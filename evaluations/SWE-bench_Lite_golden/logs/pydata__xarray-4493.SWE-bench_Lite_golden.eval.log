[pydata__xarray__0.12] [pydata__xarray-4493] Task Metadata:
	- Instance ID: pydata__xarray-4493
	- Testbed: pydata__xarray__0.12
	- 
	- Evaluation Model: SWE-bench_Lite_golden 
[pydata__xarray__0.12] [pydata__xarray-4493] Command: git status --porcelain 
[pydata__xarray__0.12] [pydata__xarray-4493] Subprocess args: {"cwd": "/home/swe-bench/pydata__xarray", "check": true, "shell": false, "capture_output": false, "text": true, "stdout": -1, "stderr": -2} 
[pydata__xarray__0.12] [pydata__xarray-4493] Std. Output:
 
[pydata__xarray__0.12] [pydata__xarray-4493] Return Code: 0 
[pydata__xarray__0.12] [pydata__xarray-4493] Command: git -c advice.detachedHead=false checkout a5f53e203c52a7605d5db799864046471115d04f 
[pydata__xarray__0.12] [pydata__xarray-4493] Subprocess args: {"cwd": "/home/swe-bench/pydata__xarray", "check": true, "shell": false, "capture_output": false, "text": true, "stdout": -1, "stderr": -2} 
[pydata__xarray__0.12] [pydata__xarray-4493] Std. Output:
Previous HEAD position was 1c198a19 Convert attribute and dimension names to strings when generating HTML repr (#5149)
HEAD is now at a5f53e20 don't skip the doctests CI (#4869)
 
[pydata__xarray__0.12] [pydata__xarray-4493] Return Code: 0 
[pydata__xarray__0.12] [pydata__xarray-4493] Command: git apply -v /home/swe-bench/temp_pydata__xarray-4493_pred_try.patch 
[pydata__xarray__0.12] [pydata__xarray-4493] Subprocess args: {"cwd": "/home/swe-bench/pydata__xarray", "check": false, "shell": false, "capture_output": false, "text": true, "stdout": -1, "stderr": -2} 
[pydata__xarray__0.12] [pydata__xarray-4493] Std. Output:
Checking patch xarray/core/variable.py...
Applied patch xarray/core/variable.py cleanly.
 
[pydata__xarray__0.12] [pydata__xarray-4493] Return Code: 0 
[pydata__xarray__0.12] [pydata__xarray-4493] Apply patch successful (pred_try) 
>>>>> Applied Patch (pred_try)
[pydata__xarray__0.12] [pydata__xarray-4493] Command: git apply -v -R /home/swe-bench/temp_pydata__xarray-4493_pred_try.patch 
[pydata__xarray__0.12] [pydata__xarray-4493] Subprocess args: {"cwd": "/home/swe-bench/pydata__xarray", "check": false, "shell": false, "capture_output": false, "text": true, "stdout": -1, "stderr": -2} 
[pydata__xarray__0.12] [pydata__xarray-4493] Std. Output:
Checking patch xarray/core/variable.py...
Applied patch xarray/core/variable.py cleanly.
 
[pydata__xarray__0.12] [pydata__xarray-4493] Return Code: 0 
[pydata__xarray__0.12] [pydata__xarray-4493] Revert patch successful (pred_try) 
>>>>> Applied Patch (pred_try)
[pydata__xarray__0.12] [pydata__xarray-4493] Command: git apply -v /home/swe-bench/temp_pydata__xarray-4493_pred.patch 
[pydata__xarray__0.12] [pydata__xarray-4493] Subprocess args: {"cwd": "/home/swe-bench/pydata__xarray", "check": false, "shell": false, "capture_output": false, "text": true, "stdout": -1, "stderr": -2} 
[pydata__xarray__0.12] [pydata__xarray-4493] Std. Output:
Checking patch xarray/core/variable.py...
Applied patch xarray/core/variable.py cleanly.
 
[pydata__xarray__0.12] [pydata__xarray-4493] Return Code: 0 
[pydata__xarray__0.12] [pydata__xarray-4493] Apply patch successful (pred) 
>>>>> Applied Patch (pred)
[pydata__xarray__0.12] [pydata__xarray-4493] Command: git restore xarray/tests/test_dask.py 
[pydata__xarray__0.12] [pydata__xarray-4493] Subprocess args: {"cwd": "/home/swe-bench/pydata__xarray", "check": true, "shell": false, "capture_output": false, "text": true, "stdout": -1, "stderr": -2} 
[pydata__xarray__0.12] [pydata__xarray-4493] Std. Output:
 
[pydata__xarray__0.12] [pydata__xarray-4493] Return Code: 0 
[pydata__xarray__0.12] [pydata__xarray-4493] Command: git restore xarray/tests/test_dataset.py 
[pydata__xarray__0.12] [pydata__xarray-4493] Subprocess args: {"cwd": "/home/swe-bench/pydata__xarray", "check": true, "shell": false, "capture_output": false, "text": true, "stdout": -1, "stderr": -2} 
[pydata__xarray__0.12] [pydata__xarray-4493] Std. Output:
 
[pydata__xarray__0.12] [pydata__xarray-4493] Return Code: 0 
[pydata__xarray__0.12] [pydata__xarray-4493] Command: git restore xarray/tests/test_interp.py 
[pydata__xarray__0.12] [pydata__xarray-4493] Subprocess args: {"cwd": "/home/swe-bench/pydata__xarray", "check": true, "shell": false, "capture_output": false, "text": true, "stdout": -1, "stderr": -2} 
[pydata__xarray__0.12] [pydata__xarray-4493] Std. Output:
 
[pydata__xarray__0.12] [pydata__xarray-4493] Return Code: 0 
[pydata__xarray__0.12] [pydata__xarray-4493] Command: git restore xarray/tests/test_variable.py 
[pydata__xarray__0.12] [pydata__xarray-4493] Subprocess args: {"cwd": "/home/swe-bench/pydata__xarray", "check": true, "shell": false, "capture_output": false, "text": true, "stdout": -1, "stderr": -2} 
[pydata__xarray__0.12] [pydata__xarray-4493] Std. Output:
 
[pydata__xarray__0.12] [pydata__xarray-4493] Return Code: 0 
[pydata__xarray__0.12] [pydata__xarray-4493] Command: git apply -v /home/swe-bench/temp_pydata__xarray-4493_test.patch 
[pydata__xarray__0.12] [pydata__xarray-4493] Subprocess args: {"cwd": "/home/swe-bench/pydata__xarray", "check": false, "shell": false, "capture_output": false, "text": true, "stdout": -1, "stderr": -2} 
[pydata__xarray__0.12] [pydata__xarray-4493] Std. Output:
Checking patch xarray/tests/test_dask.py...
Checking patch xarray/tests/test_dataset.py...
Checking patch xarray/tests/test_interp.py...
Checking patch xarray/tests/test_variable.py...
Applied patch xarray/tests/test_dask.py cleanly.
Applied patch xarray/tests/test_dataset.py cleanly.
Applied patch xarray/tests/test_interp.py cleanly.
Applied patch xarray/tests/test_variable.py cleanly.
 
[pydata__xarray__0.12] [pydata__xarray-4493] Return Code: 0 
[pydata__xarray__0.12] [pydata__xarray-4493] Apply patch successful (test) 
>>>>> Applied Patch (test)
Test Script: conda run -n pydata__xarray__0.12 pytest --no-header -rA -p no:cacheprovider xarray/tests/test_dask.py xarray/tests/test_dataset.py xarray/tests/test_interp.py xarray/tests/test_variable.py;
[pydata__xarray__0.12] [pydata__xarray-4493] Command: conda run -n pydata__xarray__0.12 pytest --no-header -rA -p no:cacheprovider xarray/tests/test_dask.py xarray/tests/test_dataset.py xarray/tests/test_interp.py xarray/tests/test_variable.py 
[pydata__xarray__0.12] [pydata__xarray-4493] Subprocess args: {"cwd": "/home/swe-bench/pydata__xarray", "check": false, "shell": false, "capture_output": false, "text": true, "stdout": -1, "stderr": -2, "timeout": 900} 
[pydata__xarray__0.12] [pydata__xarray-4493] Std. Output:
============================= test session starts ==============================
collected 1853 items

xarray/tests/test_dask.py .........................................s.... [  2%]
.......x.............F...........FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF.. [  6%]
........................................................................ [ 10%]
...................                                                      [ 11%]
xarray/tests/test_dataset.py ........................................... [ 13%]
.FF..F............F..............................F.....xX............... [ 17%]
.....................................................................F.. [ 21%]
........................................................................ [ 25%]
..........F............................................................. [ 29%]
........................................................................ [ 33%]
........................................................................ [ 36%]
........................................................................ [ 40%]
..........................ssssssssssssssss.............................. [ 44%]
........................................................................ [ 48%]
........................................................................ [ 52%]
........................................................................ [ 56%]
........................................................................ [ 60%]
..............F.XX..................                                     [ 62%]
xarray/tests/test_interp.py .....................................x...... [ 64%]
........................................................................ [ 68%]
........................................................................ [ 72%]
.......................................................                  [ 75%]
xarray/tests/test_variable.py ......................x................... [ 77%]
....................XX.X.....XX.X.....XX.X.....XX.X.....XX.X............ [ 81%]
........................................................................ [ 85%]
.....................................x.................................. [ 89%]
.xX.X.....xX.X.....xx.X.....xx.X.....xx.X..........xxxX................. [ 93%]
.........x...............................................xxxxxxxxxxxxxxx [ 96%]
xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx.........F.....                 [100%]

=================================== FAILURES ===================================
_______________________ test_persist_Dataset[<lambda>1] ________________________

persist = <function <lambda> at 0x77b3247891b0>

    @pytest.mark.parametrize(
        "persist", [lambda x: x.persist(), lambda x: dask.persist(x)[0]]
    )
    def test_persist_Dataset(persist):
        ds = Dataset({"foo": ("x", range(5)), "bar": ("x", range(5))}).chunk()
        ds = ds + 1
        n = len(ds.foo.data.dask)
    
>       ds2 = persist(ds)

/home/swe-bench/pydata__xarray/xarray/tests/test_dask.py:925: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/home/swe-bench/pydata__xarray/xarray/tests/test_dask.py:918: in <lambda>
    "persist", [lambda x: x.persist(), lambda x: dask.persist(x)[0]]
/home/swe-bench/miniconda3/envs/pydata__xarray__0.12/lib/python3.10/site-packages/dask/base.py:1001: in persist
    results2 = [r({k: d[k] for k in ks}, *s) for r, ks, s in postpersists]
/home/swe-bench/miniconda3/envs/pydata__xarray__0.12/lib/python3.10/site-packages/dask/base.py:1001: in <listcomp>
    results2 = [r({k: d[k] for k in ks}, *s) for r, ks, s in postpersists]
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsk = {('add-c28f5ace73c7e14e4df299f2eb070781', 0): array([1, 2, 3, 4, 5]), ('add-e48db14e37d48f3bcff34fa5b9a98fa0', 0): array([1, 2, 3, 4, 5])}
info = [(True, 'foo', (<function Variable._dask_finalize at 0x77b350738dc0>, (<bound method Array._rebuild of dask.array<add,...build of dask.array<add, shape=(5,), dtype=int64, chunksize=(5,), chunktype=numpy.ndarray>>, (), ('x',), None, None)))]
args = (set(), {'x': 5}, None, {}, None, None), variables = {}
is_persist = True, is_dask = True

    @staticmethod
    def _dask_postpersist(dsk, info, *args):
        variables = {}
        # postpersist is called in both dask.optimize and dask.persist
        # When persisting, we want to filter out unrelated keys for
        # each Variable's task graph.
        is_persist = len(dsk) == len(info)
        for is_dask, k, v in info:
            if is_dask:
                func, args2 = v
                if is_persist:
>                   name = args2[1][0]
E                   IndexError: tuple index out of range

/home/swe-bench/pydata__xarray/xarray/core/dataset.py:932: IndexError
____________________________ test_map_blocks_error _____________________________

map_da = <xarray.DataArray 'a' (x: 10, y: 20)>
dask.array<xarray-<this-array>, shape=(10, 20), dtype=float64, chunksize=(4, 5),...meta=np.ndarray>
    cxy      (x, y) int64 dask.array<chunksize=(4, 5), meta=np.ndarray>
Attributes:
    test:     test
map_ds = <xarray.Dataset>
Dimensions:  (x: 10, y: 20, z: 4)
Coordinates:
  * x        (x) int64 0 1 2 3 4 5 6 7 8 9
  * y      ...64 1 1 1 1
    e        (x, y) int64 100 101 102 103 104 105 ... 123 124 125 126 127 128
Attributes:
    test:     test

    def test_map_blocks_error(map_da, map_ds):
        def bad_func(darray):
            return (darray * darray.x + 5 * darray.y)[:1, :1]
    
        with raises_regex(ValueError, "Received dimension 'x' of length 1"):
>           xr.map_blocks(bad_func, map_da).compute()

/home/swe-bench/pydata__xarray/xarray/tests/test_dask.py:1074: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/home/swe-bench/pydata__xarray/xarray/core/parallel.py:566: in map_blocks
    data = dask.array.Array(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

cls = <class 'dask.array.core.Array'>
dask = HighLevelGraph with 8 layers.
<dask.highlevelgraph.HighLevelGraph object at 0x77b3240aa3b0>
 0. xarray-<this-array>-cd...9938f426b28-cxy
 6. bad_func-edfaf720c4c091694d4339938f426b28-ndcoord
 7. bad_func-edfaf720c4c091694d4339938f426b28-c2

name = 'bad_func-edfaf720c4c091694d4339938f426b28-c2', chunks = []
dtype = dtype('float64'), meta = array(2.5e-323), shape = None

    def __new__(cls, dask, name, chunks, dtype=None, meta=None, shape=None):
        self = super().__new__(cls)
        assert isinstance(dask, Mapping)
        if not isinstance(dask, HighLevelGraph):
            dask = HighLevelGraph.from_collections(name, dask, dependencies=())
        self.dask = dask
        self._name = str(name)
        meta = meta_from_array(meta, dtype=dtype)
    
        if (
            isinstance(chunks, str)
            or isinstance(chunks, tuple)
            and chunks
            and any(isinstance(c, str) for c in chunks)
        ):
            dt = meta.dtype
        else:
            dt = None
        self._chunks = normalize_chunks(chunks, shape, dtype=dt)
        if self.chunks is None:
            raise ValueError(CHUNKS_NONE_ERROR_MESSAGE)
        self._meta = meta_from_array(meta, ndim=self.ndim, dtype=dtype)
    
        for plugin in config.get("array_plugins", ()):
            result = plugin(self)
            if result is not None:
                self = result
    
        try:
            layer = self.dask.layers[name]
        except (AttributeError, KeyError):
            # self is no longer an Array after applying the plugins, OR
            # a plugin replaced the HighLevelGraph with a plain dict, OR
            # name is not the top layer's name (this can happen after the layer is
            # manipulated, to avoid a collision)
            pass
        else:
>           if layer.collection_annotations is None:
E           AttributeError: 'dict' object has no attribute 'collection_annotations'

/home/swe-bench/miniconda3/envs/pydata__xarray__0.12/lib/python3.10/site-packages/dask/array/core.py:1365: AttributeError
____________________________ test_map_blocks[obj0] _____________________________

obj = <xarray.DataArray 'a' (x: 10, y: 20)>
dask.array<xarray-<this-array>, shape=(10, 20), dtype=float64, chunksize=(4, 5),...meta=np.ndarray>
    cxy      (x, y) int64 dask.array<chunksize=(4, 5), meta=np.ndarray>
Attributes:
    test:     test

    @pytest.mark.parametrize("obj", [make_da(), make_ds()])
    def test_map_blocks(obj):
        def func(obj):
            result = obj + obj.x + 5 * obj.y
            return result
    
        with raise_if_dask_computes():
>           actual = xr.map_blocks(func, obj)

/home/swe-bench/pydata__xarray/xarray/tests/test_dask.py:1111: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/home/swe-bench/pydata__xarray/xarray/core/parallel.py:566: in map_blocks
    data = dask.array.Array(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

cls = <class 'dask.array.core.Array'>
dask = HighLevelGraph with 8 layers.
<dask.highlevelgraph.HighLevelGraph object at 0x77b3251bd810>
 0. xarray-<this-array>-cd...1694d4339938f426b28-cxy
 6. func-edfaf720c4c091694d4339938f426b28-ndcoord
 7. func-edfaf720c4c091694d4339938f426b28-c2

name = 'func-edfaf720c4c091694d4339938f426b28-c2', chunks = []
dtype = dtype('float64'), meta = array(2.5e-323), shape = None

    def __new__(cls, dask, name, chunks, dtype=None, meta=None, shape=None):
        self = super().__new__(cls)
        assert isinstance(dask, Mapping)
        if not isinstance(dask, HighLevelGraph):
            dask = HighLevelGraph.from_collections(name, dask, dependencies=())
        self.dask = dask
        self._name = str(name)
        meta = meta_from_array(meta, dtype=dtype)
    
        if (
            isinstance(chunks, str)
            or isinstance(chunks, tuple)
            and chunks
            and any(isinstance(c, str) for c in chunks)
        ):
            dt = meta.dtype
        else:
            dt = None
        self._chunks = normalize_chunks(chunks, shape, dtype=dt)
        if self.chunks is None:
            raise ValueError(CHUNKS_NONE_ERROR_MESSAGE)
        self._meta = meta_from_array(meta, ndim=self.ndim, dtype=dtype)
    
        for plugin in config.get("array_plugins", ()):
            result = plugin(self)
            if result is not None:
                self = result
    
        try:
            layer = self.dask.layers[name]
        except (AttributeError, KeyError):
            # self is no longer an Array after applying the plugins, OR
            # a plugin replaced the HighLevelGraph with a plain dict, OR
            # name is not the top layer's name (this can happen after the layer is
            # manipulated, to avoid a collision)
            pass
        else:
>           if layer.collection_annotations is None:
E           AttributeError: 'dict' object has no attribute 'collection_annotations'

/home/swe-bench/miniconda3/envs/pydata__xarray__0.12/lib/python3.10/site-packages/dask/array/core.py:1365: AttributeError
____________________________ test_map_blocks[obj1] _____________________________

obj = <xarray.Dataset>
Dimensions:  (x: 10, y: 20, z: 4)
Coordinates:
  * x        (x) int64 0 1 2 3 4 5 6 7 8 9
  * y      ...64 1 1 1 1
    e        (x, y) int64 100 101 102 103 104 105 ... 123 124 125 126 127 128
Attributes:
    test:     test

    @pytest.mark.parametrize("obj", [make_da(), make_ds()])
    def test_map_blocks(obj):
        def func(obj):
            result = obj + obj.x + 5 * obj.y
            return result
    
        with raise_if_dask_computes():
>           actual = xr.map_blocks(func, obj)

/home/swe-bench/pydata__xarray/xarray/tests/test_dask.py:1111: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/home/swe-bench/pydata__xarray/xarray/core/parallel.py:566: in map_blocks
    data = dask.array.Array(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

cls = <class 'dask.array.core.Array'>
dask = HighLevelGraph with 20 layers.
<dask.highlevelgraph.HighLevelGraph object at 0x77b3240ab2e0>
 0. array-9fc76b19d9f2299...a429cd05fd7f8f0ba-cxy
 18. func-8e0b79e9fe44b20a429cd05fd7f8f0ba-ndcoord
 19. func-8e0b79e9fe44b20a429cd05fd7f8f0ba-c2

name = 'func-8e0b79e9fe44b20a429cd05fd7f8f0ba-c2', chunks = []
dtype = dtype('float64'), meta = array(2.5e-323), shape = None

    def __new__(cls, dask, name, chunks, dtype=None, meta=None, shape=None):
        self = super().__new__(cls)
        assert isinstance(dask, Mapping)
        if not isinstance(dask, HighLevelGraph):
            dask = HighLevelGraph.from_collections(name, dask, dependencies=())
        self.dask = dask
        self._name = str(name)
        meta = meta_from_array(meta, dtype=dtype)
    
        if (
            isinstance(chunks, str)
            or isinstance(chunks, tuple)
            and chunks
            and any(isinstance(c, str) for c in chunks)
        ):
            dt = meta.dtype
        else:
            dt = None
        self._chunks = normalize_chunks(chunks, shape, dtype=dt)
        if self.chunks is None:
            raise ValueError(CHUNKS_NONE_ERROR_MESSAGE)
        self._meta = meta_from_array(meta, ndim=self.ndim, dtype=dtype)
    
        for plugin in config.get("array_plugins", ()):
            result = plugin(self)
            if result is not None:
                self = result
    
        try:
            layer = self.dask.layers[name]
        except (AttributeError, KeyError):
            # self is no longer an Array after applying the plugins, OR
            # a plugin replaced the HighLevelGraph with a plain dict, OR
            # name is not the top layer's name (this can happen after the layer is
            # manipulated, to avoid a collision)
            pass
        else:
>           if layer.collection_annotations is None:
E           AttributeError: 'dict' object has no attribute 'collection_annotations'

/home/swe-bench/miniconda3/envs/pydata__xarray__0.12/lib/python3.10/site-packages/dask/array/core.py:1365: AttributeError
__________________ test_map_blocks_convert_args_to_list[obj0] __________________

obj = <xarray.DataArray 'a' (x: 10, y: 20)>
dask.array<xarray-<this-array>, shape=(10, 20), dtype=float64, chunksize=(4, 5),...meta=np.ndarray>
    cxy      (x, y) int64 dask.array<chunksize=(4, 5), meta=np.ndarray>
Attributes:
    test:     test

    @pytest.mark.parametrize("obj", [make_da(), make_ds()])
    def test_map_blocks_convert_args_to_list(obj):
        expected = obj + 10
        with raise_if_dask_computes():
>           actual = xr.map_blocks(operator.add, obj, [10])

/home/swe-bench/pydata__xarray/xarray/tests/test_dask.py:1121: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/home/swe-bench/pydata__xarray/xarray/core/parallel.py:566: in map_blocks
    data = dask.array.Array(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

cls = <class 'dask.array.core.Array'>
dask = HighLevelGraph with 8 layers.
<dask.highlevelgraph.HighLevelGraph object at 0x77b324c63ca0>
 0. xarray-<this-array>-cd...b3dbab2ea2c4e153c8a63-cxy
 6. add-947b2858638b3dbab2ea2c4e153c8a63-ndcoord
 7. add-947b2858638b3dbab2ea2c4e153c8a63-c2

name = 'add-947b2858638b3dbab2ea2c4e153c8a63-c2', chunks = []
dtype = dtype('float64'), meta = array(10.), shape = None

    def __new__(cls, dask, name, chunks, dtype=None, meta=None, shape=None):
        self = super().__new__(cls)
        assert isinstance(dask, Mapping)
        if not isinstance(dask, HighLevelGraph):
            dask = HighLevelGraph.from_collections(name, dask, dependencies=())
        self.dask = dask
        self._name = str(name)
        meta = meta_from_array(meta, dtype=dtype)
    
        if (
            isinstance(chunks, str)
            or isinstance(chunks, tuple)
            and chunks
            and any(isinstance(c, str) for c in chunks)
        ):
            dt = meta.dtype
        else:
            dt = None
        self._chunks = normalize_chunks(chunks, shape, dtype=dt)
        if self.chunks is None:
            raise ValueError(CHUNKS_NONE_ERROR_MESSAGE)
        self._meta = meta_from_array(meta, ndim=self.ndim, dtype=dtype)
    
        for plugin in config.get("array_plugins", ()):
            result = plugin(self)
            if result is not None:
                self = result
    
        try:
            layer = self.dask.layers[name]
        except (AttributeError, KeyError):
            # self is no longer an Array after applying the plugins, OR
            # a plugin replaced the HighLevelGraph with a plain dict, OR
            # name is not the top layer's name (this can happen after the layer is
            # manipulated, to avoid a collision)
            pass
        else:
>           if layer.collection_annotations is None:
E           AttributeError: 'dict' object has no attribute 'collection_annotations'

/home/swe-bench/miniconda3/envs/pydata__xarray__0.12/lib/python3.10/site-packages/dask/array/core.py:1365: AttributeError
__________________ test_map_blocks_convert_args_to_list[obj1] __________________

obj = <xarray.Dataset>
Dimensions:  (x: 10, y: 20, z: 4)
Coordinates:
  * x        (x) int64 0 1 2 3 4 5 6 7 8 9
  * y      ...64 1 1 1 1
    e        (x, y) int64 100 101 102 103 104 105 ... 123 124 125 126 127 128
Attributes:
    test:     test

    @pytest.mark.parametrize("obj", [make_da(), make_ds()])
    def test_map_blocks_convert_args_to_list(obj):
        expected = obj + 10
        with raise_if_dask_computes():
>           actual = xr.map_blocks(operator.add, obj, [10])

/home/swe-bench/pydata__xarray/xarray/tests/test_dask.py:1121: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/home/swe-bench/pydata__xarray/xarray/core/parallel.py:566: in map_blocks
    data = dask.array.Array(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

cls = <class 'dask.array.core.Array'>
dask = HighLevelGraph with 20 layers.
<dask.highlevelgraph.HighLevelGraph object at 0x77b324357cd0>
 0. array-9fc76b19d9f2299...d045b3a7e5d511a1dc3-cxy
 18. add-fa019c69f3aead045b3a7e5d511a1dc3-ndcoord
 19. add-fa019c69f3aead045b3a7e5d511a1dc3-c2

name = 'add-fa019c69f3aead045b3a7e5d511a1dc3-c2', chunks = []
dtype = dtype('float64'), meta = array(5.e-323), shape = None

    def __new__(cls, dask, name, chunks, dtype=None, meta=None, shape=None):
        self = super().__new__(cls)
        assert isinstance(dask, Mapping)
        if not isinstance(dask, HighLevelGraph):
            dask = HighLevelGraph.from_collections(name, dask, dependencies=())
        self.dask = dask
        self._name = str(name)
        meta = meta_from_array(meta, dtype=dtype)
    
        if (
            isinstance(chunks, str)
            or isinstance(chunks, tuple)
            and chunks
            and any(isinstance(c, str) for c in chunks)
        ):
            dt = meta.dtype
        else:
            dt = None
        self._chunks = normalize_chunks(chunks, shape, dtype=dt)
        if self.chunks is None:
            raise ValueError(CHUNKS_NONE_ERROR_MESSAGE)
        self._meta = meta_from_array(meta, ndim=self.ndim, dtype=dtype)
    
        for plugin in config.get("array_plugins", ()):
            result = plugin(self)
            if result is not None:
                self = result
    
        try:
            layer = self.dask.layers[name]
        except (AttributeError, KeyError):
            # self is no longer an Array after applying the plugins, OR
            # a plugin replaced the HighLevelGraph with a plain dict, OR
            # name is not the top layer's name (this can happen after the layer is
            # manipulated, to avoid a collision)
            pass
        else:
>           if layer.collection_annotations is None:
E           AttributeError: 'dict' object has no attribute 'collection_annotations'

/home/swe-bench/miniconda3/envs/pydata__xarray__0.12/lib/python3.10/site-packages/dask/array/core.py:1365: AttributeError
__________________________ test_map_blocks_dask_args ___________________________

    def test_map_blocks_dask_args():
        da1 = xr.DataArray(
            np.ones((10, 20)),
            dims=["x", "y"],
            coords={"x": np.arange(10), "y": np.arange(20)},
        ).chunk({"x": 5, "y": 4})
    
        # check that block shapes are the same
        def sumda(da1, da2):
            assert da1.shape == da2.shape
            return da1 + da2
    
        da2 = da1 + 1
        with raise_if_dask_computes():
>           mapped = xr.map_blocks(sumda, da1, args=[da2])

/home/swe-bench/pydata__xarray/xarray/tests/test_dask.py:1140: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/home/swe-bench/pydata__xarray/xarray/core/parallel.py:566: in map_blocks
    data = dask.array.Array(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

cls = <class 'dask.array.core.Array'>
dask = HighLevelGraph with 4 layers.
<dask.highlevelgraph.HighLevelGraph object at 0x77b32427d7b0>
 0. xarray-<this-array>-94...1f1dece69902a675278
 2. sumda-2537f054f1983d7f6d2a406a697ff9e7
 3. sumda-2537f054f1983d7f6d2a406a697ff9e7-<this-array>

name = 'sumda-2537f054f1983d7f6d2a406a697ff9e7-<this-array>'
chunks = [(5, 5), (4, 4, 4, 4, 4)], dtype = dtype('float64')
meta = array(5.e-323), shape = None

    def __new__(cls, dask, name, chunks, dtype=None, meta=None, shape=None):
        self = super().__new__(cls)
        assert isinstance(dask, Mapping)
        if not isinstance(dask, HighLevelGraph):
            dask = HighLevelGraph.from_collections(name, dask, dependencies=())
        self.dask = dask
        self._name = str(name)
        meta = meta_from_array(meta, dtype=dtype)
    
        if (
            isinstance(chunks, str)
            or isinstance(chunks, tuple)
            and chunks
            and any(isinstance(c, str) for c in chunks)
        ):
            dt = meta.dtype
        else:
            dt = None
        self._chunks = normalize_chunks(chunks, shape, dtype=dt)
        if self.chunks is None:
            raise ValueError(CHUNKS_NONE_ERROR_MESSAGE)
        self._meta = meta_from_array(meta, ndim=self.ndim, dtype=dtype)
    
        for plugin in config.get("array_plugins", ()):
            result = plugin(self)
            if result is not None:
                self = result
    
        try:
            layer = self.dask.layers[name]
        except (AttributeError, KeyError):
            # self is no longer an Array after applying the plugins, OR
            # a plugin replaced the HighLevelGraph with a plain dict, OR
            # name is not the top layer's name (this can happen after the layer is
            # manipulated, to avoid a collision)
            pass
        else:
>           if layer.collection_annotations is None:
E           AttributeError: 'dict' object has no attribute 'collection_annotations'

/home/swe-bench/miniconda3/envs/pydata__xarray__0.12/lib/python3.10/site-packages/dask/array/core.py:1365: AttributeError
_______________________ test_map_blocks_add_attrs[obj0] ________________________

obj = <xarray.DataArray 'a' (x: 10, y: 20)>
dask.array<xarray-<this-array>, shape=(10, 20), dtype=float64, chunksize=(4, 5),...meta=np.ndarray>
    cxy      (x, y) int64 dask.array<chunksize=(4, 5), meta=np.ndarray>
Attributes:
    test:     test

    @pytest.mark.parametrize("obj", [make_da(), make_ds()])
    def test_map_blocks_add_attrs(obj):
        def add_attrs(obj):
            obj = obj.copy(deep=True)
            obj.attrs["new"] = "new"
            obj.cxy.attrs["new2"] = "new2"
            return obj
    
        expected = add_attrs(obj)
        with raise_if_dask_computes():
>           actual = xr.map_blocks(add_attrs, obj)

/home/swe-bench/pydata__xarray/xarray/tests/test_dask.py:1188: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/home/swe-bench/pydata__xarray/xarray/core/parallel.py:566: in map_blocks
    data = dask.array.Array(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

cls = <class 'dask.array.core.Array'>
dask = HighLevelGraph with 8 layers.
<dask.highlevelgraph.HighLevelGraph object at 0x77b324d48ca0>
 0. xarray-<this-array>-cd...38f426b28-cxy
 6. add_attrs-edfaf720c4c091694d4339938f426b28-ndcoord
 7. add_attrs-edfaf720c4c091694d4339938f426b28-c2

name = 'add_attrs-edfaf720c4c091694d4339938f426b28-c2', chunks = []
dtype = dtype('float64'), meta = array(0.5), shape = None

    def __new__(cls, dask, name, chunks, dtype=None, meta=None, shape=None):
        self = super().__new__(cls)
        assert isinstance(dask, Mapping)
        if not isinstance(dask, HighLevelGraph):
            dask = HighLevelGraph.from_collections(name, dask, dependencies=())
        self.dask = dask
        self._name = str(name)
        meta = meta_from_array(meta, dtype=dtype)
    
        if (
            isinstance(chunks, str)
            or isinstance(chunks, tuple)
            and chunks
            and any(isinstance(c, str) for c in chunks)
        ):
            dt = meta.dtype
        else:
            dt = None
        self._chunks = normalize_chunks(chunks, shape, dtype=dt)
        if self.chunks is None:
            raise ValueError(CHUNKS_NONE_ERROR_MESSAGE)
        self._meta = meta_from_array(meta, ndim=self.ndim, dtype=dtype)
    
        for plugin in config.get("array_plugins", ()):
            result = plugin(self)
            if result is not None:
                self = result
    
        try:
            layer = self.dask.layers[name]
        except (AttributeError, KeyError):
            # self is no longer an Array after applying the plugins, OR
            # a plugin replaced the HighLevelGraph with a plain dict, OR
            # name is not the top layer's name (this can happen after the layer is
            # manipulated, to avoid a collision)
            pass
        else:
>           if layer.collection_annotations is None:
E           AttributeError: 'dict' object has no attribute 'collection_annotations'

/home/swe-bench/miniconda3/envs/pydata__xarray__0.12/lib/python3.10/site-packages/dask/array/core.py:1365: AttributeError
_______________________ test_map_blocks_add_attrs[obj1] ________________________

obj = <xarray.Dataset>
Dimensions:  (x: 10, y: 20, z: 4)
Coordinates:
  * x        (x) int64 0 1 2 3 4 5 6 7 8 9
  * y      ...64 1 1 1 1
    e        (x, y) int64 100 101 102 103 104 105 ... 123 124 125 126 127 128
Attributes:
    test:     test

    @pytest.mark.parametrize("obj", [make_da(), make_ds()])
    def test_map_blocks_add_attrs(obj):
        def add_attrs(obj):
            obj = obj.copy(deep=True)
            obj.attrs["new"] = "new"
            obj.cxy.attrs["new2"] = "new2"
            return obj
    
        expected = add_attrs(obj)
        with raise_if_dask_computes():
>           actual = xr.map_blocks(add_attrs, obj)

/home/swe-bench/pydata__xarray/xarray/tests/test_dask.py:1188: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/home/swe-bench/pydata__xarray/xarray/core/parallel.py:566: in map_blocks
    data = dask.array.Array(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

cls = <class 'dask.array.core.Array'>
dask = HighLevelGraph with 20 layers.
<dask.highlevelgraph.HighLevelGraph object at 0x77b324c48820>
 0. array-9fc76b19d9f2299...7f8f0ba-cxy
 18. add_attrs-8e0b79e9fe44b20a429cd05fd7f8f0ba-ndcoord
 19. add_attrs-8e0b79e9fe44b20a429cd05fd7f8f0ba-c2

name = 'add_attrs-8e0b79e9fe44b20a429cd05fd7f8f0ba-c2', chunks = []
dtype = dtype('float64'), meta = array(0.5), shape = None

    def __new__(cls, dask, name, chunks, dtype=None, meta=None, shape=None):
        self = super().__new__(cls)
        assert isinstance(dask, Mapping)
        if not isinstance(dask, HighLevelGraph):
            dask = HighLevelGraph.from_collections(name, dask, dependencies=())
        self.dask = dask
        self._name = str(name)
        meta = meta_from_array(meta, dtype=dtype)
    
        if (
            isinstance(chunks, str)
            or isinstance(chunks, tuple)
            and chunks
            and any(isinstance(c, str) for c in chunks)
        ):
            dt = meta.dtype
        else:
            dt = None
        self._chunks = normalize_chunks(chunks, shape, dtype=dt)
        if self.chunks is None:
            raise ValueError(CHUNKS_NONE_ERROR_MESSAGE)
        self._meta = meta_from_array(meta, ndim=self.ndim, dtype=dtype)
    
        for plugin in config.get("array_plugins", ()):
            result = plugin(self)
            if result is not None:
                self = result
    
        try:
            layer = self.dask.layers[name]
        except (AttributeError, KeyError):
            # self is no longer an Array after applying the plugins, OR
            # a plugin replaced the HighLevelGraph with a plain dict, OR
            # name is not the top layer's name (this can happen after the layer is
            # manipulated, to avoid a collision)
            pass
        else:
>           if layer.collection_annotations is None:
E           AttributeError: 'dict' object has no attribute 'collection_annotations'

/home/swe-bench/miniconda3/envs/pydata__xarray__0.12/lib/python3.10/site-packages/dask/array/core.py:1365: AttributeError
_________________________ test_map_blocks_change_name __________________________

map_da = <xarray.DataArray 'a' (x: 10, y: 20)>
dask.array<xarray-<this-array>, shape=(10, 20), dtype=float64, chunksize=(4, 5),...meta=np.ndarray>
    cxy      (x, y) int64 dask.array<chunksize=(4, 5), meta=np.ndarray>
Attributes:
    test:     test

    def test_map_blocks_change_name(map_da):
        def change_name(obj):
            obj = obj.copy(deep=True)
            obj.name = "new"
            return obj
    
        expected = change_name(map_da)
        with raise_if_dask_computes():
>           actual = xr.map_blocks(change_name, map_da)

/home/swe-bench/pydata__xarray/xarray/tests/test_dask.py:1206: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/home/swe-bench/pydata__xarray/xarray/core/parallel.py:566: in map_blocks
    data = dask.array.Array(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

cls = <class 'dask.array.core.Array'>
dask = HighLevelGraph with 8 layers.
<dask.highlevelgraph.HighLevelGraph object at 0x77b324aa8850>
 0. xarray-<this-array>-cd...26b28-cxy
 6. change_name-edfaf720c4c091694d4339938f426b28-ndcoord
 7. change_name-edfaf720c4c091694d4339938f426b28-c2

name = 'change_name-edfaf720c4c091694d4339938f426b28-c2', chunks = []
dtype = dtype('float64'), meta = array(0.5), shape = None

    def __new__(cls, dask, name, chunks, dtype=None, meta=None, shape=None):
        self = super().__new__(cls)
        assert isinstance(dask, Mapping)
        if not isinstance(dask, HighLevelGraph):
            dask = HighLevelGraph.from_collections(name, dask, dependencies=())
        self.dask = dask
        self._name = str(name)
        meta = meta_from_array(meta, dtype=dtype)
    
        if (
            isinstance(chunks, str)
            or isinstance(chunks, tuple)
            and chunks
            and any(isinstance(c, str) for c in chunks)
        ):
            dt = meta.dtype
        else:
            dt = None
        self._chunks = normalize_chunks(chunks, shape, dtype=dt)
        if self.chunks is None:
            raise ValueError(CHUNKS_NONE_ERROR_MESSAGE)
        self._meta = meta_from_array(meta, ndim=self.ndim, dtype=dtype)
    
        for plugin in config.get("array_plugins", ()):
            result = plugin(self)
            if result is not None:
                self = result
    
        try:
            layer = self.dask.layers[name]
        except (AttributeError, KeyError):
            # self is no longer an Array after applying the plugins, OR
            # a plugin replaced the HighLevelGraph with a plain dict, OR
            # name is not the top layer's name (this can happen after the layer is
            # manipulated, to avoid a collision)
            pass
        else:
>           if layer.collection_annotations is None:
E           AttributeError: 'dict' object has no attribute 'collection_annotations'

/home/swe-bench/miniconda3/envs/pydata__xarray__0.12/lib/python3.10/site-packages/dask/array/core.py:1365: AttributeError
_________________________ test_map_blocks_kwargs[obj0] _________________________

obj = <xarray.DataArray 'a' (x: 10, y: 20)>
dask.array<xarray-<this-array>, shape=(10, 20), dtype=float64, chunksize=(4, 5),...meta=np.ndarray>
    cxy      (x, y) int64 dask.array<chunksize=(4, 5), meta=np.ndarray>
Attributes:
    test:     test

    @pytest.mark.parametrize("obj", [make_da(), make_ds()])
    def test_map_blocks_kwargs(obj):
        expected = xr.full_like(obj, fill_value=np.nan)
        with raise_if_dask_computes():
>           actual = xr.map_blocks(xr.full_like, obj, kwargs=dict(fill_value=np.nan))

/home/swe-bench/pydata__xarray/xarray/tests/test_dask.py:1215: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/home/swe-bench/pydata__xarray/xarray/core/parallel.py:566: in map_blocks
    data = dask.array.Array(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

cls = <class 'dask.array.core.Array'>
dask = HighLevelGraph with 8 layers.
<dask.highlevelgraph.HighLevelGraph object at 0x77b324b1fbe0>
 0. xarray-<this-array>-cd...653cd3f8f-cxy
 6. full_like-d98b1bdfab2232904404cc2653cd3f8f-ndcoord
 7. full_like-d98b1bdfab2232904404cc2653cd3f8f-c2

name = 'full_like-d98b1bdfab2232904404cc2653cd3f8f-c2', chunks = []
dtype = dtype('float64'), meta = array(nan), shape = None

    def __new__(cls, dask, name, chunks, dtype=None, meta=None, shape=None):
        self = super().__new__(cls)
        assert isinstance(dask, Mapping)
        if not isinstance(dask, HighLevelGraph):
            dask = HighLevelGraph.from_collections(name, dask, dependencies=())
        self.dask = dask
        self._name = str(name)
        meta = meta_from_array(meta, dtype=dtype)
    
        if (
            isinstance(chunks, str)
            or isinstance(chunks, tuple)
            and chunks
            and any(isinstance(c, str) for c in chunks)
        ):
            dt = meta.dtype
        else:
            dt = None
        self._chunks = normalize_chunks(chunks, shape, dtype=dt)
        if self.chunks is None:
            raise ValueError(CHUNKS_NONE_ERROR_MESSAGE)
        self._meta = meta_from_array(meta, ndim=self.ndim, dtype=dtype)
    
        for plugin in config.get("array_plugins", ()):
            result = plugin(self)
            if result is not None:
                self = result
    
        try:
            layer = self.dask.layers[name]
        except (AttributeError, KeyError):
            # self is no longer an Array after applying the plugins, OR
            # a plugin replaced the HighLevelGraph with a plain dict, OR
            # name is not the top layer's name (this can happen after the layer is
            # manipulated, to avoid a collision)
            pass
        else:
>           if layer.collection_annotations is None:
E           AttributeError: 'dict' object has no attribute 'collection_annotations'

/home/swe-bench/miniconda3/envs/pydata__xarray__0.12/lib/python3.10/site-packages/dask/array/core.py:1365: AttributeError
_________________________ test_map_blocks_kwargs[obj1] _________________________

obj = <xarray.Dataset>
Dimensions:  (x: 10, y: 20, z: 4)
Coordinates:
  * x        (x) int64 0 1 2 3 4 5 6 7 8 9
  * y      ...64 1 1 1 1
    e        (x, y) int64 100 101 102 103 104 105 ... 123 124 125 126 127 128
Attributes:
    test:     test

    @pytest.mark.parametrize("obj", [make_da(), make_ds()])
    def test_map_blocks_kwargs(obj):
        expected = xr.full_like(obj, fill_value=np.nan)
        with raise_if_dask_computes():
>           actual = xr.map_blocks(xr.full_like, obj, kwargs=dict(fill_value=np.nan))

/home/swe-bench/pydata__xarray/xarray/tests/test_dask.py:1215: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/home/swe-bench/pydata__xarray/xarray/core/parallel.py:566: in map_blocks
    data = dask.array.Array(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

cls = <class 'dask.array.core.Array'>
dask = HighLevelGraph with 20 layers.
<dask.highlevelgraph.HighLevelGraph object at 0x77b324c49330>
 0. array-9fc76b19d9f2299...b395b9a2c407d4a6-c
 18. full_like-bcd4ebca7eed8ac2b395b9a2c407d4a6-b
 19. full_like-bcd4ebca7eed8ac2b395b9a2c407d4a6-a

name = 'full_like-bcd4ebca7eed8ac2b395b9a2c407d4a6-a'
chunks = [(4, 4, 2), (5, 5, 5, 5)], dtype = dtype('float64'), meta = array(nan)
shape = None

    def __new__(cls, dask, name, chunks, dtype=None, meta=None, shape=None):
        self = super().__new__(cls)
        assert isinstance(dask, Mapping)
        if not isinstance(dask, HighLevelGraph):
            dask = HighLevelGraph.from_collections(name, dask, dependencies=())
        self.dask = dask
        self._name = str(name)
        meta = meta_from_array(meta, dtype=dtype)
    
        if (
            isinstance(chunks, str)
            or isinstance(chunks, tuple)
            and chunks
            and any(isinstance(c, str) for c in chunks)
        ):
            dt = meta.dtype
        else:
            dt = None
        self._chunks = normalize_chunks(chunks, shape, dtype=dt)
        if self.chunks is None:
            raise ValueError(CHUNKS_NONE_ERROR_MESSAGE)
        self._meta = meta_from_array(meta, ndim=self.ndim, dtype=dtype)
    
        for plugin in config.get("array_plugins", ()):
            result = plugin(self)
            if result is not None:
                self = result
    
        try:
            layer = self.dask.layers[name]
        except (AttributeError, KeyError):
            # self is no longer an Array after applying the plugins, OR
            # a plugin replaced the HighLevelGraph with a plain dict, OR
            # name is not the top layer's name (this can happen after the layer is
            # manipulated, to avoid a collision)
            pass
        else:
>           if layer.collection_annotations is None:
E           AttributeError: 'dict' object has no attribute 'collection_annotations'

/home/swe-bench/miniconda3/envs/pydata__xarray__0.12/lib/python3.10/site-packages/dask/array/core.py:1365: AttributeError
___________________________ test_map_blocks_to_array ___________________________

map_ds = <xarray.Dataset>
Dimensions:  (x: 10, y: 20, z: 4)
Coordinates:
  * x        (x) int64 0 1 2 3 4 5 6 7 8 9
  * y      ...64 1 1 1 1
    e        (x, y) int64 100 101 102 103 104 105 ... 123 124 125 126 127 128
Attributes:
    test:     test

    def test_map_blocks_to_array(map_ds):
        with raise_if_dask_computes():
>           actual = xr.map_blocks(lambda x: x.to_array(), map_ds)

/home/swe-bench/pydata__xarray/xarray/tests/test_dask.py:1222: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/home/swe-bench/pydata__xarray/xarray/core/parallel.py:566: in map_blocks
    data = dask.array.Array(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

cls = <class 'dask.array.core.Array'>
dask = HighLevelGraph with 16 layers.
<dask.highlevelgraph.HighLevelGraph object at 0x77b324a624d0>
 0. array-9fc76b19d9f2299...cd05fd7f8f0ba-cxy
 14. lambda-8e0b79e9fe44b20a429cd05fd7f8f0ba-ndcoord
 15. lambda-8e0b79e9fe44b20a429cd05fd7f8f0ba-c2

name = 'lambda-8e0b79e9fe44b20a429cd05fd7f8f0ba-c2', chunks = []
dtype = dtype('float64'), meta = array(0.), shape = None

    def __new__(cls, dask, name, chunks, dtype=None, meta=None, shape=None):
        self = super().__new__(cls)
        assert isinstance(dask, Mapping)
        if not isinstance(dask, HighLevelGraph):
            dask = HighLevelGraph.from_collections(name, dask, dependencies=())
        self.dask = dask
        self._name = str(name)
        meta = meta_from_array(meta, dtype=dtype)
    
        if (
            isinstance(chunks, str)
            or isinstance(chunks, tuple)
            and chunks
            and any(isinstance(c, str) for c in chunks)
        ):
            dt = meta.dtype
        else:
            dt = None
        self._chunks = normalize_chunks(chunks, shape, dtype=dt)
        if self.chunks is None:
            raise ValueError(CHUNKS_NONE_ERROR_MESSAGE)
        self._meta = meta_from_array(meta, ndim=self.ndim, dtype=dtype)
    
        for plugin in config.get("array_plugins", ()):
            result = plugin(self)
            if result is not None:
                self = result
    
        try:
            layer = self.dask.layers[name]
        except (AttributeError, KeyError):
            # self is no longer an Array after applying the plugins, OR
            # a plugin replaced the HighLevelGraph with a plain dict, OR
            # name is not the top layer's name (this can happen after the layer is
            # manipulated, to avoid a collision)
            pass
        else:
>           if layer.collection_annotations is None:
E           AttributeError: 'dict' object has no attribute 'collection_annotations'

/home/swe-bench/miniconda3/envs/pydata__xarray__0.12/lib/python3.10/site-packages/dask/array/core.py:1365: AttributeError
________________ test_map_blocks_da_transformations[<lambda>0] _________________

func = <function <lambda> at 0x77b32478a560>
map_da = <xarray.DataArray 'a' (x: 10, y: 20)>
dask.array<xarray-<this-array>, shape=(10, 20), dtype=float64, chunksize=(4, 5),...meta=np.ndarray>
    cxy      (x, y) int64 dask.array<chunksize=(4, 5), meta=np.ndarray>
Attributes:
    test:     test

    @pytest.mark.parametrize(
        "func",
        [
            lambda x: x,
            lambda x: x.to_dataset(),
            lambda x: x.drop_vars("x"),
            lambda x: x.expand_dims(k=[1, 2, 3]),
            lambda x: x.expand_dims(k=3),
            lambda x: x.assign_coords(new_coord=("y", x.y.data * 2)),
            lambda x: x.astype(np.int32),
            lambda x: x.x,
        ],
    )
    def test_map_blocks_da_transformations(func, map_da):
        with raise_if_dask_computes():
>           actual = xr.map_blocks(func, map_da)

/home/swe-bench/pydata__xarray/xarray/tests/test_dask.py:1243: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/home/swe-bench/pydata__xarray/xarray/core/parallel.py:566: in map_blocks
    data = dask.array.Array(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

cls = <class 'dask.array.core.Array'>
dask = HighLevelGraph with 8 layers.
<dask.highlevelgraph.HighLevelGraph object at 0x77b32430fca0>
 0. xarray-<this-array>-cd...d4339938f426b28-cxy
 6. lambda-edfaf720c4c091694d4339938f426b28-ndcoord
 7. lambda-edfaf720c4c091694d4339938f426b28-c2

name = 'lambda-edfaf720c4c091694d4339938f426b28-c2', chunks = []
dtype = dtype('float64'), meta = array(6.e-323), shape = None

    def __new__(cls, dask, name, chunks, dtype=None, meta=None, shape=None):
        self = super().__new__(cls)
        assert isinstance(dask, Mapping)
        if not isinstance(dask, HighLevelGraph):
            dask = HighLevelGraph.from_collections(name, dask, dependencies=())
        self.dask = dask
        self._name = str(name)
        meta = meta_from_array(meta, dtype=dtype)
    
        if (
            isinstance(chunks, str)
            or isinstance(chunks, tuple)
            and chunks
            and any(isinstance(c, str) for c in chunks)
        ):
            dt = meta.dtype
        else:
            dt = None
        self._chunks = normalize_chunks(chunks, shape, dtype=dt)
        if self.chunks is None:
            raise ValueError(CHUNKS_NONE_ERROR_MESSAGE)
        self._meta = meta_from_array(meta, ndim=self.ndim, dtype=dtype)
    
        for plugin in config.get("array_plugins", ()):
            result = plugin(self)
            if result is not None:
                self = result
    
        try:
            layer = self.dask.layers[name]
        except (AttributeError, KeyError):
            # self is no longer an Array after applying the plugins, OR
            # a plugin replaced the HighLevelGraph with a plain dict, OR
            # name is not the top layer's name (this can happen after the layer is
            # manipulated, to avoid a collision)
            pass
        else:
>           if layer.collection_annotations is None:
E           AttributeError: 'dict' object has no attribute 'collection_annotations'

/home/swe-bench/miniconda3/envs/pydata__xarray__0.12/lib/python3.10/site-packages/dask/array/core.py:1365: AttributeError
________________ test_map_blocks_da_transformations[<lambda>1] _________________

func = <function <lambda> at 0x77b32478a4d0>
map_da = <xarray.DataArray 'a' (x: 10, y: 20)>
dask.array<xarray-<this-array>, shape=(10, 20), dtype=float64, chunksize=(4, 5),...meta=np.ndarray>
    cxy      (x, y) int64 dask.array<chunksize=(4, 5), meta=np.ndarray>
Attributes:
    test:     test

    @pytest.mark.parametrize(
        "func",
        [
            lambda x: x,
            lambda x: x.to_dataset(),
            lambda x: x.drop_vars("x"),
            lambda x: x.expand_dims(k=[1, 2, 3]),
            lambda x: x.expand_dims(k=3),
            lambda x: x.assign_coords(new_coord=("y", x.y.data * 2)),
            lambda x: x.astype(np.int32),
            lambda x: x.x,
        ],
    )
    def test_map_blocks_da_transformations(func, map_da):
        with raise_if_dask_computes():
>           actual = xr.map_blocks(func, map_da)

/home/swe-bench/pydata__xarray/xarray/tests/test_dask.py:1243: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/home/swe-bench/pydata__xarray/xarray/core/parallel.py:566: in map_blocks
    data = dask.array.Array(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

cls = <class 'dask.array.core.Array'>
dask = HighLevelGraph with 8 layers.
<dask.highlevelgraph.HighLevelGraph object at 0x77b324605330>
 0. xarray-<this-array>-cd...d4339938f426b28-cxy
 6. lambda-edfaf720c4c091694d4339938f426b28-ndcoord
 7. lambda-edfaf720c4c091694d4339938f426b28-c2

name = 'lambda-edfaf720c4c091694d4339938f426b28-c2', chunks = []
dtype = dtype('float64'), meta = array(10.), shape = None

    def __new__(cls, dask, name, chunks, dtype=None, meta=None, shape=None):
        self = super().__new__(cls)
        assert isinstance(dask, Mapping)
        if not isinstance(dask, HighLevelGraph):
            dask = HighLevelGraph.from_collections(name, dask, dependencies=())
        self.dask = dask
        self._name = str(name)
        meta = meta_from_array(meta, dtype=dtype)
    
        if (
            isinstance(chunks, str)
            or isinstance(chunks, tuple)
            and chunks
            and any(isinstance(c, str) for c in chunks)
        ):
            dt = meta.dtype
        else:
            dt = None
        self._chunks = normalize_chunks(chunks, shape, dtype=dt)
        if self.chunks is None:
            raise ValueError(CHUNKS_NONE_ERROR_MESSAGE)
        self._meta = meta_from_array(meta, ndim=self.ndim, dtype=dtype)
    
        for plugin in config.get("array_plugins", ()):
            result = plugin(self)
            if result is not None:
                self = result
    
        try:
            layer = self.dask.layers[name]
        except (AttributeError, KeyError):
            # self is no longer an Array after applying the plugins, OR
            # a plugin replaced the HighLevelGraph with a plain dict, OR
            # name is not the top layer's name (this can happen after the layer is
            # manipulated, to avoid a collision)
            pass
        else:
>           if layer.collection_annotations is None:
E           AttributeError: 'dict' object has no attribute 'collection_annotations'

/home/swe-bench/miniconda3/envs/pydata__xarray__0.12/lib/python3.10/site-packages/dask/array/core.py:1365: AttributeError
________________ test_map_blocks_da_transformations[<lambda>2] _________________

func = <function <lambda> at 0x77b324789ab0>
map_da = <xarray.DataArray 'a' (x: 10, y: 20)>
dask.array<xarray-<this-array>, shape=(10, 20), dtype=float64, chunksize=(4, 5),...meta=np.ndarray>
    cxy      (x, y) int64 dask.array<chunksize=(4, 5), meta=np.ndarray>
Attributes:
    test:     test

    @pytest.mark.parametrize(
        "func",
        [
            lambda x: x,
            lambda x: x.to_dataset(),
            lambda x: x.drop_vars("x"),
            lambda x: x.expand_dims(k=[1, 2, 3]),
            lambda x: x.expand_dims(k=3),
            lambda x: x.assign_coords(new_coord=("y", x.y.data * 2)),
            lambda x: x.astype(np.int32),
            lambda x: x.x,
        ],
    )
    def test_map_blocks_da_transformations(func, map_da):
        with raise_if_dask_computes():
>           actual = xr.map_blocks(func, map_da)

/home/swe-bench/pydata__xarray/xarray/tests/test_dask.py:1243: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/home/swe-bench/pydata__xarray/xarray/core/parallel.py:566: in map_blocks
    data = dask.array.Array(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

cls = <class 'dask.array.core.Array'>
dask = HighLevelGraph with 8 layers.
<dask.highlevelgraph.HighLevelGraph object at 0x77b32460b7c0>
 0. xarray-<this-array>-cd...d4339938f426b28-cxy
 6. lambda-edfaf720c4c091694d4339938f426b28-ndcoord
 7. lambda-edfaf720c4c091694d4339938f426b28-c2

name = 'lambda-edfaf720c4c091694d4339938f426b28-c2', chunks = []
dtype = dtype('float64'), meta = array(10.), shape = None

    def __new__(cls, dask, name, chunks, dtype=None, meta=None, shape=None):
        self = super().__new__(cls)
        assert isinstance(dask, Mapping)
        if not isinstance(dask, HighLevelGraph):
            dask = HighLevelGraph.from_collections(name, dask, dependencies=())
        self.dask = dask
        self._name = str(name)
        meta = meta_from_array(meta, dtype=dtype)
    
        if (
            isinstance(chunks, str)
            or isinstance(chunks, tuple)
            and chunks
            and any(isinstance(c, str) for c in chunks)
        ):
            dt = meta.dtype
        else:
            dt = None
        self._chunks = normalize_chunks(chunks, shape, dtype=dt)
        if self.chunks is None:
            raise ValueError(CHUNKS_NONE_ERROR_MESSAGE)
        self._meta = meta_from_array(meta, ndim=self.ndim, dtype=dtype)
    
        for plugin in config.get("array_plugins", ()):
            result = plugin(self)
            if result is not None:
                self = result
    
        try:
            layer = self.dask.layers[name]
        except (AttributeError, KeyError):
            # self is no longer an Array after applying the plugins, OR
            # a plugin replaced the HighLevelGraph with a plain dict, OR
            # name is not the top layer's name (this can happen after the layer is
            # manipulated, to avoid a collision)
            pass
        else:
>           if layer.collection_annotations is None:
E           AttributeError: 'dict' object has no attribute 'collection_annotations'

/home/swe-bench/miniconda3/envs/pydata__xarray__0.12/lib/python3.10/site-packages/dask/array/core.py:1365: AttributeError
________________ test_map_blocks_da_transformations[<lambda>3] _________________

func = <function <lambda> at 0x77b324789cf0>
map_da = <xarray.DataArray 'a' (x: 10, y: 20)>
dask.array<xarray-<this-array>, shape=(10, 20), dtype=float64, chunksize=(4, 5),...meta=np.ndarray>
    cxy      (x, y) int64 dask.array<chunksize=(4, 5), meta=np.ndarray>
Attributes:
    test:     test

    @pytest.mark.parametrize(
        "func",
        [
            lambda x: x,
            lambda x: x.to_dataset(),
            lambda x: x.drop_vars("x"),
            lambda x: x.expand_dims(k=[1, 2, 3]),
            lambda x: x.expand_dims(k=3),
            lambda x: x.assign_coords(new_coord=("y", x.y.data * 2)),
            lambda x: x.astype(np.int32),
            lambda x: x.x,
        ],
    )
    def test_map_blocks_da_transformations(func, map_da):
        with raise_if_dask_computes():
>           actual = xr.map_blocks(func, map_da)

/home/swe-bench/pydata__xarray/xarray/tests/test_dask.py:1243: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/home/swe-bench/pydata__xarray/xarray/core/parallel.py:566: in map_blocks
    data = dask.array.Array(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

cls = <class 'dask.array.core.Array'>
dask = HighLevelGraph with 8 layers.
<dask.highlevelgraph.HighLevelGraph object at 0x77b325284430>
 0. xarray-<this-array>-cd...d4339938f426b28-cxy
 6. lambda-edfaf720c4c091694d4339938f426b28-ndcoord
 7. lambda-edfaf720c4c091694d4339938f426b28-c2

name = 'lambda-edfaf720c4c091694d4339938f426b28-c2', chunks = []
dtype = dtype('float64'), meta = array(0.5), shape = None

    def __new__(cls, dask, name, chunks, dtype=None, meta=None, shape=None):
        self = super().__new__(cls)
        assert isinstance(dask, Mapping)
        if not isinstance(dask, HighLevelGraph):
            dask = HighLevelGraph.from_collections(name, dask, dependencies=())
        self.dask = dask
        self._name = str(name)
        meta = meta_from_array(meta, dtype=dtype)
    
        if (
            isinstance(chunks, str)
            or isinstance(chunks, tuple)
            and chunks
            and any(isinstance(c, str) for c in chunks)
        ):
            dt = meta.dtype
        else:
            dt = None
        self._chunks = normalize_chunks(chunks, shape, dtype=dt)
        if self.chunks is None:
            raise ValueError(CHUNKS_NONE_ERROR_MESSAGE)
        self._meta = meta_from_array(meta, ndim=self.ndim, dtype=dtype)
    
        for plugin in config.get("array_plugins", ()):
            result = plugin(self)
            if result is not None:
                self = result
    
        try:
            layer = self.dask.layers[name]
        except (AttributeError, KeyError):
            # self is no longer an Array after applying the plugins, OR
            # a plugin replaced the HighLevelGraph with a plain dict, OR
            # name is not the top layer's name (this can happen after the layer is
            # manipulated, to avoid a collision)
            pass
        else:
>           if layer.collection_annotations is None:
E           AttributeError: 'dict' object has no attribute 'collection_annotations'

/home/swe-bench/miniconda3/envs/pydata__xarray__0.12/lib/python3.10/site-packages/dask/array/core.py:1365: AttributeError
________________ test_map_blocks_da_transformations[<lambda>4] _________________

func = <function <lambda> at 0x77b32478a200>
map_da = <xarray.DataArray 'a' (x: 10, y: 20)>
dask.array<xarray-<this-array>, shape=(10, 20), dtype=float64, chunksize=(4, 5),...meta=np.ndarray>
    cxy      (x, y) int64 dask.array<chunksize=(4, 5), meta=np.ndarray>
Attributes:
    test:     test

    @pytest.mark.parametrize(
        "func",
        [
            lambda x: x,
            lambda x: x.to_dataset(),
            lambda x: x.drop_vars("x"),
            lambda x: x.expand_dims(k=[1, 2, 3]),
            lambda x: x.expand_dims(k=3),
            lambda x: x.assign_coords(new_coord=("y", x.y.data * 2)),
            lambda x: x.astype(np.int32),
            lambda x: x.x,
        ],
    )
    def test_map_blocks_da_transformations(func, map_da):
        with raise_if_dask_computes():
>           actual = xr.map_blocks(func, map_da)

/home/swe-bench/pydata__xarray/xarray/tests/test_dask.py:1243: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/home/swe-bench/pydata__xarray/xarray/core/parallel.py:566: in map_blocks
    data = dask.array.Array(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

cls = <class 'dask.array.core.Array'>
dask = HighLevelGraph with 8 layers.
<dask.highlevelgraph.HighLevelGraph object at 0x77b3253c0a90>
 0. xarray-<this-array>-cd...d4339938f426b28-cxy
 6. lambda-edfaf720c4c091694d4339938f426b28-ndcoord
 7. lambda-edfaf720c4c091694d4339938f426b28-c2

name = 'lambda-edfaf720c4c091694d4339938f426b28-c2', chunks = []
dtype = dtype('float64'), meta = array(10.), shape = None

    def __new__(cls, dask, name, chunks, dtype=None, meta=None, shape=None):
        self = super().__new__(cls)
        assert isinstance(dask, Mapping)
        if not isinstance(dask, HighLevelGraph):
            dask = HighLevelGraph.from_collections(name, dask, dependencies=())
        self.dask = dask
        self._name = str(name)
        meta = meta_from_array(meta, dtype=dtype)
    
        if (
            isinstance(chunks, str)
            or isinstance(chunks, tuple)
            and chunks
            and any(isinstance(c, str) for c in chunks)
        ):
            dt = meta.dtype
        else:
            dt = None
        self._chunks = normalize_chunks(chunks, shape, dtype=dt)
        if self.chunks is None:
            raise ValueError(CHUNKS_NONE_ERROR_MESSAGE)
        self._meta = meta_from_array(meta, ndim=self.ndim, dtype=dtype)
    
        for plugin in config.get("array_plugins", ()):
            result = plugin(self)
            if result is not None:
                self = result
    
        try:
            layer = self.dask.layers[name]
        except (AttributeError, KeyError):
            # self is no longer an Array after applying the plugins, OR
            # a plugin replaced the HighLevelGraph with a plain dict, OR
            # name is not the top layer's name (this can happen after the layer is
            # manipulated, to avoid a collision)
            pass
        else:
>           if layer.collection_annotations is None:
E           AttributeError: 'dict' object has no attribute 'collection_annotations'

/home/swe-bench/miniconda3/envs/pydata__xarray__0.12/lib/python3.10/site-packages/dask/array/core.py:1365: AttributeError
________________ test_map_blocks_da_transformations[<lambda>5] _________________

func = <function <lambda> at 0x77b32478a290>
map_da = <xarray.DataArray 'a' (x: 10, y: 20)>
dask.array<xarray-<this-array>, shape=(10, 20), dtype=float64, chunksize=(4, 5),...meta=np.ndarray>
    cxy      (x, y) int64 dask.array<chunksize=(4, 5), meta=np.ndarray>
Attributes:
    test:     test

    @pytest.mark.parametrize(
        "func",
        [
            lambda x: x,
            lambda x: x.to_dataset(),
            lambda x: x.drop_vars("x"),
            lambda x: x.expand_dims(k=[1, 2, 3]),
            lambda x: x.expand_dims(k=3),
            lambda x: x.assign_coords(new_coord=("y", x.y.data * 2)),
            lambda x: x.astype(np.int32),
            lambda x: x.x,
        ],
    )
    def test_map_blocks_da_transformations(func, map_da):
        with raise_if_dask_computes():
>           actual = xr.map_blocks(func, map_da)

/home/swe-bench/pydata__xarray/xarray/tests/test_dask.py:1243: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/home/swe-bench/pydata__xarray/xarray/core/parallel.py:566: in map_blocks
    data = dask.array.Array(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

cls = <class 'dask.array.core.Array'>
dask = HighLevelGraph with 9 layers.
<dask.highlevelgraph.HighLevelGraph object at 0x77b324b1e590>
 0. xarray-<this-array>-cd...d4339938f426b28-cxy
 7. lambda-edfaf720c4c091694d4339938f426b28-ndcoord
 8. lambda-edfaf720c4c091694d4339938f426b28-c2

name = 'lambda-edfaf720c4c091694d4339938f426b28-c2', chunks = []
dtype = dtype('float64'), meta = array(1.e-323), shape = None

    def __new__(cls, dask, name, chunks, dtype=None, meta=None, shape=None):
        self = super().__new__(cls)
        assert isinstance(dask, Mapping)
        if not isinstance(dask, HighLevelGraph):
            dask = HighLevelGraph.from_collections(name, dask, dependencies=())
        self.dask = dask
        self._name = str(name)
        meta = meta_from_array(meta, dtype=dtype)
    
        if (
            isinstance(chunks, str)
            or isinstance(chunks, tuple)
            and chunks
            and any(isinstance(c, str) for c in chunks)
        ):
            dt = meta.dtype
        else:
            dt = None
        self._chunks = normalize_chunks(chunks, shape, dtype=dt)
        if self.chunks is None:
            raise ValueError(CHUNKS_NONE_ERROR_MESSAGE)
        self._meta = meta_from_array(meta, ndim=self.ndim, dtype=dtype)
    
        for plugin in config.get("array_plugins", ()):
            result = plugin(self)
            if result is not None:
                self = result
    
        try:
            layer = self.dask.layers[name]
        except (AttributeError, KeyError):
            # self is no longer an Array after applying the plugins, OR
            # a plugin replaced the HighLevelGraph with a plain dict, OR
            # name is not the top layer's name (this can happen after the layer is
            # manipulated, to avoid a collision)
            pass
        else:
>           if layer.collection_annotations is None:
E           AttributeError: 'dict' object has no attribute 'collection_annotations'

/home/swe-bench/miniconda3/envs/pydata__xarray__0.12/lib/python3.10/site-packages/dask/array/core.py:1365: AttributeError
________________ test_map_blocks_da_transformations[<lambda>6] _________________

func = <function <lambda> at 0x77b324789a20>
map_da = <xarray.DataArray 'a' (x: 10, y: 20)>
dask.array<xarray-<this-array>, shape=(10, 20), dtype=float64, chunksize=(4, 5),...meta=np.ndarray>
    cxy      (x, y) int64 dask.array<chunksize=(4, 5), meta=np.ndarray>
Attributes:
    test:     test

    @pytest.mark.parametrize(
        "func",
        [
            lambda x: x,
            lambda x: x.to_dataset(),
            lambda x: x.drop_vars("x"),
            lambda x: x.expand_dims(k=[1, 2, 3]),
            lambda x: x.expand_dims(k=3),
            lambda x: x.assign_coords(new_coord=("y", x.y.data * 2)),
            lambda x: x.astype(np.int32),
            lambda x: x.x,
        ],
    )
    def test_map_blocks_da_transformations(func, map_da):
        with raise_if_dask_computes():
>           actual = xr.map_blocks(func, map_da)

/home/swe-bench/pydata__xarray/xarray/tests/test_dask.py:1243: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/home/swe-bench/pydata__xarray/xarray/core/parallel.py:566: in map_blocks
    data = dask.array.Array(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

cls = <class 'dask.array.core.Array'>
dask = HighLevelGraph with 8 layers.
<dask.highlevelgraph.HighLevelGraph object at 0x77b3253d6050>
 0. xarray-<this-array>-cd...d4339938f426b28-cxy
 6. lambda-edfaf720c4c091694d4339938f426b28-ndcoord
 7. lambda-edfaf720c4c091694d4339938f426b28-c2

name = 'lambda-edfaf720c4c091694d4339938f426b28-c2', chunks = []
dtype = dtype('float64'), meta = array(10.), shape = None

    def __new__(cls, dask, name, chunks, dtype=None, meta=None, shape=None):
        self = super().__new__(cls)
        assert isinstance(dask, Mapping)
        if not isinstance(dask, HighLevelGraph):
            dask = HighLevelGraph.from_collections(name, dask, dependencies=())
        self.dask = dask
        self._name = str(name)
        meta = meta_from_array(meta, dtype=dtype)
    
        if (
            isinstance(chunks, str)
            or isinstance(chunks, tuple)
            and chunks
            and any(isinstance(c, str) for c in chunks)
        ):
            dt = meta.dtype
        else:
            dt = None
        self._chunks = normalize_chunks(chunks, shape, dtype=dt)
        if self.chunks is None:
            raise ValueError(CHUNKS_NONE_ERROR_MESSAGE)
        self._meta = meta_from_array(meta, ndim=self.ndim, dtype=dtype)
    
        for plugin in config.get("array_plugins", ()):
            result = plugin(self)
            if result is not None:
                self = result
    
        try:
            layer = self.dask.layers[name]
        except (AttributeError, KeyError):
            # self is no longer an Array after applying the plugins, OR
            # a plugin replaced the HighLevelGraph with a plain dict, OR
            # name is not the top layer's name (this can happen after the layer is
            # manipulated, to avoid a collision)
            pass
        else:
>           if layer.collection_annotations is None:
E           AttributeError: 'dict' object has no attribute 'collection_annotations'

/home/swe-bench/miniconda3/envs/pydata__xarray__0.12/lib/python3.10/site-packages/dask/array/core.py:1365: AttributeError
________________ test_map_blocks_da_transformations[<lambda>7] _________________

func = <function <lambda> at 0x77b324789f30>
map_da = <xarray.DataArray 'a' (x: 10, y: 20)>
dask.array<xarray-<this-array>, shape=(10, 20), dtype=float64, chunksize=(4, 5),...meta=np.ndarray>
    cxy      (x, y) int64 dask.array<chunksize=(4, 5), meta=np.ndarray>
Attributes:
    test:     test

    @pytest.mark.parametrize(
        "func",
        [
            lambda x: x,
            lambda x: x.to_dataset(),
            lambda x: x.drop_vars("x"),
            lambda x: x.expand_dims(k=[1, 2, 3]),
            lambda x: x.expand_dims(k=3),
            lambda x: x.assign_coords(new_coord=("y", x.y.data * 2)),
            lambda x: x.astype(np.int32),
            lambda x: x.x,
        ],
    )
    def test_map_blocks_da_transformations(func, map_da):
        with raise_if_dask_computes():
>           actual = xr.map_blocks(func, map_da)

/home/swe-bench/pydata__xarray/xarray/tests/test_dask.py:1243: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/home/swe-bench/pydata__xarray/xarray/core/parallel.py:566: in map_blocks
    data = dask.array.Array(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

cls = <class 'dask.array.core.Array'>
dask = HighLevelGraph with 7 layers.
<dask.highlevelgraph.HighLevelGraph object at 0x77b324b73460>
 0. xarray-<this-array>-cd...426b28-<this-array>
 5. lambda-edfaf720c4c091694d4339938f426b28-ndcoord
 6. lambda-edfaf720c4c091694d4339938f426b28-c2

name = 'lambda-edfaf720c4c091694d4339938f426b28-c2', chunks = []
dtype = dtype('float64'), meta = array(1.5e-323), shape = None

    def __new__(cls, dask, name, chunks, dtype=None, meta=None, shape=None):
        self = super().__new__(cls)
        assert isinstance(dask, Mapping)
        if not isinstance(dask, HighLevelGraph):
            dask = HighLevelGraph.from_collections(name, dask, dependencies=())
        self.dask = dask
        self._name = str(name)
        meta = meta_from_array(meta, dtype=dtype)
    
        if (
            isinstance(chunks, str)
            or isinstance(chunks, tuple)
            and chunks
            and any(isinstance(c, str) for c in chunks)
        ):
            dt = meta.dtype
        else:
            dt = None
        self._chunks = normalize_chunks(chunks, shape, dtype=dt)
        if self.chunks is None:
            raise ValueError(CHUNKS_NONE_ERROR_MESSAGE)
        self._meta = meta_from_array(meta, ndim=self.ndim, dtype=dtype)
    
        for plugin in config.get("array_plugins", ()):
            result = plugin(self)
            if result is not None:
                self = result
    
        try:
            layer = self.dask.layers[name]
        except (AttributeError, KeyError):
            # self is no longer an Array after applying the plugins, OR
            # a plugin replaced the HighLevelGraph with a plain dict, OR
            # name is not the top layer's name (this can happen after the layer is
            # manipulated, to avoid a collision)
            pass
        else:
>           if layer.collection_annotations is None:
E           AttributeError: 'dict' object has no attribute 'collection_annotations'

/home/swe-bench/miniconda3/envs/pydata__xarray__0.12/lib/python3.10/site-packages/dask/array/core.py:1365: AttributeError
________________ test_map_blocks_ds_transformations[<lambda>0] _________________

func = <function <lambda> at 0x77b32478a950>
map_ds = <xarray.Dataset>
Dimensions:  (x: 10, y: 20, z: 4)
Coordinates:
  * x        (x) int64 0 1 2 3 4 5 6 7 8 9
  * y      ...64 1 1 1 1
    e        (x, y) int64 100 101 102 103 104 105 ... 123 124 125 126 127 128
Attributes:
    test:     test

    @pytest.mark.parametrize(
        "func",
        [
            lambda x: x,
            lambda x: x.drop_vars("cxy"),
            lambda x: x.drop_vars("a"),
            lambda x: x.drop_vars("x"),
            lambda x: x.expand_dims(k=[1, 2, 3]),
            lambda x: x.expand_dims(k=3),
            lambda x: x.rename({"a": "new1", "b": "new2"}),
            lambda x: x.x,
        ],
    )
    def test_map_blocks_ds_transformations(func, map_ds):
        with raise_if_dask_computes():
>           actual = xr.map_blocks(func, map_ds)

/home/swe-bench/pydata__xarray/xarray/tests/test_dask.py:1263: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/home/swe-bench/pydata__xarray/xarray/core/parallel.py:566: in map_blocks
    data = dask.array.Array(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

cls = <class 'dask.array.core.Array'>
dask = HighLevelGraph with 20 layers.
<dask.highlevelgraph.HighLevelGraph object at 0x77b324be5cf0>
 0. array-9fc76b19d9f2299...cd05fd7f8f0ba-cxy
 18. lambda-8e0b79e9fe44b20a429cd05fd7f8f0ba-ndcoord
 19. lambda-8e0b79e9fe44b20a429cd05fd7f8f0ba-c2

name = 'lambda-8e0b79e9fe44b20a429cd05fd7f8f0ba-c2', chunks = []
dtype = dtype('float64'), meta = array(0.), shape = None

    def __new__(cls, dask, name, chunks, dtype=None, meta=None, shape=None):
        self = super().__new__(cls)
        assert isinstance(dask, Mapping)
        if not isinstance(dask, HighLevelGraph):
            dask = HighLevelGraph.from_collections(name, dask, dependencies=())
        self.dask = dask
        self._name = str(name)
        meta = meta_from_array(meta, dtype=dtype)
    
        if (
            isinstance(chunks, str)
            or isinstance(chunks, tuple)
            and chunks
            and any(isinstance(c, str) for c in chunks)
        ):
            dt = meta.dtype
        else:
            dt = None
        self._chunks = normalize_chunks(chunks, shape, dtype=dt)
        if self.chunks is None:
            raise ValueError(CHUNKS_NONE_ERROR_MESSAGE)
        self._meta = meta_from_array(meta, ndim=self.ndim, dtype=dtype)
    
        for plugin in config.get("array_plugins", ()):
            result = plugin(self)
            if result is not None:
                self = result
    
        try:
            layer = self.dask.layers[name]
        except (AttributeError, KeyError):
            # self is no longer an Array after applying the plugins, OR
            # a plugin replaced the HighLevelGraph with a plain dict, OR
            # name is not the top layer's name (this can happen after the layer is
            # manipulated, to avoid a collision)
            pass
        else:
>           if layer.collection_annotations is None:
E           AttributeError: 'dict' object has no attribute 'collection_annotations'

/home/swe-bench/miniconda3/envs/pydata__xarray__0.12/lib/python3.10/site-packages/dask/array/core.py:1365: AttributeError
________________ test_map_blocks_ds_transformations[<lambda>1] _________________

func = <function <lambda> at 0x77b32478a9e0>
map_ds = <xarray.Dataset>
Dimensions:  (x: 10, y: 20, z: 4)
Coordinates:
  * x        (x) int64 0 1 2 3 4 5 6 7 8 9
  * y      ...64 1 1 1 1
    e        (x, y) int64 100 101 102 103 104 105 ... 123 124 125 126 127 128
Attributes:
    test:     test

    @pytest.mark.parametrize(
        "func",
        [
            lambda x: x,
            lambda x: x.drop_vars("cxy"),
            lambda x: x.drop_vars("a"),
            lambda x: x.drop_vars("x"),
            lambda x: x.expand_dims(k=[1, 2, 3]),
            lambda x: x.expand_dims(k=3),
            lambda x: x.rename({"a": "new1", "b": "new2"}),
            lambda x: x.x,
        ],
    )
    def test_map_blocks_ds_transformations(func, map_ds):
        with raise_if_dask_computes():
>           actual = xr.map_blocks(func, map_ds)

/home/swe-bench/pydata__xarray/xarray/tests/test_dask.py:1263: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/home/swe-bench/pydata__xarray/xarray/core/parallel.py:566: in map_blocks
    data = dask.array.Array(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

cls = <class 'dask.array.core.Array'>
dask = HighLevelGraph with 19 layers.
<dask.highlevelgraph.HighLevelGraph object at 0x77b324c18f40>
 0. array-9fc76b19d9f2299...29cd05fd7f8f0ba-a
 17. lambda-8e0b79e9fe44b20a429cd05fd7f8f0ba-ndcoord
 18. lambda-8e0b79e9fe44b20a429cd05fd7f8f0ba-c2

name = 'lambda-8e0b79e9fe44b20a429cd05fd7f8f0ba-c2', chunks = []
dtype = dtype('float64'), meta = array(0.), shape = None

    def __new__(cls, dask, name, chunks, dtype=None, meta=None, shape=None):
        self = super().__new__(cls)
        assert isinstance(dask, Mapping)
        if not isinstance(dask, HighLevelGraph):
            dask = HighLevelGraph.from_collections(name, dask, dependencies=())
        self.dask = dask
        self._name = str(name)
        meta = meta_from_array(meta, dtype=dtype)
    
        if (
            isinstance(chunks, str)
            or isinstance(chunks, tuple)
            and chunks
            and any(isinstance(c, str) for c in chunks)
        ):
            dt = meta.dtype
        else:
            dt = None
        self._chunks = normalize_chunks(chunks, shape, dtype=dt)
        if self.chunks is None:
            raise ValueError(CHUNKS_NONE_ERROR_MESSAGE)
        self._meta = meta_from_array(meta, ndim=self.ndim, dtype=dtype)
    
        for plugin in config.get("array_plugins", ()):
            result = plugin(self)
            if result is not None:
                self = result
    
        try:
            layer = self.dask.layers[name]
        except (AttributeError, KeyError):
            # self is no longer an Array after applying the plugins, OR
            # a plugin replaced the HighLevelGraph with a plain dict, OR
            # name is not the top layer's name (this can happen after the layer is
            # manipulated, to avoid a collision)
            pass
        else:
>           if layer.collection_annotations is None:
E           AttributeError: 'dict' object has no attribute 'collection_annotations'

/home/swe-bench/miniconda3/envs/pydata__xarray__0.12/lib/python3.10/site-packages/dask/array/core.py:1365: AttributeError
________________ test_map_blocks_ds_transformations[<lambda>2] _________________

func = <function <lambda> at 0x77b32478aa70>
map_ds = <xarray.Dataset>
Dimensions:  (x: 10, y: 20, z: 4)
Coordinates:
  * x        (x) int64 0 1 2 3 4 5 6 7 8 9
  * y      ...64 1 1 1 1
    e        (x, y) int64 100 101 102 103 104 105 ... 123 124 125 126 127 128
Attributes:
    test:     test

    @pytest.mark.parametrize(
        "func",
        [
            lambda x: x,
            lambda x: x.drop_vars("cxy"),
            lambda x: x.drop_vars("a"),
            lambda x: x.drop_vars("x"),
            lambda x: x.expand_dims(k=[1, 2, 3]),
            lambda x: x.expand_dims(k=3),
            lambda x: x.rename({"a": "new1", "b": "new2"}),
            lambda x: x.x,
        ],
    )
    def test_map_blocks_ds_transformations(func, map_ds):
        with raise_if_dask_computes():
>           actual = xr.map_blocks(func, map_ds)

/home/swe-bench/pydata__xarray/xarray/tests/test_dask.py:1263: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/home/swe-bench/pydata__xarray/xarray/core/parallel.py:566: in map_blocks
    data = dask.array.Array(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

cls = <class 'dask.array.core.Array'>
dask = HighLevelGraph with 19 layers.
<dask.highlevelgraph.HighLevelGraph object at 0x77b3243e08b0>
 0. array-9fc76b19d9f2299...cd05fd7f8f0ba-cxy
 17. lambda-8e0b79e9fe44b20a429cd05fd7f8f0ba-ndcoord
 18. lambda-8e0b79e9fe44b20a429cd05fd7f8f0ba-c2

name = 'lambda-8e0b79e9fe44b20a429cd05fd7f8f0ba-c2', chunks = []
dtype = dtype('float64'), meta = array(0.), shape = None

    def __new__(cls, dask, name, chunks, dtype=None, meta=None, shape=None):
        self = super().__new__(cls)
        assert isinstance(dask, Mapping)
        if not isinstance(dask, HighLevelGraph):
            dask = HighLevelGraph.from_collections(name, dask, dependencies=())
        self.dask = dask
        self._name = str(name)
        meta = meta_from_array(meta, dtype=dtype)
    
        if (
            isinstance(chunks, str)
            or isinstance(chunks, tuple)
            and chunks
            and any(isinstance(c, str) for c in chunks)
        ):
            dt = meta.dtype
        else:
            dt = None
        self._chunks = normalize_chunks(chunks, shape, dtype=dt)
        if self.chunks is None:
            raise ValueError(CHUNKS_NONE_ERROR_MESSAGE)
        self._meta = meta_from_array(meta, ndim=self.ndim, dtype=dtype)
    
        for plugin in config.get("array_plugins", ()):
            result = plugin(self)
            if result is not None:
                self = result
    
        try:
            layer = self.dask.layers[name]
        except (AttributeError, KeyError):
            # self is no longer an Array after applying the plugins, OR
            # a plugin replaced the HighLevelGraph with a plain dict, OR
            # name is not the top layer's name (this can happen after the layer is
            # manipulated, to avoid a collision)
            pass
        else:
>           if layer.collection_annotations is None:
E           AttributeError: 'dict' object has no attribute 'collection_annotations'

/home/swe-bench/miniconda3/envs/pydata__xarray__0.12/lib/python3.10/site-packages/dask/array/core.py:1365: AttributeError
________________ test_map_blocks_ds_transformations[<lambda>3] _________________

func = <function <lambda> at 0x77b32478ab00>
map_ds = <xarray.Dataset>
Dimensions:  (x: 10, y: 20, z: 4)
Coordinates:
  * x        (x) int64 0 1 2 3 4 5 6 7 8 9
  * y      ...64 1 1 1 1
    e        (x, y) int64 100 101 102 103 104 105 ... 123 124 125 126 127 128
Attributes:
    test:     test

    @pytest.mark.parametrize(
        "func",
        [
            lambda x: x,
            lambda x: x.drop_vars("cxy"),
            lambda x: x.drop_vars("a"),
            lambda x: x.drop_vars("x"),
            lambda x: x.expand_dims(k=[1, 2, 3]),
            lambda x: x.expand_dims(k=3),
            lambda x: x.rename({"a": "new1", "b": "new2"}),
            lambda x: x.x,
        ],
    )
    def test_map_blocks_ds_transformations(func, map_ds):
        with raise_if_dask_computes():
>           actual = xr.map_blocks(func, map_ds)

/home/swe-bench/pydata__xarray/xarray/tests/test_dask.py:1263: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/home/swe-bench/pydata__xarray/xarray/core/parallel.py:566: in map_blocks
    data = dask.array.Array(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

cls = <class 'dask.array.core.Array'>
dask = HighLevelGraph with 20 layers.
<dask.highlevelgraph.HighLevelGraph object at 0x77b324b73580>
 0. array-9fc76b19d9f2299...cd05fd7f8f0ba-cxy
 18. lambda-8e0b79e9fe44b20a429cd05fd7f8f0ba-ndcoord
 19. lambda-8e0b79e9fe44b20a429cd05fd7f8f0ba-c2

name = 'lambda-8e0b79e9fe44b20a429cd05fd7f8f0ba-c2', chunks = []
dtype = dtype('float64'), meta = array(0.), shape = None

    def __new__(cls, dask, name, chunks, dtype=None, meta=None, shape=None):
        self = super().__new__(cls)
        assert isinstance(dask, Mapping)
        if not isinstance(dask, HighLevelGraph):
            dask = HighLevelGraph.from_collections(name, dask, dependencies=())
        self.dask = dask
        self._name = str(name)
        meta = meta_from_array(meta, dtype=dtype)
    
        if (
            isinstance(chunks, str)
            or isinstance(chunks, tuple)
            and chunks
            and any(isinstance(c, str) for c in chunks)
        ):
            dt = meta.dtype
        else:
            dt = None
        self._chunks = normalize_chunks(chunks, shape, dtype=dt)
        if self.chunks is None:
            raise ValueError(CHUNKS_NONE_ERROR_MESSAGE)
        self._meta = meta_from_array(meta, ndim=self.ndim, dtype=dtype)
    
        for plugin in config.get("array_plugins", ()):
            result = plugin(self)
            if result is not None:
                self = result
    
        try:
            layer = self.dask.layers[name]
        except (AttributeError, KeyError):
            # self is no longer an Array after applying the plugins, OR
            # a plugin replaced the HighLevelGraph with a plain dict, OR
            # name is not the top layer's name (this can happen after the layer is
            # manipulated, to avoid a collision)
            pass
        else:
>           if layer.collection_annotations is None:
E           AttributeError: 'dict' object has no attribute 'collection_annotations'

/home/swe-bench/miniconda3/envs/pydata__xarray__0.12/lib/python3.10/site-packages/dask/array/core.py:1365: AttributeError
________________ test_map_blocks_ds_transformations[<lambda>4] _________________

func = <function <lambda> at 0x77b32478ab90>
map_ds = <xarray.Dataset>
Dimensions:  (x: 10, y: 20, z: 4)
Coordinates:
  * x        (x) int64 0 1 2 3 4 5 6 7 8 9
  * y      ...64 1 1 1 1
    e        (x, y) int64 100 101 102 103 104 105 ... 123 124 125 126 127 128
Attributes:
    test:     test

    @pytest.mark.parametrize(
        "func",
        [
            lambda x: x,
            lambda x: x.drop_vars("cxy"),
            lambda x: x.drop_vars("a"),
            lambda x: x.drop_vars("x"),
            lambda x: x.expand_dims(k=[1, 2, 3]),
            lambda x: x.expand_dims(k=3),
            lambda x: x.rename({"a": "new1", "b": "new2"}),
            lambda x: x.x,
        ],
    )
    def test_map_blocks_ds_transformations(func, map_ds):
        with raise_if_dask_computes():
>           actual = xr.map_blocks(func, map_ds)

/home/swe-bench/pydata__xarray/xarray/tests/test_dask.py:1263: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/home/swe-bench/pydata__xarray/xarray/core/parallel.py:566: in map_blocks
    data = dask.array.Array(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

cls = <class 'dask.array.core.Array'>
dask = HighLevelGraph with 20 layers.
<dask.highlevelgraph.HighLevelGraph object at 0x77b324609de0>
 0. array-9fc76b19d9f2299...cd05fd7f8f0ba-cxy
 18. lambda-8e0b79e9fe44b20a429cd05fd7f8f0ba-ndcoord
 19. lambda-8e0b79e9fe44b20a429cd05fd7f8f0ba-c2

name = 'lambda-8e0b79e9fe44b20a429cd05fd7f8f0ba-c2', chunks = []
dtype = dtype('float64'), meta = array(1.5e-323), shape = None

    def __new__(cls, dask, name, chunks, dtype=None, meta=None, shape=None):
        self = super().__new__(cls)
        assert isinstance(dask, Mapping)
        if not isinstance(dask, HighLevelGraph):
            dask = HighLevelGraph.from_collections(name, dask, dependencies=())
        self.dask = dask
        self._name = str(name)
        meta = meta_from_array(meta, dtype=dtype)
    
        if (
            isinstance(chunks, str)
            or isinstance(chunks, tuple)
            and chunks
            and any(isinstance(c, str) for c in chunks)
        ):
            dt = meta.dtype
        else:
            dt = None
        self._chunks = normalize_chunks(chunks, shape, dtype=dt)
        if self.chunks is None:
            raise ValueError(CHUNKS_NONE_ERROR_MESSAGE)
        self._meta = meta_from_array(meta, ndim=self.ndim, dtype=dtype)
    
        for plugin in config.get("array_plugins", ()):
            result = plugin(self)
            if result is not None:
                self = result
    
        try:
            layer = self.dask.layers[name]
        except (AttributeError, KeyError):
            # self is no longer an Array after applying the plugins, OR
            # a plugin replaced the HighLevelGraph with a plain dict, OR
            # name is not the top layer's name (this can happen after the layer is
            # manipulated, to avoid a collision)
            pass
        else:
>           if layer.collection_annotations is None:
E           AttributeError: 'dict' object has no attribute 'collection_annotations'

/home/swe-bench/miniconda3/envs/pydata__xarray__0.12/lib/python3.10/site-packages/dask/array/core.py:1365: AttributeError
________________ test_map_blocks_ds_transformations[<lambda>5] _________________

func = <function <lambda> at 0x77b32478ac20>
map_ds = <xarray.Dataset>
Dimensions:  (x: 10, y: 20, z: 4)
Coordinates:
  * x        (x) int64 0 1 2 3 4 5 6 7 8 9
  * y      ...64 1 1 1 1
    e        (x, y) int64 100 101 102 103 104 105 ... 123 124 125 126 127 128
Attributes:
    test:     test

    @pytest.mark.parametrize(
        "func",
        [
            lambda x: x,
            lambda x: x.drop_vars("cxy"),
            lambda x: x.drop_vars("a"),
            lambda x: x.drop_vars("x"),
            lambda x: x.expand_dims(k=[1, 2, 3]),
            lambda x: x.expand_dims(k=3),
            lambda x: x.rename({"a": "new1", "b": "new2"}),
            lambda x: x.x,
        ],
    )
    def test_map_blocks_ds_transformations(func, map_ds):
        with raise_if_dask_computes():
>           actual = xr.map_blocks(func, map_ds)

/home/swe-bench/pydata__xarray/xarray/tests/test_dask.py:1263: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/home/swe-bench/pydata__xarray/xarray/core/parallel.py:566: in map_blocks
    data = dask.array.Array(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

cls = <class 'dask.array.core.Array'>
dask = HighLevelGraph with 20 layers.
<dask.highlevelgraph.HighLevelGraph object at 0x77b3252c23e0>
 0. array-9fc76b19d9f2299...cd05fd7f8f0ba-cxy
 18. lambda-8e0b79e9fe44b20a429cd05fd7f8f0ba-ndcoord
 19. lambda-8e0b79e9fe44b20a429cd05fd7f8f0ba-c2

name = 'lambda-8e0b79e9fe44b20a429cd05fd7f8f0ba-c2', chunks = []
dtype = dtype('float64'), meta = array(0.), shape = None

    def __new__(cls, dask, name, chunks, dtype=None, meta=None, shape=None):
        self = super().__new__(cls)
        assert isinstance(dask, Mapping)
        if not isinstance(dask, HighLevelGraph):
            dask = HighLevelGraph.from_collections(name, dask, dependencies=())
        self.dask = dask
        self._name = str(name)
        meta = meta_from_array(meta, dtype=dtype)
    
        if (
            isinstance(chunks, str)
            or isinstance(chunks, tuple)
            and chunks
            and any(isinstance(c, str) for c in chunks)
        ):
            dt = meta.dtype
        else:
            dt = None
        self._chunks = normalize_chunks(chunks, shape, dtype=dt)
        if self.chunks is None:
            raise ValueError(CHUNKS_NONE_ERROR_MESSAGE)
        self._meta = meta_from_array(meta, ndim=self.ndim, dtype=dtype)
    
        for plugin in config.get("array_plugins", ()):
            result = plugin(self)
            if result is not None:
                self = result
    
        try:
            layer = self.dask.layers[name]
        except (AttributeError, KeyError):
            # self is no longer an Array after applying the plugins, OR
            # a plugin replaced the HighLevelGraph with a plain dict, OR
            # name is not the top layer's name (this can happen after the layer is
            # manipulated, to avoid a collision)
            pass
        else:
>           if layer.collection_annotations is None:
E           AttributeError: 'dict' object has no attribute 'collection_annotations'

/home/swe-bench/miniconda3/envs/pydata__xarray__0.12/lib/python3.10/site-packages/dask/array/core.py:1365: AttributeError
________________ test_map_blocks_ds_transformations[<lambda>6] _________________

func = <function <lambda> at 0x77b32478acb0>
map_ds = <xarray.Dataset>
Dimensions:  (x: 10, y: 20, z: 4)
Coordinates:
  * x        (x) int64 0 1 2 3 4 5 6 7 8 9
  * y      ...64 1 1 1 1
    e        (x, y) int64 100 101 102 103 104 105 ... 123 124 125 126 127 128
Attributes:
    test:     test

    @pytest.mark.parametrize(
        "func",
        [
            lambda x: x,
            lambda x: x.drop_vars("cxy"),
            lambda x: x.drop_vars("a"),
            lambda x: x.drop_vars("x"),
            lambda x: x.expand_dims(k=[1, 2, 3]),
            lambda x: x.expand_dims(k=3),
            lambda x: x.rename({"a": "new1", "b": "new2"}),
            lambda x: x.x,
        ],
    )
    def test_map_blocks_ds_transformations(func, map_ds):
        with raise_if_dask_computes():
>           actual = xr.map_blocks(func, map_ds)

/home/swe-bench/pydata__xarray/xarray/tests/test_dask.py:1263: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/home/swe-bench/pydata__xarray/xarray/core/parallel.py:566: in map_blocks
    data = dask.array.Array(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

cls = <class 'dask.array.core.Array'>
dask = HighLevelGraph with 20 layers.
<dask.highlevelgraph.HighLevelGraph object at 0x77b3253d4220>
 0. array-9fc76b19d9f2299...cd05fd7f8f0ba-cxy
 18. lambda-8e0b79e9fe44b20a429cd05fd7f8f0ba-ndcoord
 19. lambda-8e0b79e9fe44b20a429cd05fd7f8f0ba-c2

name = 'lambda-8e0b79e9fe44b20a429cd05fd7f8f0ba-c2', chunks = []
dtype = dtype('float64'), meta = array(0.), shape = None

    def __new__(cls, dask, name, chunks, dtype=None, meta=None, shape=None):
        self = super().__new__(cls)
        assert isinstance(dask, Mapping)
        if not isinstance(dask, HighLevelGraph):
            dask = HighLevelGraph.from_collections(name, dask, dependencies=())
        self.dask = dask
        self._name = str(name)
        meta = meta_from_array(meta, dtype=dtype)
    
        if (
            isinstance(chunks, str)
            or isinstance(chunks, tuple)
            and chunks
            and any(isinstance(c, str) for c in chunks)
        ):
            dt = meta.dtype
        else:
            dt = None
        self._chunks = normalize_chunks(chunks, shape, dtype=dt)
        if self.chunks is None:
            raise ValueError(CHUNKS_NONE_ERROR_MESSAGE)
        self._meta = meta_from_array(meta, ndim=self.ndim, dtype=dtype)
    
        for plugin in config.get("array_plugins", ()):
            result = plugin(self)
            if result is not None:
                self = result
    
        try:
            layer = self.dask.layers[name]
        except (AttributeError, KeyError):
            # self is no longer an Array after applying the plugins, OR
            # a plugin replaced the HighLevelGraph with a plain dict, OR
            # name is not the top layer's name (this can happen after the layer is
            # manipulated, to avoid a collision)
            pass
        else:
>           if layer.collection_annotations is None:
E           AttributeError: 'dict' object has no attribute 'collection_annotations'

/home/swe-bench/miniconda3/envs/pydata__xarray__0.12/lib/python3.10/site-packages/dask/array/core.py:1365: AttributeError
________________ test_map_blocks_ds_transformations[<lambda>7] _________________

func = <function <lambda> at 0x77b32478ad40>
map_ds = <xarray.Dataset>
Dimensions:  (x: 10, y: 20, z: 4)
Coordinates:
  * x        (x) int64 0 1 2 3 4 5 6 7 8 9
  * y      ...64 1 1 1 1
    e        (x, y) int64 100 101 102 103 104 105 ... 123 124 125 126 127 128
Attributes:
    test:     test

    @pytest.mark.parametrize(
        "func",
        [
            lambda x: x,
            lambda x: x.drop_vars("cxy"),
            lambda x: x.drop_vars("a"),
            lambda x: x.drop_vars("x"),
            lambda x: x.expand_dims(k=[1, 2, 3]),
            lambda x: x.expand_dims(k=3),
            lambda x: x.rename({"a": "new1", "b": "new2"}),
            lambda x: x.x,
        ],
    )
    def test_map_blocks_ds_transformations(func, map_ds):
        with raise_if_dask_computes():
>           actual = xr.map_blocks(func, map_ds)

/home/swe-bench/pydata__xarray/xarray/tests/test_dask.py:1263: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/home/swe-bench/pydata__xarray/xarray/core/parallel.py:566: in map_blocks
    data = dask.array.Array(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

cls = <class 'dask.array.core.Array'>
dask = HighLevelGraph with 14 layers.
<dask.highlevelgraph.HighLevelGraph object at 0x77b324605210>
 0. array-9fc76b19d9f2299...9cd05fd7f8f0ba-c1
 12. lambda-8e0b79e9fe44b20a429cd05fd7f8f0ba-ndcoord
 13. lambda-8e0b79e9fe44b20a429cd05fd7f8f0ba-c2

name = 'lambda-8e0b79e9fe44b20a429cd05fd7f8f0ba-c2', chunks = []
dtype = dtype('float64'), meta = array(0.), shape = None

    def __new__(cls, dask, name, chunks, dtype=None, meta=None, shape=None):
        self = super().__new__(cls)
        assert isinstance(dask, Mapping)
        if not isinstance(dask, HighLevelGraph):
            dask = HighLevelGraph.from_collections(name, dask, dependencies=())
        self.dask = dask
        self._name = str(name)
        meta = meta_from_array(meta, dtype=dtype)
    
        if (
            isinstance(chunks, str)
            or isinstance(chunks, tuple)
            and chunks
            and any(isinstance(c, str) for c in chunks)
        ):
            dt = meta.dtype
        else:
            dt = None
        self._chunks = normalize_chunks(chunks, shape, dtype=dt)
        if self.chunks is None:
            raise ValueError(CHUNKS_NONE_ERROR_MESSAGE)
        self._meta = meta_from_array(meta, ndim=self.ndim, dtype=dtype)
    
        for plugin in config.get("array_plugins", ()):
            result = plugin(self)
            if result is not None:
                self = result
    
        try:
            layer = self.dask.layers[name]
        except (AttributeError, KeyError):
            # self is no longer an Array after applying the plugins, OR
            # a plugin replaced the HighLevelGraph with a plain dict, OR
            # name is not the top layer's name (this can happen after the layer is
            # manipulated, to avoid a collision)
            pass
        else:
>           if layer.collection_annotations is None:
E           AttributeError: 'dict' object has no attribute 'collection_annotations'

/home/swe-bench/miniconda3/envs/pydata__xarray__0.12/lib/python3.10/site-packages/dask/array/core.py:1365: AttributeError
__________________ test_map_blocks_da_ds_with_template[obj0] ___________________

obj = <xarray.DataArray 'a' (x: 10, y: 20)>
dask.array<xarray-<this-array>, shape=(10, 20), dtype=float64, chunksize=(4, 5),...meta=np.ndarray>
    cxy      (x, y) int64 dask.array<chunksize=(4, 5), meta=np.ndarray>
Attributes:
    test:     test

    @pytest.mark.parametrize("obj", [make_da(), make_ds()])
    def test_map_blocks_da_ds_with_template(obj):
        func = lambda x: x.isel(x=[1])
        template = obj.isel(x=[1, 5, 9])
        with raise_if_dask_computes():
>           actual = xr.map_blocks(func, obj, template=template)

/home/swe-bench/pydata__xarray/xarray/tests/test_dask.py:1273: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/home/swe-bench/pydata__xarray/xarray/core/parallel.py:566: in map_blocks
    data = dask.array.Array(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

cls = <class 'dask.array.core.Array'>
dask = HighLevelGraph with 8 layers.
<dask.highlevelgraph.HighLevelGraph object at 0x77b32405d0f0>
 0. xarray-<this-array>-cd...d4339938f426b28-cxy
 6. lambda-edfaf720c4c091694d4339938f426b28-ndcoord
 7. lambda-edfaf720c4c091694d4339938f426b28-c2

name = 'lambda-edfaf720c4c091694d4339938f426b28-c2', chunks = []
dtype = dtype('float64'), meta = array(0.), shape = None

    def __new__(cls, dask, name, chunks, dtype=None, meta=None, shape=None):
        self = super().__new__(cls)
        assert isinstance(dask, Mapping)
        if not isinstance(dask, HighLevelGraph):
            dask = HighLevelGraph.from_collections(name, dask, dependencies=())
        self.dask = dask
        self._name = str(name)
        meta = meta_from_array(meta, dtype=dtype)
    
        if (
            isinstance(chunks, str)
            or isinstance(chunks, tuple)
            and chunks
            and any(isinstance(c, str) for c in chunks)
        ):
            dt = meta.dtype
        else:
            dt = None
        self._chunks = normalize_chunks(chunks, shape, dtype=dt)
        if self.chunks is None:
            raise ValueError(CHUNKS_NONE_ERROR_MESSAGE)
        self._meta = meta_from_array(meta, ndim=self.ndim, dtype=dtype)
    
        for plugin in config.get("array_plugins", ()):
            result = plugin(self)
            if result is not None:
                self = result
    
        try:
            layer = self.dask.layers[name]
        except (AttributeError, KeyError):
            # self is no longer an Array after applying the plugins, OR
            # a plugin replaced the HighLevelGraph with a plain dict, OR
            # name is not the top layer's name (this can happen after the layer is
            # manipulated, to avoid a collision)
            pass
        else:
>           if layer.collection_annotations is None:
E           AttributeError: 'dict' object has no attribute 'collection_annotations'

/home/swe-bench/miniconda3/envs/pydata__xarray__0.12/lib/python3.10/site-packages/dask/array/core.py:1365: AttributeError
__________________ test_map_blocks_da_ds_with_template[obj1] ___________________

obj = <xarray.Dataset>
Dimensions:  (x: 10, y: 20, z: 4)
Coordinates:
  * x        (x) int64 0 1 2 3 4 5 6 7 8 9
  * y      ...64 1 1 1 1
    e        (x, y) int64 100 101 102 103 104 105 ... 123 124 125 126 127 128
Attributes:
    test:     test

    @pytest.mark.parametrize("obj", [make_da(), make_ds()])
    def test_map_blocks_da_ds_with_template(obj):
        func = lambda x: x.isel(x=[1])
        template = obj.isel(x=[1, 5, 9])
        with raise_if_dask_computes():
>           actual = xr.map_blocks(func, obj, template=template)

/home/swe-bench/pydata__xarray/xarray/tests/test_dask.py:1273: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/home/swe-bench/pydata__xarray/xarray/core/parallel.py:566: in map_blocks
    data = dask.array.Array(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

cls = <class 'dask.array.core.Array'>
dask = HighLevelGraph with 20 layers.
<dask.highlevelgraph.HighLevelGraph object at 0x77b324b72c80>
 0. array-9fc76b19d9f2299...73c61e7c6c304-cxy
 18. lambda-a460705fd8ef782905573c61e7c6c304-ndcoord
 19. lambda-a460705fd8ef782905573c61e7c6c304-c2

name = 'lambda-a460705fd8ef782905573c61e7c6c304-c2', chunks = []
dtype = dtype('float64'), meta = array(4.e-323), shape = None

    def __new__(cls, dask, name, chunks, dtype=None, meta=None, shape=None):
        self = super().__new__(cls)
        assert isinstance(dask, Mapping)
        if not isinstance(dask, HighLevelGraph):
            dask = HighLevelGraph.from_collections(name, dask, dependencies=())
        self.dask = dask
        self._name = str(name)
        meta = meta_from_array(meta, dtype=dtype)
    
        if (
            isinstance(chunks, str)
            or isinstance(chunks, tuple)
            and chunks
            and any(isinstance(c, str) for c in chunks)
        ):
            dt = meta.dtype
        else:
            dt = None
        self._chunks = normalize_chunks(chunks, shape, dtype=dt)
        if self.chunks is None:
            raise ValueError(CHUNKS_NONE_ERROR_MESSAGE)
        self._meta = meta_from_array(meta, ndim=self.ndim, dtype=dtype)
    
        for plugin in config.get("array_plugins", ()):
            result = plugin(self)
            if result is not None:
                self = result
    
        try:
            layer = self.dask.layers[name]
        except (AttributeError, KeyError):
            # self is no longer an Array after applying the plugins, OR
            # a plugin replaced the HighLevelGraph with a plain dict, OR
            # name is not the top layer's name (this can happen after the layer is
            # manipulated, to avoid a collision)
            pass
        else:
>           if layer.collection_annotations is None:
E           AttributeError: 'dict' object has no attribute 'collection_annotations'

/home/swe-bench/miniconda3/envs/pydata__xarray__0.12/lib/python3.10/site-packages/dask/array/core.py:1365: AttributeError
___________________ test_map_blocks_template_convert_object ____________________

    def test_map_blocks_template_convert_object():
        da = make_da()
        func = lambda x: x.to_dataset().isel(x=[1])
        template = da.to_dataset().isel(x=[1, 5, 9])
        with raise_if_dask_computes():
>           actual = xr.map_blocks(func, da, template=template)

/home/swe-bench/pydata__xarray/xarray/tests/test_dask.py:1286: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/home/swe-bench/pydata__xarray/xarray/core/parallel.py:566: in map_blocks
    data = dask.array.Array(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

cls = <class 'dask.array.core.Array'>
dask = HighLevelGraph with 8 layers.
<dask.highlevelgraph.HighLevelGraph object at 0x77b324b1f9a0>
 0. xarray-<this-array>-cd...d4339938f426b28-cxy
 6. lambda-edfaf720c4c091694d4339938f426b28-ndcoord
 7. lambda-edfaf720c4c091694d4339938f426b28-c2

name = 'lambda-edfaf720c4c091694d4339938f426b28-c2', chunks = []
dtype = dtype('float64'), meta = array(0.), shape = None

    def __new__(cls, dask, name, chunks, dtype=None, meta=None, shape=None):
        self = super().__new__(cls)
        assert isinstance(dask, Mapping)
        if not isinstance(dask, HighLevelGraph):
            dask = HighLevelGraph.from_collections(name, dask, dependencies=())
        self.dask = dask
        self._name = str(name)
        meta = meta_from_array(meta, dtype=dtype)
    
        if (
            isinstance(chunks, str)
            or isinstance(chunks, tuple)
            and chunks
            and any(isinstance(c, str) for c in chunks)
        ):
            dt = meta.dtype
        else:
            dt = None
        self._chunks = normalize_chunks(chunks, shape, dtype=dt)
        if self.chunks is None:
            raise ValueError(CHUNKS_NONE_ERROR_MESSAGE)
        self._meta = meta_from_array(meta, ndim=self.ndim, dtype=dtype)
    
        for plugin in config.get("array_plugins", ()):
            result = plugin(self)
            if result is not None:
                self = result
    
        try:
            layer = self.dask.layers[name]
        except (AttributeError, KeyError):
            # self is no longer an Array after applying the plugins, OR
            # a plugin replaced the HighLevelGraph with a plain dict, OR
            # name is not the top layer's name (this can happen after the layer is
            # manipulated, to avoid a collision)
            pass
        else:
>           if layer.collection_annotations is None:
E           AttributeError: 'dict' object has no attribute 'collection_annotations'

/home/swe-bench/miniconda3/envs/pydata__xarray__0.12/lib/python3.10/site-packages/dask/array/core.py:1365: AttributeError
__________________ test_map_blocks_errors_bad_template[obj0] ___________________

obj = <xarray.DataArray 'a' (x: 10, y: 20)>
dask.array<xarray-<this-array>, shape=(10, 20), dtype=float64, chunksize=(4, 5),...meta=np.ndarray>
    cxy      (x, y) int64 dask.array<chunksize=(4, 5), meta=np.ndarray>
Attributes:
    test:     test

    @pytest.mark.parametrize("obj", [make_da(), make_ds()])
    def test_map_blocks_errors_bad_template(obj):
        with raises_regex(ValueError, "unexpected coordinate variables"):
>           xr.map_blocks(lambda x: x.assign_coords(a=10), obj, template=obj).compute()

/home/swe-bench/pydata__xarray/xarray/tests/test_dask.py:1300: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/home/swe-bench/pydata__xarray/xarray/core/parallel.py:566: in map_blocks
    data = dask.array.Array(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

cls = <class 'dask.array.core.Array'>
dask = HighLevelGraph with 8 layers.
<dask.highlevelgraph.HighLevelGraph object at 0x77b324d4b010>
 0. xarray-<this-array>-cd...d4339938f426b28-cxy
 6. lambda-edfaf720c4c091694d4339938f426b28-ndcoord
 7. lambda-edfaf720c4c091694d4339938f426b28-c2

name = 'lambda-edfaf720c4c091694d4339938f426b28-c2', chunks = []
dtype = dtype('float64'), meta = array(0.), shape = None

    def __new__(cls, dask, name, chunks, dtype=None, meta=None, shape=None):
        self = super().__new__(cls)
        assert isinstance(dask, Mapping)
        if not isinstance(dask, HighLevelGraph):
            dask = HighLevelGraph.from_collections(name, dask, dependencies=())
        self.dask = dask
        self._name = str(name)
        meta = meta_from_array(meta, dtype=dtype)
    
        if (
            isinstance(chunks, str)
            or isinstance(chunks, tuple)
            and chunks
            and any(isinstance(c, str) for c in chunks)
        ):
            dt = meta.dtype
        else:
            dt = None
        self._chunks = normalize_chunks(chunks, shape, dtype=dt)
        if self.chunks is None:
            raise ValueError(CHUNKS_NONE_ERROR_MESSAGE)
        self._meta = meta_from_array(meta, ndim=self.ndim, dtype=dtype)
    
        for plugin in config.get("array_plugins", ()):
            result = plugin(self)
            if result is not None:
                self = result
    
        try:
            layer = self.dask.layers[name]
        except (AttributeError, KeyError):
            # self is no longer an Array after applying the plugins, OR
            # a plugin replaced the HighLevelGraph with a plain dict, OR
            # name is not the top layer's name (this can happen after the layer is
            # manipulated, to avoid a collision)
            pass
        else:
>           if layer.collection_annotations is None:
E           AttributeError: 'dict' object has no attribute 'collection_annotations'

/home/swe-bench/miniconda3/envs/pydata__xarray__0.12/lib/python3.10/site-packages/dask/array/core.py:1365: AttributeError
__________________ test_map_blocks_errors_bad_template[obj1] ___________________

obj = <xarray.Dataset>
Dimensions:  (x: 10, y: 20, z: 4)
Coordinates:
  * x        (x) int64 0 1 2 3 4 5 6 7 8 9
  * y      ...64 1 1 1 1
    e        (x, y) int64 100 101 102 103 104 105 ... 123 124 125 126 127 128
Attributes:
    test:     test

    @pytest.mark.parametrize("obj", [make_da(), make_ds()])
    def test_map_blocks_errors_bad_template(obj):
        with raises_regex(ValueError, "unexpected coordinate variables"):
>           xr.map_blocks(lambda x: x.assign_coords(a=10), obj, template=obj).compute()

/home/swe-bench/pydata__xarray/xarray/tests/test_dask.py:1300: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/home/swe-bench/pydata__xarray/xarray/core/parallel.py:566: in map_blocks
    data = dask.array.Array(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

cls = <class 'dask.array.core.Array'>
dask = HighLevelGraph with 20 layers.
<dask.highlevelgraph.HighLevelGraph object at 0x77b324b70a30>
 0. array-9fc76b19d9f2299...73c61e7c6c304-cxy
 18. lambda-a460705fd8ef782905573c61e7c6c304-ndcoord
 19. lambda-a460705fd8ef782905573c61e7c6c304-c2

name = 'lambda-a460705fd8ef782905573c61e7c6c304-c2', chunks = []
dtype = dtype('float64'), meta = array(0.), shape = None

    def __new__(cls, dask, name, chunks, dtype=None, meta=None, shape=None):
        self = super().__new__(cls)
        assert isinstance(dask, Mapping)
        if not isinstance(dask, HighLevelGraph):
            dask = HighLevelGraph.from_collections(name, dask, dependencies=())
        self.dask = dask
        self._name = str(name)
        meta = meta_from_array(meta, dtype=dtype)
    
        if (
            isinstance(chunks, str)
            or isinstance(chunks, tuple)
            and chunks
            and any(isinstance(c, str) for c in chunks)
        ):
            dt = meta.dtype
        else:
            dt = None
        self._chunks = normalize_chunks(chunks, shape, dtype=dt)
        if self.chunks is None:
            raise ValueError(CHUNKS_NONE_ERROR_MESSAGE)
        self._meta = meta_from_array(meta, ndim=self.ndim, dtype=dtype)
    
        for plugin in config.get("array_plugins", ()):
            result = plugin(self)
            if result is not None:
                self = result
    
        try:
            layer = self.dask.layers[name]
        except (AttributeError, KeyError):
            # self is no longer an Array after applying the plugins, OR
            # a plugin replaced the HighLevelGraph with a plain dict, OR
            # name is not the top layer's name (this can happen after the layer is
            # manipulated, to avoid a collision)
            pass
        else:
>           if layer.collection_annotations is None:
E           AttributeError: 'dict' object has no attribute 'collection_annotations'

/home/swe-bench/miniconda3/envs/pydata__xarray__0.12/lib/python3.10/site-packages/dask/array/core.py:1365: AttributeError
____________________ test_map_blocks_errors_bad_template_2 _____________________

map_ds = <xarray.Dataset>
Dimensions:  (x: 10, y: 20, z: 4)
Coordinates:
  * x        (x) int64 0 1 2 3 4 5 6 7 8 9
  * y      ...64 1 1 1 1
    e        (x, y) int64 100 101 102 103 104 105 ... 123 124 125 126 127 128
Attributes:
    test:     test

    def test_map_blocks_errors_bad_template_2(map_ds):
        with raises_regex(ValueError, "unexpected data variables {'xyz'}"):
>           xr.map_blocks(lambda x: x.assign(xyz=1), map_ds, template=map_ds).compute()

/home/swe-bench/pydata__xarray/xarray/tests/test_dask.py:1323: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/home/swe-bench/pydata__xarray/xarray/core/parallel.py:566: in map_blocks
    data = dask.array.Array(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

cls = <class 'dask.array.core.Array'>
dask = HighLevelGraph with 20 layers.
<dask.highlevelgraph.HighLevelGraph object at 0x77b324b1f070>
 0. array-9fc76b19d9f2299...73c61e7c6c304-cxy
 18. lambda-a460705fd8ef782905573c61e7c6c304-ndcoord
 19. lambda-a460705fd8ef782905573c61e7c6c304-c2

name = 'lambda-a460705fd8ef782905573c61e7c6c304-c2', chunks = []
dtype = dtype('float64'), meta = array(0.), shape = None

    def __new__(cls, dask, name, chunks, dtype=None, meta=None, shape=None):
        self = super().__new__(cls)
        assert isinstance(dask, Mapping)
        if not isinstance(dask, HighLevelGraph):
            dask = HighLevelGraph.from_collections(name, dask, dependencies=())
        self.dask = dask
        self._name = str(name)
        meta = meta_from_array(meta, dtype=dtype)
    
        if (
            isinstance(chunks, str)
            or isinstance(chunks, tuple)
            and chunks
            and any(isinstance(c, str) for c in chunks)
        ):
            dt = meta.dtype
        else:
            dt = None
        self._chunks = normalize_chunks(chunks, shape, dtype=dt)
        if self.chunks is None:
            raise ValueError(CHUNKS_NONE_ERROR_MESSAGE)
        self._meta = meta_from_array(meta, ndim=self.ndim, dtype=dtype)
    
        for plugin in config.get("array_plugins", ()):
            result = plugin(self)
            if result is not None:
                self = result
    
        try:
            layer = self.dask.layers[name]
        except (AttributeError, KeyError):
            # self is no longer an Array after applying the plugins, OR
            # a plugin replaced the HighLevelGraph with a plain dict, OR
            # name is not the top layer's name (this can happen after the layer is
            # manipulated, to avoid a collision)
            pass
        else:
>           if layer.collection_annotations is None:
E           AttributeError: 'dict' object has no attribute 'collection_annotations'

/home/swe-bench/miniconda3/envs/pydata__xarray__0.12/lib/python3.10/site-packages/dask/array/core.py:1365: AttributeError
_____________________ test_map_blocks_object_method[obj0] ______________________

obj = <xarray.DataArray 'a' (x: 10, y: 20)>
dask.array<xarray-<this-array>, shape=(10, 20), dtype=float64, chunksize=(4, 5),...meta=np.ndarray>
    cxy      (x, y) int64 dask.array<chunksize=(4, 5), meta=np.ndarray>
Attributes:
    test:     test

    @pytest.mark.parametrize("obj", [make_da(), make_ds()])
    def test_map_blocks_object_method(obj):
        def func(obj):
            result = obj + obj.x + 5 * obj.y
            return result
    
        with raise_if_dask_computes():
>           expected = xr.map_blocks(func, obj)

/home/swe-bench/pydata__xarray/xarray/tests/test_dask.py:1333: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/home/swe-bench/pydata__xarray/xarray/core/parallel.py:566: in map_blocks
    data = dask.array.Array(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

cls = <class 'dask.array.core.Array'>
dask = HighLevelGraph with 8 layers.
<dask.highlevelgraph.HighLevelGraph object at 0x77b3252a0820>
 0. xarray-<this-array>-cd...1694d4339938f426b28-cxy
 6. func-edfaf720c4c091694d4339938f426b28-ndcoord
 7. func-edfaf720c4c091694d4339938f426b28-c2

name = 'func-edfaf720c4c091694d4339938f426b28-c2', chunks = []
dtype = dtype('float64'), meta = array(2.5e-323), shape = None

    def __new__(cls, dask, name, chunks, dtype=None, meta=None, shape=None):
        self = super().__new__(cls)
        assert isinstance(dask, Mapping)
        if not isinstance(dask, HighLevelGraph):
            dask = HighLevelGraph.from_collections(name, dask, dependencies=())
        self.dask = dask
        self._name = str(name)
        meta = meta_from_array(meta, dtype=dtype)
    
        if (
            isinstance(chunks, str)
            or isinstance(chunks, tuple)
            and chunks
            and any(isinstance(c, str) for c in chunks)
        ):
            dt = meta.dtype
        else:
            dt = None
        self._chunks = normalize_chunks(chunks, shape, dtype=dt)
        if self.chunks is None:
            raise ValueError(CHUNKS_NONE_ERROR_MESSAGE)
        self._meta = meta_from_array(meta, ndim=self.ndim, dtype=dtype)
    
        for plugin in config.get("array_plugins", ()):
            result = plugin(self)
            if result is not None:
                self = result
    
        try:
            layer = self.dask.layers[name]
        except (AttributeError, KeyError):
            # self is no longer an Array after applying the plugins, OR
            # a plugin replaced the HighLevelGraph with a plain dict, OR
            # name is not the top layer's name (this can happen after the layer is
            # manipulated, to avoid a collision)
            pass
        else:
>           if layer.collection_annotations is None:
E           AttributeError: 'dict' object has no attribute 'collection_annotations'

/home/swe-bench/miniconda3/envs/pydata__xarray__0.12/lib/python3.10/site-packages/dask/array/core.py:1365: AttributeError
_____________________ test_map_blocks_object_method[obj1] ______________________

obj = <xarray.Dataset>
Dimensions:  (x: 10, y: 20, z: 4)
Coordinates:
  * x        (x) int64 0 1 2 3 4 5 6 7 8 9
  * y      ...64 1 1 1 1
    e        (x, y) int64 100 101 102 103 104 105 ... 123 124 125 126 127 128
Attributes:
    test:     test

    @pytest.mark.parametrize("obj", [make_da(), make_ds()])
    def test_map_blocks_object_method(obj):
        def func(obj):
            result = obj + obj.x + 5 * obj.y
            return result
    
        with raise_if_dask_computes():
>           expected = xr.map_blocks(func, obj)

/home/swe-bench/pydata__xarray/xarray/tests/test_dask.py:1333: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/home/swe-bench/pydata__xarray/xarray/core/parallel.py:566: in map_blocks
    data = dask.array.Array(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

cls = <class 'dask.array.core.Array'>
dask = HighLevelGraph with 20 layers.
<dask.highlevelgraph.HighLevelGraph object at 0x77b324062c50>
 0. array-9fc76b19d9f2299...a429cd05fd7f8f0ba-cxy
 18. func-8e0b79e9fe44b20a429cd05fd7f8f0ba-ndcoord
 19. func-8e0b79e9fe44b20a429cd05fd7f8f0ba-c2

name = 'func-8e0b79e9fe44b20a429cd05fd7f8f0ba-c2', chunks = []
dtype = dtype('float64'), meta = array(2.5e-323), shape = None

    def __new__(cls, dask, name, chunks, dtype=None, meta=None, shape=None):
        self = super().__new__(cls)
        assert isinstance(dask, Mapping)
        if not isinstance(dask, HighLevelGraph):
            dask = HighLevelGraph.from_collections(name, dask, dependencies=())
        self.dask = dask
        self._name = str(name)
        meta = meta_from_array(meta, dtype=dtype)
    
        if (
            isinstance(chunks, str)
            or isinstance(chunks, tuple)
            and chunks
            and any(isinstance(c, str) for c in chunks)
        ):
            dt = meta.dtype
        else:
            dt = None
        self._chunks = normalize_chunks(chunks, shape, dtype=dt)
        if self.chunks is None:
            raise ValueError(CHUNKS_NONE_ERROR_MESSAGE)
        self._meta = meta_from_array(meta, ndim=self.ndim, dtype=dtype)
    
        for plugin in config.get("array_plugins", ()):
            result = plugin(self)
            if result is not None:
                self = result
    
        try:
            layer = self.dask.layers[name]
        except (AttributeError, KeyError):
            # self is no longer an Array after applying the plugins, OR
            # a plugin replaced the HighLevelGraph with a plain dict, OR
            # name is not the top layer's name (this can happen after the layer is
            # manipulated, to avoid a collision)
            pass
        else:
>           if layer.collection_annotations is None:
E           AttributeError: 'dict' object has no attribute 'collection_annotations'

/home/swe-bench/miniconda3/envs/pydata__xarray__0.12/lib/python3.10/site-packages/dask/array/core.py:1365: AttributeError
__________________________ test_map_blocks_hlg_layers __________________________

    def test_map_blocks_hlg_layers():
        # regression test for #3599
        ds = xr.Dataset(
            {
                "x": (("a",), dask.array.ones(10, chunks=(5,))),
                "z": (("b",), dask.array.ones(10, chunks=(5,))),
            }
        )
>       mapped = ds.map_blocks(lambda x: x)

/home/swe-bench/pydata__xarray/xarray/tests/test_dask.py:1347: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/home/swe-bench/pydata__xarray/xarray/core/dataset.py:6328: in map_blocks
    return map_blocks(func, self, args, kwargs, template)
/home/swe-bench/pydata__xarray/xarray/core/parallel.py:566: in map_blocks
    data = dask.array.Array(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

cls = <class 'dask.array.core.Array'>
dask = HighLevelGraph with 4 layers.
<dask.highlevelgraph.HighLevelGraph object at 0x77b3252a08b0>
 0. ones_like-4b490aea6a75...cc5f8063f661fc44326ad7d29c
 2. lambda-3d8602cc5f8063f661fc44326ad7d29c-z
 3. lambda-3d8602cc5f8063f661fc44326ad7d29c-x

name = 'lambda-3d8602cc5f8063f661fc44326ad7d29c-x', chunks = [(5, 5)]
dtype = dtype('float64'), meta = array(2.5e-323), shape = None

    def __new__(cls, dask, name, chunks, dtype=None, meta=None, shape=None):
        self = super().__new__(cls)
        assert isinstance(dask, Mapping)
        if not isinstance(dask, HighLevelGraph):
            dask = HighLevelGraph.from_collections(name, dask, dependencies=())
        self.dask = dask
        self._name = str(name)
        meta = meta_from_array(meta, dtype=dtype)
    
        if (
            isinstance(chunks, str)
            or isinstance(chunks, tuple)
            and chunks
            and any(isinstance(c, str) for c in chunks)
        ):
            dt = meta.dtype
        else:
            dt = None
        self._chunks = normalize_chunks(chunks, shape, dtype=dt)
        if self.chunks is None:
            raise ValueError(CHUNKS_NONE_ERROR_MESSAGE)
        self._meta = meta_from_array(meta, ndim=self.ndim, dtype=dtype)
    
        for plugin in config.get("array_plugins", ()):
            result = plugin(self)
            if result is not None:
                self = result
    
        try:
            layer = self.dask.layers[name]
        except (AttributeError, KeyError):
            # self is no longer an Array after applying the plugins, OR
            # a plugin replaced the HighLevelGraph with a plain dict, OR
            # name is not the top layer's name (this can happen after the layer is
            # manipulated, to avoid a collision)
            pass
        else:
>           if layer.collection_annotations is None:
E           AttributeError: 'dict' object has no attribute 'collection_annotations'

/home/swe-bench/miniconda3/envs/pydata__xarray__0.12/lib/python3.10/site-packages/dask/array/core.py:1365: AttributeError
_______________________ TestDataset.test_sel_categorical _______________________

self = <xarray.tests.test_dataset.TestDataset object at 0x77b323edd870>

    def test_sel_categorical(self):
        ind = pd.Series(["foo", "bar"], dtype="category")
        df = pd.DataFrame({"ind": ind, "values": [1, 2]})
>       ds = df.set_index("ind").to_xarray()

/home/swe-bench/pydata__xarray/xarray/tests/test_dataset.py:1432: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/home/swe-bench/miniconda3/envs/pydata__xarray__0.12/lib/python3.10/site-packages/pandas/core/generic.py:3222: in to_xarray
    xarray = import_optional_dependency("xarray")
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'xarray', extra = '', errors = 'raise', min_version = None

    def import_optional_dependency(
        name: str,
        extra: str = "",
        errors: str = "raise",
        min_version: str | None = None,
    ):
        """
        Import an optional dependency.
    
        By default, if a dependency is missing an ImportError with a nice
        message will be raised. If a dependency is present, but too old,
        we raise.
    
        Parameters
        ----------
        name : str
            The module name.
        extra : str
            Additional text to include in the ImportError message.
        errors : str {'raise', 'warn', 'ignore'}
            What to do when a dependency is not found or its version is too old.
    
            * raise : Raise an ImportError
            * warn : Only applicable when a module's version is to old.
              Warns that the version is too old and returns None
            * ignore: If the module is not installed, return None, otherwise,
              return the module, even if the version is too old.
              It's expected that users validate the version locally when
              using ``errors="ignore"`` (see. ``io/html.py``)
        min_version : str, default None
            Specify a minimum version that is different from the global pandas
            minimum version required.
        Returns
        -------
        maybe_module : Optional[ModuleType]
            The imported module, when found and the version is correct.
            None is returned when the package is not found and `errors`
            is False, or when the package's version is too old and `errors`
            is ``'warn'``.
        """
    
        assert errors in {"warn", "raise", "ignore"}
    
        package_name = INSTALL_MAPPING.get(name)
        install_name = package_name if package_name is not None else name
    
        msg = (
            f"Missing optional dependency '{install_name}'. {extra} "
            f"Use pip or conda to install {install_name}."
        )
        try:
            module = importlib.import_module(name)
        except ImportError:
            if errors == "raise":
                raise ImportError(msg)
            else:
                return None
    
        # Handle submodules: if we have submodule, grab parent module from sys.modules
        parent = name.split(".")[0]
        if parent != name:
            install_name = parent
            module_to_get = sys.modules[install_name]
        else:
            module_to_get = module
        minimum_version = min_version if min_version is not None else VERSIONS.get(parent)
        if minimum_version:
            version = get_version(module_to_get)
            if version and Version(version) < Version(minimum_version):
                msg = (
                    f"Pandas requires version '{minimum_version}' or newer of '{parent}' "
                    f"(version '{version}' currently installed)."
                )
                if errors == "warn":
                    warnings.warn(
                        msg,
                        UserWarning,
                        stacklevel=find_stack_level(),
                    )
                    return None
                elif errors == "raise":
>                   raise ImportError(msg)
E                   ImportError: Pandas requires version '0.19.0' or newer of 'xarray' (version '0.17.1.dev100+g1c198a19' currently installed).

/home/swe-bench/miniconda3/envs/pydata__xarray__0.12/lib/python3.10/site-packages/pandas/compat/_optional.py:171: ImportError
____________________ TestDataset.test_sel_categorical_error ____________________

self = <xarray.tests.test_dataset.TestDataset object at 0x77b323eddae0>

    def test_sel_categorical_error(self):
        ind = pd.Series(["foo", "bar"], dtype="category")
        df = pd.DataFrame({"ind": ind, "values": [1, 2]})
>       ds = df.set_index("ind").to_xarray()

/home/swe-bench/pydata__xarray/xarray/tests/test_dataset.py:1440: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/home/swe-bench/miniconda3/envs/pydata__xarray__0.12/lib/python3.10/site-packages/pandas/core/generic.py:3222: in to_xarray
    xarray = import_optional_dependency("xarray")
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'xarray', extra = '', errors = 'raise', min_version = None

    def import_optional_dependency(
        name: str,
        extra: str = "",
        errors: str = "raise",
        min_version: str | None = None,
    ):
        """
        Import an optional dependency.
    
        By default, if a dependency is missing an ImportError with a nice
        message will be raised. If a dependency is present, but too old,
        we raise.
    
        Parameters
        ----------
        name : str
            The module name.
        extra : str
            Additional text to include in the ImportError message.
        errors : str {'raise', 'warn', 'ignore'}
            What to do when a dependency is not found or its version is too old.
    
            * raise : Raise an ImportError
            * warn : Only applicable when a module's version is to old.
              Warns that the version is too old and returns None
            * ignore: If the module is not installed, return None, otherwise,
              return the module, even if the version is too old.
              It's expected that users validate the version locally when
              using ``errors="ignore"`` (see. ``io/html.py``)
        min_version : str, default None
            Specify a minimum version that is different from the global pandas
            minimum version required.
        Returns
        -------
        maybe_module : Optional[ModuleType]
            The imported module, when found and the version is correct.
            None is returned when the package is not found and `errors`
            is False, or when the package's version is too old and `errors`
            is ``'warn'``.
        """
    
        assert errors in {"warn", "raise", "ignore"}
    
        package_name = INSTALL_MAPPING.get(name)
        install_name = package_name if package_name is not None else name
    
        msg = (
            f"Missing optional dependency '{install_name}'. {extra} "
            f"Use pip or conda to install {install_name}."
        )
        try:
            module = importlib.import_module(name)
        except ImportError:
            if errors == "raise":
                raise ImportError(msg)
            else:
                return None
    
        # Handle submodules: if we have submodule, grab parent module from sys.modules
        parent = name.split(".")[0]
        if parent != name:
            install_name = parent
            module_to_get = sys.modules[install_name]
        else:
            module_to_get = module
        minimum_version = min_version if min_version is not None else VERSIONS.get(parent)
        if minimum_version:
            version = get_version(module_to_get)
            if version and Version(version) < Version(minimum_version):
                msg = (
                    f"Pandas requires version '{minimum_version}' or newer of '{parent}' "
                    f"(version '{version}' currently installed)."
                )
                if errors == "warn":
                    warnings.warn(
                        msg,
                        UserWarning,
                        stacklevel=find_stack_level(),
                    )
                    return None
                elif errors == "raise":
>                   raise ImportError(msg)
E                   ImportError: Pandas requires version '0.19.0' or newer of 'xarray' (version '0.17.1.dev100+g1c198a19' currently installed).

/home/swe-bench/miniconda3/envs/pydata__xarray__0.12/lib/python3.10/site-packages/pandas/compat/_optional.py:171: ImportError
___________________ TestDataset.test_categorical_multiindex ____________________

self = <xarray.tests.test_dataset.TestDataset object at 0x77b323edd270>

    def test_categorical_multiindex(self):
        i1 = pd.Series([0, 0])
        cat = pd.CategoricalDtype(categories=["foo", "baz", "bar"])
        i2 = pd.Series(["baz", "bar"], dtype=cat)
    
        df = pd.DataFrame({"i1": i1, "i2": i2, "values": [1, 2]}).set_index(
            ["i1", "i2"]
        )
>       actual = df.to_xarray()

/home/swe-bench/pydata__xarray/xarray/tests/test_dataset.py:1487: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/home/swe-bench/miniconda3/envs/pydata__xarray__0.12/lib/python3.10/site-packages/pandas/core/generic.py:3222: in to_xarray
    xarray = import_optional_dependency("xarray")
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'xarray', extra = '', errors = 'raise', min_version = None

    def import_optional_dependency(
        name: str,
        extra: str = "",
        errors: str = "raise",
        min_version: str | None = None,
    ):
        """
        Import an optional dependency.
    
        By default, if a dependency is missing an ImportError with a nice
        message will be raised. If a dependency is present, but too old,
        we raise.
    
        Parameters
        ----------
        name : str
            The module name.
        extra : str
            Additional text to include in the ImportError message.
        errors : str {'raise', 'warn', 'ignore'}
            What to do when a dependency is not found or its version is too old.
    
            * raise : Raise an ImportError
            * warn : Only applicable when a module's version is to old.
              Warns that the version is too old and returns None
            * ignore: If the module is not installed, return None, otherwise,
              return the module, even if the version is too old.
              It's expected that users validate the version locally when
              using ``errors="ignore"`` (see. ``io/html.py``)
        min_version : str, default None
            Specify a minimum version that is different from the global pandas
            minimum version required.
        Returns
        -------
        maybe_module : Optional[ModuleType]
            The imported module, when found and the version is correct.
            None is returned when the package is not found and `errors`
            is False, or when the package's version is too old and `errors`
            is ``'warn'``.
        """
    
        assert errors in {"warn", "raise", "ignore"}
    
        package_name = INSTALL_MAPPING.get(name)
        install_name = package_name if package_name is not None else name
    
        msg = (
            f"Missing optional dependency '{install_name}'. {extra} "
            f"Use pip or conda to install {install_name}."
        )
        try:
            module = importlib.import_module(name)
        except ImportError:
            if errors == "raise":
                raise ImportError(msg)
            else:
                return None
    
        # Handle submodules: if we have submodule, grab parent module from sys.modules
        parent = name.split(".")[0]
        if parent != name:
            install_name = parent
            module_to_get = sys.modules[install_name]
        else:
            module_to_get = module
        minimum_version = min_version if min_version is not None else VERSIONS.get(parent)
        if minimum_version:
            version = get_version(module_to_get)
            if version and Version(version) < Version(minimum_version):
                msg = (
                    f"Pandas requires version '{minimum_version}' or newer of '{parent}' "
                    f"(version '{version}' currently installed)."
                )
                if errors == "warn":
                    warnings.warn(
                        msg,
                        UserWarning,
                        stacklevel=find_stack_level(),
                    )
                    return None
                elif errors == "raise":
>                   raise ImportError(msg)
E                   ImportError: Pandas requires version '0.19.0' or newer of 'xarray' (version '0.17.1.dev100+g1c198a19' currently installed).

/home/swe-bench/miniconda3/envs/pydata__xarray__0.12/lib/python3.10/site-packages/pandas/compat/_optional.py:171: ImportError
_______________________ TestDataset.test_reindex_warning _______________________

self = <xarray.tests.test_dataset.TestDataset object at 0x77b323edf7c0>

    def test_reindex_warning(self):
        data = create_test_data()
    
        with pytest.raises(ValueError):
            # DataArray with different dimension raises Future warning
            ind = xr.DataArray([0.0, 1.0], dims=["new_dim"], name="ind")
            data.reindex(dim2=ind)
    
        # Should not warn
        ind = xr.DataArray([0.0, 1.0], dims=["dim2"], name="ind")
>       with pytest.warns(None) as ws:

/home/swe-bench/pydata__xarray/xarray/tests/test_dataset.py:1876: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = WarningsChecker(record=True), expected_warning = None, match_expr = None

    def __init__(
        self,
        expected_warning: Union[Type[Warning], Tuple[Type[Warning], ...]] = Warning,
        match_expr: Optional[Union[str, Pattern[str]]] = None,
        *,
        _ispytest: bool = False,
    ) -> None:
        check_ispytest(_ispytest)
        super().__init__(_ispytest=True)
    
        msg = "exceptions must be derived from Warning, not %s"
        if isinstance(expected_warning, tuple):
            for exc in expected_warning:
                if not issubclass(exc, Warning):
                    raise TypeError(msg % type(exc))
            expected_warning_tup = expected_warning
        elif isinstance(expected_warning, type) and issubclass(
            expected_warning, Warning
        ):
            expected_warning_tup = (expected_warning,)
        else:
>           raise TypeError(msg % type(expected_warning))
E           TypeError: exceptions must be derived from Warning, not <class 'NoneType'>

/home/swe-bench/miniconda3/envs/pydata__xarray__0.12/lib/python3.10/site-packages/_pytest/recwarn.py:285: TypeError
______________________ TestDataset.test_drop_index_labels ______________________

self = <xarray.tests.test_dataset.TestDataset object at 0x77b323eee860>

    def test_drop_index_labels(self):
        data = Dataset({"A": (["x", "y"], np.random.randn(2, 3)), "x": ["a", "b"]})
    
        with pytest.warns(DeprecationWarning):
            actual = data.drop(["a"], dim="x")
        expected = data.isel(x=[1])
        assert_identical(expected, actual)
    
        with pytest.warns(DeprecationWarning):
            actual = data.drop(["a", "b"], dim="x")
        expected = data.isel(x=slice(0, 0))
        assert_identical(expected, actual)
    
        with pytest.raises(KeyError):
            # not contained in axis
            with pytest.warns(DeprecationWarning):
                data.drop(["c"], dim="x")
    
        with pytest.warns(DeprecationWarning):
            actual = data.drop(["c"], dim="x", errors="ignore")
        assert_identical(data, actual)
    
        with pytest.raises(ValueError):
            with pytest.warns(DeprecationWarning):
>               data.drop(["c"], dim="x", errors="wrong_value")

/home/swe-bench/pydata__xarray/xarray/tests/test_dataset.py:2358: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <xarray.Dataset>
Dimensions:  (x: 2, y: 3)
Coordinates:
  * x        (x) <U1 'a' 'b'
Dimensions without coordinates: y
Data variables:
    A        (x, y) float64 1.764 0.4002 0.9787 2.241 1.868 -0.9773
labels = ['c'], dim = 'x', errors = 'wrong_value', labels_kwargs = {}

    def drop(self, labels=None, dim=None, *, errors="raise", **labels_kwargs):
        """Backward compatible method based on `drop_vars` and `drop_sel`
    
        Using either `drop_vars` or `drop_sel` is encouraged
    
        See Also
        --------
        Dataset.drop_vars
        Dataset.drop_sel
        """
        if errors not in ["raise", "ignore"]:
>           raise ValueError('errors must be either "raise" or "ignore"')
E           ValueError: errors must be either "raise" or "ignore"

/home/swe-bench/pydata__xarray/xarray/core/dataset.py:4038: ValueError

During handling of the above exception, another exception occurred:

self = <xarray.tests.test_dataset.TestDataset object at 0x77b323eee860>

    def test_drop_index_labels(self):
        data = Dataset({"A": (["x", "y"], np.random.randn(2, 3)), "x": ["a", "b"]})
    
        with pytest.warns(DeprecationWarning):
            actual = data.drop(["a"], dim="x")
        expected = data.isel(x=[1])
        assert_identical(expected, actual)
    
        with pytest.warns(DeprecationWarning):
            actual = data.drop(["a", "b"], dim="x")
        expected = data.isel(x=slice(0, 0))
        assert_identical(expected, actual)
    
        with pytest.raises(KeyError):
            # not contained in axis
            with pytest.warns(DeprecationWarning):
                data.drop(["c"], dim="x")
    
        with pytest.warns(DeprecationWarning):
            actual = data.drop(["c"], dim="x", errors="ignore")
        assert_identical(data, actual)
    
        with pytest.raises(ValueError):
>           with pytest.warns(DeprecationWarning):
E           Failed: DID NOT WARN. No warnings of type (<class 'DeprecationWarning'>,) were emitted.
E            Emitted warnings: [].

/home/swe-bench/pydata__xarray/xarray/tests/test_dataset.py:2357: Failed
_________________ TestDataset.test_from_dataframe_categorical __________________

self = <xarray.tests.test_dataset.TestDataset object at 0x77b323e9f340>

    def test_from_dataframe_categorical(self):
        cat = pd.CategoricalDtype(
            categories=["foo", "bar", "baz", "qux", "quux", "corge"]
        )
        i1 = pd.Series(["foo", "bar", "foo"], dtype=cat)
        i2 = pd.Series(["bar", "bar", "baz"], dtype=cat)
    
        df = pd.DataFrame({"i1": i1, "i2": i2, "values": [1, 2, 3]})
>       ds = df.set_index("i1").to_xarray()

/home/swe-bench/pydata__xarray/xarray/tests/test_dataset.py:4131: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/home/swe-bench/miniconda3/envs/pydata__xarray__0.12/lib/python3.10/site-packages/pandas/core/generic.py:3222: in to_xarray
    xarray = import_optional_dependency("xarray")
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'xarray', extra = '', errors = 'raise', min_version = None

    def import_optional_dependency(
        name: str,
        extra: str = "",
        errors: str = "raise",
        min_version: str | None = None,
    ):
        """
        Import an optional dependency.
    
        By default, if a dependency is missing an ImportError with a nice
        message will be raised. If a dependency is present, but too old,
        we raise.
    
        Parameters
        ----------
        name : str
            The module name.
        extra : str
            Additional text to include in the ImportError message.
        errors : str {'raise', 'warn', 'ignore'}
            What to do when a dependency is not found or its version is too old.
    
            * raise : Raise an ImportError
            * warn : Only applicable when a module's version is to old.
              Warns that the version is too old and returns None
            * ignore: If the module is not installed, return None, otherwise,
              return the module, even if the version is too old.
              It's expected that users validate the version locally when
              using ``errors="ignore"`` (see. ``io/html.py``)
        min_version : str, default None
            Specify a minimum version that is different from the global pandas
            minimum version required.
        Returns
        -------
        maybe_module : Optional[ModuleType]
            The imported module, when found and the version is correct.
            None is returned when the package is not found and `errors`
            is False, or when the package's version is too old and `errors`
            is ``'warn'``.
        """
    
        assert errors in {"warn", "raise", "ignore"}
    
        package_name = INSTALL_MAPPING.get(name)
        install_name = package_name if package_name is not None else name
    
        msg = (
            f"Missing optional dependency '{install_name}'. {extra} "
            f"Use pip or conda to install {install_name}."
        )
        try:
            module = importlib.import_module(name)
        except ImportError:
            if errors == "raise":
                raise ImportError(msg)
            else:
                return None
    
        # Handle submodules: if we have submodule, grab parent module from sys.modules
        parent = name.split(".")[0]
        if parent != name:
            install_name = parent
            module_to_get = sys.modules[install_name]
        else:
            module_to_get = module
        minimum_version = min_version if min_version is not None else VERSIONS.get(parent)
        if minimum_version:
            version = get_version(module_to_get)
            if version and Version(version) < Version(minimum_version):
                msg = (
                    f"Pandas requires version '{minimum_version}' or newer of '{parent}' "
                    f"(version '{version}' currently installed)."
                )
                if errors == "warn":
                    warnings.warn(
                        msg,
                        UserWarning,
                        stacklevel=find_stack_level(),
                    )
                    return None
                elif errors == "raise":
>                   raise ImportError(msg)
E                   ImportError: Pandas requires version '0.19.0' or newer of 'xarray' (version '0.17.1.dev100+g1c198a19' currently installed).

/home/swe-bench/miniconda3/envs/pydata__xarray__0.12/lib/python3.10/site-packages/pandas/compat/_optional.py:171: ImportError
______________________ TestDataset.test_polyfit_warnings _______________________

self = <xarray.tests.test_dataset.TestDataset object at 0x77b323e6af20>

    def test_polyfit_warnings(self):
        ds = create_test_data(seed=1)
    
        with warnings.catch_warnings(record=True) as ws:
            ds.var1.polyfit("dim2", 10, full=False)
>           assert len(ws) == 1
E           assert 3 == 1
E            +  where 3 = len([<warnings.WarningMessage object at 0x77b3237e4250>, <warnings.WarningMessage object at 0x77b32328c430>, <warnings.WarningMessage object at 0x77b32328df90>])

/home/swe-bench/pydata__xarray/xarray/tests/test_dataset.py:5783: AssertionError
_________________ test_raise_no_warning_for_nan_in_binary_ops __________________

    def test_raise_no_warning_for_nan_in_binary_ops():
>       with pytest.warns(None) as record:

/home/swe-bench/pydata__xarray/xarray/tests/test_dataset.py:6395: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = WarningsChecker(record=True), expected_warning = None, match_expr = None

    def __init__(
        self,
        expected_warning: Union[Type[Warning], Tuple[Type[Warning], ...]] = Warning,
        match_expr: Optional[Union[str, Pattern[str]]] = None,
        *,
        _ispytest: bool = False,
    ) -> None:
        check_ispytest(_ispytest)
        super().__init__(_ispytest=True)
    
        msg = "exceptions must be derived from Warning, not %s"
        if isinstance(expected_warning, tuple):
            for exc in expected_warning:
                if not issubclass(exc, Warning):
                    raise TypeError(msg % type(exc))
            expected_warning_tup = expected_warning
        elif isinstance(expected_warning, type) and issubclass(
            expected_warning, Warning
        ):
            expected_warning_tup = (expected_warning,)
        else:
>           raise TypeError(msg % type(expected_warning))
E           TypeError: exceptions must be derived from Warning, not <class 'NoneType'>

/home/swe-bench/miniconda3/envs/pydata__xarray__0.12/lib/python3.10/site-packages/_pytest/recwarn.py:285: TypeError
_________________ test_raise_no_warning_for_nan_in_binary_ops __________________

    def test_raise_no_warning_for_nan_in_binary_ops():
>       with pytest.warns(None) as record:

/home/swe-bench/pydata__xarray/xarray/tests/test_variable.py:2316: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = WarningsChecker(record=True), expected_warning = None, match_expr = None

    def __init__(
        self,
        expected_warning: Union[Type[Warning], Tuple[Type[Warning], ...]] = Warning,
        match_expr: Optional[Union[str, Pattern[str]]] = None,
        *,
        _ispytest: bool = False,
    ) -> None:
        check_ispytest(_ispytest)
        super().__init__(_ispytest=True)
    
        msg = "exceptions must be derived from Warning, not %s"
        if isinstance(expected_warning, tuple):
            for exc in expected_warning:
                if not issubclass(exc, Warning):
                    raise TypeError(msg % type(exc))
            expected_warning_tup = expected_warning
        elif isinstance(expected_warning, type) and issubclass(
            expected_warning, Warning
        ):
            expected_warning_tup = (expected_warning,)
        else:
>           raise TypeError(msg % type(expected_warning))
E           TypeError: exceptions must be derived from Warning, not <class 'NoneType'>

/home/swe-bench/miniconda3/envs/pydata__xarray__0.12/lib/python3.10/site-packages/_pytest/recwarn.py:285: TypeError
================================== XFAILURES ===================================
___________ TestToDaskDataFrame.test_to_dask_dataframe_2D_set_index ____________

self = <xarray.tests.test_dask.TestToDaskDataFrame object at 0x77b32537e0b0>

    @pytest.mark.xfail(raises=NotImplementedError)
    def test_to_dask_dataframe_2D_set_index(self):
        # This will fail until dask implements MultiIndex support
        w = da.from_array(np.random.randn(2, 3), chunks=(1, 2))
        ds = Dataset({"w": (("x", "y"), w)})
        ds["x"] = ("x", np.array([0, 1], np.int64))
        ds["y"] = ("y", list("abc"))
    
        expected = ds.compute().to_dataframe()
>       actual = ds.to_dask_dataframe(set_index=True)

/home/swe-bench/pydata__xarray/xarray/tests/test_dask.py:790: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/home/swe-bench/pydata__xarray/xarray/core/dataset.py:5216: in to_dask_dataframe
    df = df.set_index(dim_order)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = Dask DataFrame Structure:
                   x       y        w
npartitions=3                        
0              i.....
3                ...     ...      ...
5                ...     ...      ...
Dask Name: concat-indexed, 1 graph layer
other = ['x', 'y'], drop = True, npartitions = None, divisions = None
inplace = False, sort = True, kwargs = {}, pre_sorted = False

    def set_index(
        self,
        other: str | Series,
        drop: bool = True,
        sorted: bool = False,
        npartitions: int | Literal["auto"] | None = None,
        divisions: Sequence | None = None,
        inplace: bool = False,
        sort: bool = True,
        **kwargs,
    ):
        """Set the DataFrame index (row labels) using an existing column.
    
        If ``sort=False``, this function operates exactly like ``pandas.set_index``
        and sets the index on the DataFrame. If ``sort=True`` (default),
        this function also sorts the DataFrame by the new index. This can have a
        significant impact on performance, because joins, groupbys, lookups, etc.
        are all much faster on that column. However, this performance increase
        comes with a cost, sorting a parallel dataset requires expensive shuffles.
        Often we ``set_index`` once directly after data ingest and filtering and
        then perform many cheap computations off of the sorted dataset.
    
        With ``sort=True``, this function is much more expensive. Under normal
        operation this function does an initial pass over the index column to
        compute approximate quantiles to serve as future divisions. It then passes
        over the data a second time, splitting up each input partition into several
        pieces and sharing those pieces to all of the output partitions now in
        sorted order.
    
        In some cases we can alleviate those costs, for example if your dataset is
        sorted already then we can avoid making many small pieces or if you know
        good values to split the new index column then we can avoid the initial
        pass over the data. For example if your new index is a datetime index and
        your data is already sorted by day then this entire operation can be done
        for free. You can control these options with the following parameters.
    
        Parameters
        ----------
        other: string or Dask Series
            Column to use as index.
        drop: boolean, default True
            Delete column to be used as the new index.
        sorted: bool, optional
            If the index column is already sorted in increasing order.
            Defaults to False
        npartitions: int, None, or 'auto'
            The ideal number of output partitions. If None, use the same as
            the input. If 'auto' then decide by memory use.
            Only used when ``divisions`` is not given. If ``divisions`` is given,
            the number of output partitions will be ``len(divisions) - 1``.
        divisions: list, optional
            The "dividing lines" used to split the new index into partitions.
            For ``divisions=[0, 10, 50, 100]``, there would be three output partitions,
            where the new index contained [0, 10), [10, 50), and [50, 100), respectively.
            See https://docs.dask.org/en/latest/dataframe-design.html#partitions.
            If not given (default), good divisions are calculated by immediately computing
            the data and looking at the distribution of its values. For large datasets,
            this can be expensive.
            Note that if ``sorted=True``, specified divisions are assumed to match
            the existing partitions in the data; if this is untrue you should
            leave divisions empty and call ``repartition`` after ``set_index``.
        inplace: bool, optional
            Modifying the DataFrame in place is not supported by Dask.
            Defaults to False.
        sort: bool, optional
            If ``True``, sort the DataFrame by the new index. Otherwise
            set the index on the individual existing partitions.
            Defaults to ``True``.
        shuffle_method: {'disk', 'tasks', 'p2p'}, optional
            Either ``'disk'`` for single-node operation or ``'tasks'`` and
            ``'p2p'`` for distributed operation.  Will be inferred by your
            current scheduler.
        compute: bool, default False
            Whether or not to trigger an immediate computation. Defaults to False.
            Note, that even if you set ``compute=False``, an immediate computation
            will still be triggered if ``divisions`` is ``None``.
        partition_size: int, optional
            Desired size of each partitions in bytes.
            Only used when ``npartitions='auto'``
    
        Examples
        --------
        >>> import dask
        >>> ddf = dask.datasets.timeseries(start="2021-01-01", end="2021-01-07", freq="1h").reset_index()
        >>> ddf2 = ddf.set_index("x")
        >>> ddf2 = ddf.set_index(ddf.x)
        >>> ddf2 = ddf.set_index(ddf.timestamp, sorted=True)
    
        A common case is when we have a datetime column that we know to be
        sorted and is cleanly divided by day.  We can set this index for free
        by specifying both that the column is pre-sorted and the particular
        divisions along which is is separated
    
        >>> import pandas as pd
        >>> divisions = pd.date_range(start="2021-01-01", end="2021-01-07", freq='1D')
        >>> divisions
        DatetimeIndex(['2021-01-01', '2021-01-02', '2021-01-03', '2021-01-04',
                       '2021-01-05', '2021-01-06', '2021-01-07'],
                      dtype='datetime64[ns]', freq='D')
    
        Note that ``len(divisions)`` is equal to ``npartitions + 1``. This is because ``divisions``
        represents the upper and lower bounds of each partition. The first item is the
        lower bound of the first partition, the second item is the lower bound of the
        second partition and the upper bound of the first partition, and so on.
        The second-to-last item is the lower bound of the last partition, and the last
        (extra) item is the upper bound of the last partition.
    
        >>> ddf2 = ddf.set_index("timestamp", sorted=True, divisions=divisions.tolist())
    
        If you'll be running `set_index` on the same (or similar) datasets repeatedly,
        you could save time by letting Dask calculate good divisions once, then copy-pasting
        them to reuse. This is especially helpful running in a Jupyter notebook:
    
        >>> ddf2 = ddf.set_index("name")  # slow, calculates data distribution
        >>> ddf2.divisions  # doctest: +SKIP
        ["Alice", "Laura", "Ursula", "Zelda"]
        >>> # ^ Now copy-paste this and edit the line above to:
        >>> # ddf2 = ddf.set_index("name", divisions=["Alice", "Laura", "Ursula", "Zelda"])
        """
    
        if inplace:
            raise NotImplementedError("The inplace= keyword is not supported")
        pre_sorted = sorted
        del sorted
    
        # Check other can be translated to column name or column object, possibly flattening it
        if not isinstance(other, str):
            # It may refer to several columns
            if isinstance(other, Sequence):  # type: ignore[unreachable]
                # Accept ["a"], but not [["a"]]
                if len(other) == 1 and (  # type: ignore[unreachable]
                    isinstance(other[0], str) or not isinstance(other[0], Sequence)
                ):
                    other = other[0]
                else:
>                   raise NotImplementedError(
                        "Dask dataframe does not yet support multi-indexes.\n"
                        f"You tried to index with this index: {other}\n"
                        "Indexes must be single columns only."
                    )
E                   NotImplementedError: Dask dataframe does not yet support multi-indexes.
E                   You tried to index with this index: ['x', 'y']
E                   Indexes must be single columns only.

/home/swe-bench/miniconda3/envs/pydata__xarray__0.12/lib/python3.10/site-packages/dask/dataframe/core.py:5491: NotImplementedError
______________ TestDataset.test_copy_coords[True-expected_orig0] _______________

self = <xarray.tests.test_dataset.TestDataset object at 0x77b323eef760>
deep = True
expected_orig = <xarray.DataArray 'a' (a: 2)>
array([1, 2])
Coordinates:
  * a        (a) int64 1 2

    @pytest.mark.xfail(raises=AssertionError)
    @pytest.mark.parametrize(
        "deep, expected_orig",
        [
            [
                True,
                xr.DataArray(
                    xr.IndexVariable("a", np.array([1, 2])),
                    coords={"a": [1, 2]},
                    dims=["a"],
                ),
            ],
            [
                False,
                xr.DataArray(
                    xr.IndexVariable("a", np.array([999, 2])),
                    coords={"a": [999, 2]},
                    dims=["a"],
                ),
            ],
        ],
    )
    def test_copy_coords(self, deep, expected_orig):
        """The test fails for the shallow copy, and apparently only on Windows
        for some reason. In windows coords seem to be immutable unless it's one
        dataset deep copied from another."""
        ds = xr.DataArray(
            np.ones([2, 2, 2]),
            coords={"a": [1, 2], "b": ["x", "y"], "c": [0, 1]},
            dims=["a", "b", "c"],
            name="value",
        ).to_dataset()
        ds_cp = ds.copy(deep=deep)
        ds_cp.coords["a"].data[0] = 999
    
        expected_cp = xr.DataArray(
            xr.IndexVariable("a", np.array([999, 2])),
            coords={"a": [999, 2]},
            dims=["a"],
        )
>       assert_identical(ds_cp.coords["a"], expected_cp)

/home/swe-bench/pydata__xarray/xarray/tests/test_dataset.py:2565: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/home/swe-bench/pydata__xarray/xarray/testing.py:335: in _assert_internal_invariants
    _assert_dataarray_invariants(xarray_obj)
/home/swe-bench/pydata__xarray/xarray/testing.py:285: in _assert_dataarray_invariants
    _assert_indexes_invariants_checks(da._indexes, da._coords, da.dims)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

indexes = {'a': Int64Index([1, 2], dtype='int64', name='a')}
possible_coord_variables = {'a': <xarray.IndexVariable 'a' (a: 2)>
array([999,   2])}
dims = ('a',)

    def _assert_indexes_invariants_checks(indexes, possible_coord_variables, dims):
        assert isinstance(indexes, dict), indexes
        assert all(isinstance(v, pd.Index) for v in indexes.values()), {
            k: type(v) for k, v in indexes.items()
        }
    
        index_vars = {
            k for k, v in possible_coord_variables.items() if isinstance(v, IndexVariable)
        }
        assert indexes.keys() <= index_vars, (set(indexes), index_vars)
    
        # Note: when we support non-default indexes, these checks should be opt-in
        # only!
        defaults = default_indexes(possible_coord_variables, dims)
        assert indexes.keys() == defaults.keys(), (set(indexes), set(defaults))
>       assert all(v.equals(defaults[k]) for k, v in indexes.items()), (indexes, defaults)
E       AssertionError: ({'a': Int64Index([1, 2], dtype='int64', name='a')}, {'a': Int64Index([999, 2], dtype='int64', name='a')})

/home/swe-bench/pydata__xarray/xarray/testing.py:249: AssertionError
_____________________ test_datetime[2000-01-01T12:00-0.5] ______________________

x_new = '2000-01-01T12:00', expected = 0.5

    @requires_scipy
    @pytest.mark.parametrize(
        "x_new, expected",
        [
            (pd.date_range("2000-01-02", periods=3), [1, 2, 3]),
            (
                np.array(
                    [np.datetime64("2000-01-01T12:00"), np.datetime64("2000-01-02T12:00")]
                ),
                [0.5, 1.5],
            ),
            (["2000-01-01T12:00", "2000-01-02T12:00"], [0.5, 1.5]),
            (["2000-01-01T12:00", "2000-01-02T12:00", "NaT"], [0.5, 1.5, np.nan]),
            (["2000-01-01T12:00"], 0.5),
            pytest.param("2000-01-01T12:00", 0.5, marks=pytest.mark.xfail),
        ],
    )
    def test_datetime(x_new, expected):
        da = xr.DataArray(
            np.arange(24),
            dims="time",
            coords={"time": pd.date_range("2000-01-01", periods=24)},
        )
    
        actual = da.interp(time=x_new)
        expected_da = xr.DataArray(
            np.atleast_1d(expected),
            dims=["time"],
            coords={"time": (np.atleast_1d(x_new).astype("datetime64[ns]"))},
        )
    
>       assert_allclose(actual, expected_da)
E       AssertionError: Left and right DataArray objects are not close
E       Differing dimensions:
E           () != (time: 1)
E       Differing values:
E       L
E           array(0.5)
E       R
E           array([0.5])
E       Differing coordinates:
E       L   time     datetime64[ns] 2000-01-01T12:00:00
E       R * time     (time) datetime64[ns] 2000-01-01T12:00:00

/home/swe-bench/pydata__xarray/xarray/tests/test_interp.py:601: AssertionError
__________________ TestVariable.test_timedelta64_valid_range ___________________

>   ???

pandas/_libs/tslibs/np_datetime.pyx:368: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???
E   pandas._libs.tslibs.np_datetime.OutOfBoundsDatetime: Out of bounds nanosecond timestamp: 2517-08-01 00:00:00

pandas/_libs/tslibs/np_datetime.pyx:212: OutOfBoundsDatetime

The above exception was the direct cause of the following exception:

self = <xarray.tests.test_variable.TestVariable object at 0x77b324762050>

    @pytest.mark.xfail(reason="pandas issue 36615")
    def test_timedelta64_valid_range(self):
        data = np.timedelta64("200000", "D")
        pderror = pd.errors.OutOfBoundsTimedelta
        with raises_regex(pderror, "Out of bounds nanosecond"):
>           self.cls(["t"], [data])

/home/swe-bench/pydata__xarray/xarray/tests/test_variable.py:308: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/home/swe-bench/pydata__xarray/xarray/core/variable.py:340: in __init__
    self._data = as_compatible_data(data, fastpath=fastpath)
/home/swe-bench/pydata__xarray/xarray/core/variable.py:264: in as_compatible_data
    data = _possibly_convert_objects(data)
/home/swe-bench/pydata__xarray/xarray/core/variable.py:196: in _possibly_convert_objects
    return np.asarray(pd.Series(values.ravel())).reshape(values.shape)
/home/swe-bench/miniconda3/envs/pydata__xarray__0.12/lib/python3.10/site-packages/pandas/core/series.py:470: in __init__
    data = sanitize_array(data, index, dtype, copy)
/home/swe-bench/miniconda3/envs/pydata__xarray__0.12/lib/python3.10/site-packages/pandas/core/construction.py:597: in sanitize_array
    subarr = _try_cast(data, dtype, copy, raise_cast_failure)
/home/swe-bench/miniconda3/envs/pydata__xarray__0.12/lib/python3.10/site-packages/pandas/core/construction.py:775: in _try_cast
    return sanitize_to_nanoseconds(arr, copy=copy)
/home/swe-bench/miniconda3/envs/pydata__xarray__0.12/lib/python3.10/site-packages/pandas/core/dtypes/cast.py:1431: in sanitize_to_nanoseconds
    values = astype_overflowsafe(values, dtype=TD64NS_DTYPE)
pandas/_libs/tslibs/np_datetime.pyx:288: in pandas._libs.tslibs.np_datetime.astype_overflowsafe
    ???
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???
E   pandas._libs.tslibs.np_datetime.OutOfBoundsTimedelta: Cannot convert 200000 days to timedelta64[ns] without overflow

pandas/_libs/tslibs/np_datetime.pyx:377: OutOfBoundsTimedelta

During handling of the above exception, another exception occurred:

self = <xarray.tests.test_variable.TestVariable object at 0x77b324762050>

    @pytest.mark.xfail(reason="pandas issue 36615")
    def test_timedelta64_valid_range(self):
        data = np.timedelta64("200000", "D")
        pderror = pd.errors.OutOfBoundsTimedelta
>       with raises_regex(pderror, "Out of bounds nanosecond"):

/home/swe-bench/pydata__xarray/xarray/tests/test_variable.py:307: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <contextlib._GeneratorContextManager object at 0x77b31d5ef130>
typ = <class 'pandas._libs.tslibs.np_datetime.OutOfBoundsTimedelta'>
value = OutOfBoundsTimedelta('Cannot convert 200000 days to timedelta64[ns] without overflow')
traceback = <traceback object at 0x77b3215bc980>

    def __exit__(self, typ, value, traceback):
        if typ is None:
            try:
                next(self.gen)
            except StopIteration:
                return False
            else:
                raise RuntimeError("generator didn't stop")
        else:
            if value is None:
                # Need to force instantiation so we can reliably
                # tell if we get the same exception back
                value = typ()
            try:
>               self.gen.throw(typ, value, traceback)
E               AssertionError: exception OutOfBoundsTimedelta('Cannot convert 200000 days to timedelta64[ns] without overflow') did not match pattern 'Out of bounds nanosecond'

/home/swe-bench/miniconda3/envs/pydata__xarray__0.12/lib/python3.10/contextlib.py:153: AssertionError
______________ TestVariableWithDask.test_timedelta64_valid_range _______________

>   ???

pandas/_libs/tslibs/np_datetime.pyx:368: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???
E   pandas._libs.tslibs.np_datetime.OutOfBoundsDatetime: Out of bounds nanosecond timestamp: 2517-08-01 00:00:00

pandas/_libs/tslibs/np_datetime.pyx:212: OutOfBoundsDatetime

The above exception was the direct cause of the following exception:

self = <xarray.tests.test_variable.TestVariableWithDask object at 0x77b324943040>

    @pytest.mark.xfail(reason="pandas issue 36615")
    def test_timedelta64_valid_range(self):
        data = np.timedelta64("200000", "D")
        pderror = pd.errors.OutOfBoundsTimedelta
        with raises_regex(pderror, "Out of bounds nanosecond"):
>           self.cls(["t"], [data])

/home/swe-bench/pydata__xarray/xarray/tests/test_variable.py:308: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/home/swe-bench/pydata__xarray/xarray/tests/test_variable.py:1978: in <lambda>
    cls = staticmethod(lambda *args: Variable(*args).chunk())
/home/swe-bench/pydata__xarray/xarray/core/variable.py:340: in __init__
    self._data = as_compatible_data(data, fastpath=fastpath)
/home/swe-bench/pydata__xarray/xarray/core/variable.py:264: in as_compatible_data
    data = _possibly_convert_objects(data)
/home/swe-bench/pydata__xarray/xarray/core/variable.py:196: in _possibly_convert_objects
    return np.asarray(pd.Series(values.ravel())).reshape(values.shape)
/home/swe-bench/miniconda3/envs/pydata__xarray__0.12/lib/python3.10/site-packages/pandas/core/series.py:470: in __init__
    data = sanitize_array(data, index, dtype, copy)
/home/swe-bench/miniconda3/envs/pydata__xarray__0.12/lib/python3.10/site-packages/pandas/core/construction.py:597: in sanitize_array
    subarr = _try_cast(data, dtype, copy, raise_cast_failure)
/home/swe-bench/miniconda3/envs/pydata__xarray__0.12/lib/python3.10/site-packages/pandas/core/construction.py:775: in _try_cast
    return sanitize_to_nanoseconds(arr, copy=copy)
/home/swe-bench/miniconda3/envs/pydata__xarray__0.12/lib/python3.10/site-packages/pandas/core/dtypes/cast.py:1431: in sanitize_to_nanoseconds
    values = astype_overflowsafe(values, dtype=TD64NS_DTYPE)
pandas/_libs/tslibs/np_datetime.pyx:288: in pandas._libs.tslibs.np_datetime.astype_overflowsafe
    ???
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???
E   pandas._libs.tslibs.np_datetime.OutOfBoundsTimedelta: Cannot convert 200000 days to timedelta64[ns] without overflow

pandas/_libs/tslibs/np_datetime.pyx:377: OutOfBoundsTimedelta

During handling of the above exception, another exception occurred:

self = <xarray.tests.test_variable.TestVariableWithDask object at 0x77b324943040>

    @pytest.mark.xfail(reason="pandas issue 36615")
    def test_timedelta64_valid_range(self):
        data = np.timedelta64("200000", "D")
        pderror = pd.errors.OutOfBoundsTimedelta
>       with raises_regex(pderror, "Out of bounds nanosecond"):

/home/swe-bench/pydata__xarray/xarray/tests/test_variable.py:307: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <contextlib._GeneratorContextManager object at 0x77b31f3dbc40>
typ = <class 'pandas._libs.tslibs.np_datetime.OutOfBoundsTimedelta'>
value = OutOfBoundsTimedelta('Cannot convert 200000 days to timedelta64[ns] without overflow')
traceback = <traceback object at 0x77b3214d4a00>

    def __exit__(self, typ, value, traceback):
        if typ is None:
            try:
                next(self.gen)
            except StopIteration:
                return False
            else:
                raise RuntimeError("generator didn't stop")
        else:
            if value is None:
                # Need to force instantiation so we can reliably
                # tell if we get the same exception back
                value = typ()
            try:
>               self.gen.throw(typ, value, traceback)
E               AssertionError: exception OutOfBoundsTimedelta('Cannot convert 200000 days to timedelta64[ns] without overflow') did not match pattern 'Out of bounds nanosecond'

/home/swe-bench/miniconda3/envs/pydata__xarray__0.12/lib/python3.10/contextlib.py:153: AssertionError
____________ TestVariableWithDask.test_pad[xr_arg0-np_arg0-median] _____________

self = <xarray.tests.test_variable.TestVariableWithDask object at 0x77b324940970>
mode = 'median', xr_arg = {'x': (2, 1)}, np_arg = ((2, 1), (0, 0), (0, 0))

    @pytest.mark.parametrize(
        "mode",
        [
            "mean",
            pytest.param(
                "median",
                marks=pytest.mark.xfail(reason="median is not implemented by Dask"),
            ),
            pytest.param(
                "reflect", marks=pytest.mark.xfail(reason="dask.array.pad bug")
            ),
            "edge",
            pytest.param(
                "linear_ramp",
                marks=pytest.mark.xfail(
                    reason="pint bug: https://github.com/hgrecco/pint/issues/1026"
                ),
            ),
            "maximum",
            "minimum",
            "symmetric",
            "wrap",
        ],
    )
    @pytest.mark.parametrize("xr_arg, np_arg", _PAD_XR_NP_ARGS)
    @pytest.mark.filterwarnings(
        r"ignore:dask.array.pad.+? converts integers to floats."
    )
    def test_pad(self, mode, xr_arg, np_arg):
        data = np.arange(4 * 3 * 2).reshape(4, 3, 2)
        v = self.cls(["x", "y", "z"], data)
    
>       actual = v.pad(mode=mode, **xr_arg)

/home/swe-bench/pydata__xarray/xarray/tests/test_variable.py:845: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/home/swe-bench/pydata__xarray/xarray/core/variable.py:1357: in pad
    array = duck_array_ops.pad(
/home/swe-bench/pydata__xarray/xarray/core/duck_array_ops.py:56: in f
    return wrapped(*args, **kwargs)
/home/swe-bench/pydata__xarray/xarray/core/dask_array_compat.py:46: in pad
    padded = da.pad(array, pad_width, mode=mode, **kwargs)
/home/swe-bench/miniconda3/envs/pydata__xarray__0.12/lib/python3.10/site-packages/dask/array/creation.py:1274: in pad
    return pad_stats(array, pad_width, mode, stat_length)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

array = dask.array<array, shape=(4, 3, 2), dtype=int64, chunksize=(4, 3, 2), chunktype=numpy.ndarray>
pad_width = ((2, 1), (0, 0), (0, 0)), mode = 'median'
stat_length = [(4, 4), (3, 3), (2, 2)]

    def pad_stats(array, pad_width, mode, stat_length):
        """
        Helper function for padding boundaries with statistics from the array.
    
        In cases where the padding requires computations of statistics from part
        or all of the array, this function helps compute those statistics as
        requested and then adds those statistics onto the boundaries of the array.
        """
    
        if mode == "median":
>           raise NotImplementedError("`pad` does not support `mode` of `median`.")
E           NotImplementedError: `pad` does not support `mode` of `median`.

/home/swe-bench/miniconda3/envs/pydata__xarray__0.12/lib/python3.10/site-packages/dask/array/creation.py:1140: NotImplementedError
____________ TestVariableWithDask.test_pad[xr_arg1-np_arg1-median] _____________

self = <xarray.tests.test_variable.TestVariableWithDask object at 0x77b32422b040>
mode = 'median', xr_arg = {'x': 1}, np_arg = ((1, 1), (0, 0), (0, 0))

    @pytest.mark.parametrize(
        "mode",
        [
            "mean",
            pytest.param(
                "median",
                marks=pytest.mark.xfail(reason="median is not implemented by Dask"),
            ),
            pytest.param(
                "reflect", marks=pytest.mark.xfail(reason="dask.array.pad bug")
            ),
            "edge",
            pytest.param(
                "linear_ramp",
                marks=pytest.mark.xfail(
                    reason="pint bug: https://github.com/hgrecco/pint/issues/1026"
                ),
            ),
            "maximum",
            "minimum",
            "symmetric",
            "wrap",
        ],
    )
    @pytest.mark.parametrize("xr_arg, np_arg", _PAD_XR_NP_ARGS)
    @pytest.mark.filterwarnings(
        r"ignore:dask.array.pad.+? converts integers to floats."
    )
    def test_pad(self, mode, xr_arg, np_arg):
        data = np.arange(4 * 3 * 2).reshape(4, 3, 2)
        v = self.cls(["x", "y", "z"], data)
    
>       actual = v.pad(mode=mode, **xr_arg)

/home/swe-bench/pydata__xarray/xarray/tests/test_variable.py:845: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/home/swe-bench/pydata__xarray/xarray/core/variable.py:1357: in pad
    array = duck_array_ops.pad(
/home/swe-bench/pydata__xarray/xarray/core/duck_array_ops.py:56: in f
    return wrapped(*args, **kwargs)
/home/swe-bench/pydata__xarray/xarray/core/dask_array_compat.py:46: in pad
    padded = da.pad(array, pad_width, mode=mode, **kwargs)
/home/swe-bench/miniconda3/envs/pydata__xarray__0.12/lib/python3.10/site-packages/dask/array/creation.py:1274: in pad
    return pad_stats(array, pad_width, mode, stat_length)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

array = dask.array<array, shape=(4, 3, 2), dtype=int64, chunksize=(4, 3, 2), chunktype=numpy.ndarray>
pad_width = ((1, 1), (0, 0), (0, 0)), mode = 'median'
stat_length = [(4, 4), (3, 3), (2, 2)]

    def pad_stats(array, pad_width, mode, stat_length):
        """
        Helper function for padding boundaries with statistics from the array.
    
        In cases where the padding requires computations of statistics from part
        or all of the array, this function helps compute those statistics as
        requested and then adds those statistics onto the boundaries of the array.
        """
    
        if mode == "median":
>           raise NotImplementedError("`pad` does not support `mode` of `median`.")
E           NotImplementedError: `pad` does not support `mode` of `median`.

/home/swe-bench/miniconda3/envs/pydata__xarray__0.12/lib/python3.10/site-packages/dask/array/creation.py:1140: NotImplementedError
____________ TestVariableWithDask.test_pad[xr_arg2-np_arg2-median] _____________

self = <xarray.tests.test_variable.TestVariableWithDask object at 0x77b32422b7f0>
mode = 'median', xr_arg = {'y': (0, 3)}, np_arg = ((0, 0), (0, 3), (0, 0))

    @pytest.mark.parametrize(
        "mode",
        [
            "mean",
            pytest.param(
                "median",
                marks=pytest.mark.xfail(reason="median is not implemented by Dask"),
            ),
            pytest.param(
                "reflect", marks=pytest.mark.xfail(reason="dask.array.pad bug")
            ),
            "edge",
            pytest.param(
                "linear_ramp",
                marks=pytest.mark.xfail(
                    reason="pint bug: https://github.com/hgrecco/pint/issues/1026"
                ),
            ),
            "maximum",
            "minimum",
            "symmetric",
            "wrap",
        ],
    )
    @pytest.mark.parametrize("xr_arg, np_arg", _PAD_XR_NP_ARGS)
    @pytest.mark.filterwarnings(
        r"ignore:dask.array.pad.+? converts integers to floats."
    )
    def test_pad(self, mode, xr_arg, np_arg):
        data = np.arange(4 * 3 * 2).reshape(4, 3, 2)
        v = self.cls(["x", "y", "z"], data)
    
>       actual = v.pad(mode=mode, **xr_arg)

/home/swe-bench/pydata__xarray/xarray/tests/test_variable.py:845: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/home/swe-bench/pydata__xarray/xarray/core/variable.py:1357: in pad
    array = duck_array_ops.pad(
/home/swe-bench/pydata__xarray/xarray/core/duck_array_ops.py:56: in f
    return wrapped(*args, **kwargs)
/home/swe-bench/pydata__xarray/xarray/core/dask_array_compat.py:46: in pad
    padded = da.pad(array, pad_width, mode=mode, **kwargs)
/home/swe-bench/miniconda3/envs/pydata__xarray__0.12/lib/python3.10/site-packages/dask/array/creation.py:1274: in pad
    return pad_stats(array, pad_width, mode, stat_length)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

array = dask.array<array, shape=(4, 3, 2), dtype=int64, chunksize=(4, 3, 2), chunktype=numpy.ndarray>
pad_width = ((0, 0), (0, 3), (0, 0)), mode = 'median'
stat_length = [(4, 4), (3, 3), (2, 2)]

    def pad_stats(array, pad_width, mode, stat_length):
        """
        Helper function for padding boundaries with statistics from the array.
    
        In cases where the padding requires computations of statistics from part
        or all of the array, this function helps compute those statistics as
        requested and then adds those statistics onto the boundaries of the array.
        """
    
        if mode == "median":
>           raise NotImplementedError("`pad` does not support `mode` of `median`.")
E           NotImplementedError: `pad` does not support `mode` of `median`.

/home/swe-bench/miniconda3/envs/pydata__xarray__0.12/lib/python3.10/site-packages/dask/array/creation.py:1140: NotImplementedError
____________ TestVariableWithDask.test_pad[xr_arg2-np_arg2-reflect] ____________

self = <xarray.tests.test_variable.TestVariableWithDask object at 0x77b32422bdc0>
mode = 'reflect', xr_arg = {'y': (0, 3)}, np_arg = ((0, 0), (0, 3), (0, 0))

    @pytest.mark.parametrize(
        "mode",
        [
            "mean",
            pytest.param(
                "median",
                marks=pytest.mark.xfail(reason="median is not implemented by Dask"),
            ),
            pytest.param(
                "reflect", marks=pytest.mark.xfail(reason="dask.array.pad bug")
            ),
            "edge",
            pytest.param(
                "linear_ramp",
                marks=pytest.mark.xfail(
                    reason="pint bug: https://github.com/hgrecco/pint/issues/1026"
                ),
            ),
            "maximum",
            "minimum",
            "symmetric",
            "wrap",
        ],
    )
    @pytest.mark.parametrize("xr_arg, np_arg", _PAD_XR_NP_ARGS)
    @pytest.mark.filterwarnings(
        r"ignore:dask.array.pad.+? converts integers to floats."
    )
    def test_pad(self, mode, xr_arg, np_arg):
        data = np.arange(4 * 3 * 2).reshape(4, 3, 2)
        v = self.cls(["x", "y", "z"], data)
    
>       actual = v.pad(mode=mode, **xr_arg)

/home/swe-bench/pydata__xarray/xarray/tests/test_variable.py:845: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/home/swe-bench/pydata__xarray/xarray/core/variable.py:1357: in pad
    array = duck_array_ops.pad(
/home/swe-bench/pydata__xarray/xarray/core/duck_array_ops.py:56: in f
    return wrapped(*args, **kwargs)
/home/swe-bench/pydata__xarray/xarray/core/dask_array_compat.py:57: in pad
    _validate_pad_output_shape(array.shape, pad_width, padded.shape)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

input_shape = (4, 3, 2), pad_width = array([0, 3, 0]), output_shape = (4, 3, 2)

    def _validate_pad_output_shape(input_shape, pad_width, output_shape):
        """Validates the output shape of dask.array.pad, raising a RuntimeError if they do not match.
        In the current versions of dask (2.2/2.4), dask.array.pad with mode='reflect' sometimes returns
        an invalid shape.
        """
        isint = lambda i: isinstance(i, int)
    
        if isint(pad_width):
            pass
        elif len(pad_width) == 2 and all(map(isint, pad_width)):
            pad_width = sum(pad_width)
        elif (
            len(pad_width) == len(input_shape)
            and all(map(lambda x: len(x) == 2, pad_width))
            and all(isint(i) for p in pad_width for i in p)
        ):
            pad_width = np.sum(pad_width, axis=1)
        else:
            # unreachable: dask.array.pad should already have thrown an error
            raise ValueError("Invalid value for `pad_width`")
    
        if not np.array_equal(np.array(input_shape) + pad_width, output_shape):
>           raise RuntimeError(
                "There seems to be something wrong with the shape of the output of dask.array.pad, "
                "try upgrading Dask, use a different pad mode e.g. mode='constant' or first convert "
                "your DataArray/Dataset to one backed by a numpy array by calling the `compute()` method."
                "See: https://github.com/dask/dask/issues/5303"
            )
E           RuntimeError: There seems to be something wrong with the shape of the output of dask.array.pad, try upgrading Dask, use a different pad mode e.g. mode='constant' or first convert your DataArray/Dataset to one backed by a numpy array by calling the `compute()` method.See: https://github.com/dask/dask/issues/5303

/home/swe-bench/pydata__xarray/xarray/core/dask_array_compat.py:37: RuntimeError
____________ TestVariableWithDask.test_pad[xr_arg3-np_arg3-median] _____________

self = <xarray.tests.test_variable.TestVariableWithDask object at 0x77b32422bb50>
mode = 'median', xr_arg = {'x': (3, 1), 'z': (2, 0)}
np_arg = ((3, 1), (0, 0), (2, 0))

    @pytest.mark.parametrize(
        "mode",
        [
            "mean",
            pytest.param(
                "median",
                marks=pytest.mark.xfail(reason="median is not implemented by Dask"),
            ),
            pytest.param(
                "reflect", marks=pytest.mark.xfail(reason="dask.array.pad bug")
            ),
            "edge",
            pytest.param(
                "linear_ramp",
                marks=pytest.mark.xfail(
                    reason="pint bug: https://github.com/hgrecco/pint/issues/1026"
                ),
            ),
            "maximum",
            "minimum",
            "symmetric",
            "wrap",
        ],
    )
    @pytest.mark.parametrize("xr_arg, np_arg", _PAD_XR_NP_ARGS)
    @pytest.mark.filterwarnings(
        r"ignore:dask.array.pad.+? converts integers to floats."
    )
    def test_pad(self, mode, xr_arg, np_arg):
        data = np.arange(4 * 3 * 2).reshape(4, 3, 2)
        v = self.cls(["x", "y", "z"], data)
    
>       actual = v.pad(mode=mode, **xr_arg)

/home/swe-bench/pydata__xarray/xarray/tests/test_variable.py:845: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/home/swe-bench/pydata__xarray/xarray/core/variable.py:1357: in pad
    array = duck_array_ops.pad(
/home/swe-bench/pydata__xarray/xarray/core/duck_array_ops.py:56: in f
    return wrapped(*args, **kwargs)
/home/swe-bench/pydata__xarray/xarray/core/dask_array_compat.py:46: in pad
    padded = da.pad(array, pad_width, mode=mode, **kwargs)
/home/swe-bench/miniconda3/envs/pydata__xarray__0.12/lib/python3.10/site-packages/dask/array/creation.py:1274: in pad
    return pad_stats(array, pad_width, mode, stat_length)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

array = dask.array<array, shape=(4, 3, 2), dtype=int64, chunksize=(4, 3, 2), chunktype=numpy.ndarray>
pad_width = ((3, 1), (0, 0), (2, 0)), mode = 'median'
stat_length = [(4, 4), (3, 3), (2, 2)]

    def pad_stats(array, pad_width, mode, stat_length):
        """
        Helper function for padding boundaries with statistics from the array.
    
        In cases where the padding requires computations of statistics from part
        or all of the array, this function helps compute those statistics as
        requested and then adds those statistics onto the boundaries of the array.
        """
    
        if mode == "median":
>           raise NotImplementedError("`pad` does not support `mode` of `median`.")
E           NotImplementedError: `pad` does not support `mode` of `median`.

/home/swe-bench/miniconda3/envs/pydata__xarray__0.12/lib/python3.10/site-packages/dask/array/creation.py:1140: NotImplementedError
____________ TestVariableWithDask.test_pad[xr_arg3-np_arg3-reflect] ____________

self = <xarray.tests.test_variable.TestVariableWithDask object at 0x77b32422be80>
mode = 'reflect', xr_arg = {'x': (3, 1), 'z': (2, 0)}
np_arg = ((3, 1), (0, 0), (2, 0))

    @pytest.mark.parametrize(
        "mode",
        [
            "mean",
            pytest.param(
                "median",
                marks=pytest.mark.xfail(reason="median is not implemented by Dask"),
            ),
            pytest.param(
                "reflect", marks=pytest.mark.xfail(reason="dask.array.pad bug")
            ),
            "edge",
            pytest.param(
                "linear_ramp",
                marks=pytest.mark.xfail(
                    reason="pint bug: https://github.com/hgrecco/pint/issues/1026"
                ),
            ),
            "maximum",
            "minimum",
            "symmetric",
            "wrap",
        ],
    )
    @pytest.mark.parametrize("xr_arg, np_arg", _PAD_XR_NP_ARGS)
    @pytest.mark.filterwarnings(
        r"ignore:dask.array.pad.+? converts integers to floats."
    )
    def test_pad(self, mode, xr_arg, np_arg):
        data = np.arange(4 * 3 * 2).reshape(4, 3, 2)
        v = self.cls(["x", "y", "z"], data)
    
>       actual = v.pad(mode=mode, **xr_arg)

/home/swe-bench/pydata__xarray/xarray/tests/test_variable.py:845: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/home/swe-bench/pydata__xarray/xarray/core/variable.py:1357: in pad
    array = duck_array_ops.pad(
/home/swe-bench/pydata__xarray/xarray/core/duck_array_ops.py:56: in f
    return wrapped(*args, **kwargs)
/home/swe-bench/pydata__xarray/xarray/core/dask_array_compat.py:57: in pad
    _validate_pad_output_shape(array.shape, pad_width, padded.shape)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

input_shape = (4, 3, 2), pad_width = array([4, 0, 2]), output_shape = (8, 3, 3)

    def _validate_pad_output_shape(input_shape, pad_width, output_shape):
        """Validates the output shape of dask.array.pad, raising a RuntimeError if they do not match.
        In the current versions of dask (2.2/2.4), dask.array.pad with mode='reflect' sometimes returns
        an invalid shape.
        """
        isint = lambda i: isinstance(i, int)
    
        if isint(pad_width):
            pass
        elif len(pad_width) == 2 and all(map(isint, pad_width)):
            pad_width = sum(pad_width)
        elif (
            len(pad_width) == len(input_shape)
            and all(map(lambda x: len(x) == 2, pad_width))
            and all(isint(i) for p in pad_width for i in p)
        ):
            pad_width = np.sum(pad_width, axis=1)
        else:
            # unreachable: dask.array.pad should already have thrown an error
            raise ValueError("Invalid value for `pad_width`")
    
        if not np.array_equal(np.array(input_shape) + pad_width, output_shape):
>           raise RuntimeError(
                "There seems to be something wrong with the shape of the output of dask.array.pad, "
                "try upgrading Dask, use a different pad mode e.g. mode='constant' or first convert "
                "your DataArray/Dataset to one backed by a numpy array by calling the `compute()` method."
                "See: https://github.com/dask/dask/issues/5303"
            )
E           RuntimeError: There seems to be something wrong with the shape of the output of dask.array.pad, try upgrading Dask, use a different pad mode e.g. mode='constant' or first convert your DataArray/Dataset to one backed by a numpy array by calling the `compute()` method.See: https://github.com/dask/dask/issues/5303

/home/swe-bench/pydata__xarray/xarray/core/dask_array_compat.py:37: RuntimeError
____________ TestVariableWithDask.test_pad[xr_arg4-np_arg4-median] _____________

self = <xarray.tests.test_variable.TestVariableWithDask object at 0x77b3242285b0>
mode = 'median', xr_arg = {'x': (3, 1), 'z': 2}
np_arg = ((3, 1), (0, 0), (2, 2))

    @pytest.mark.parametrize(
        "mode",
        [
            "mean",
            pytest.param(
                "median",
                marks=pytest.mark.xfail(reason="median is not implemented by Dask"),
            ),
            pytest.param(
                "reflect", marks=pytest.mark.xfail(reason="dask.array.pad bug")
            ),
            "edge",
            pytest.param(
                "linear_ramp",
                marks=pytest.mark.xfail(
                    reason="pint bug: https://github.com/hgrecco/pint/issues/1026"
                ),
            ),
            "maximum",
            "minimum",
            "symmetric",
            "wrap",
        ],
    )
    @pytest.mark.parametrize("xr_arg, np_arg", _PAD_XR_NP_ARGS)
    @pytest.mark.filterwarnings(
        r"ignore:dask.array.pad.+? converts integers to floats."
    )
    def test_pad(self, mode, xr_arg, np_arg):
        data = np.arange(4 * 3 * 2).reshape(4, 3, 2)
        v = self.cls(["x", "y", "z"], data)
    
>       actual = v.pad(mode=mode, **xr_arg)

/home/swe-bench/pydata__xarray/xarray/tests/test_variable.py:845: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/home/swe-bench/pydata__xarray/xarray/core/variable.py:1357: in pad
    array = duck_array_ops.pad(
/home/swe-bench/pydata__xarray/xarray/core/duck_array_ops.py:56: in f
    return wrapped(*args, **kwargs)
/home/swe-bench/pydata__xarray/xarray/core/dask_array_compat.py:46: in pad
    padded = da.pad(array, pad_width, mode=mode, **kwargs)
/home/swe-bench/miniconda3/envs/pydata__xarray__0.12/lib/python3.10/site-packages/dask/array/creation.py:1274: in pad
    return pad_stats(array, pad_width, mode, stat_length)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

array = dask.array<array, shape=(4, 3, 2), dtype=int64, chunksize=(4, 3, 2), chunktype=numpy.ndarray>
pad_width = ((3, 1), (0, 0), (2, 2)), mode = 'median'
stat_length = [(4, 4), (3, 3), (2, 2)]

    def pad_stats(array, pad_width, mode, stat_length):
        """
        Helper function for padding boundaries with statistics from the array.
    
        In cases where the padding requires computations of statistics from part
        or all of the array, this function helps compute those statistics as
        requested and then adds those statistics onto the boundaries of the array.
        """
    
        if mode == "median":
>           raise NotImplementedError("`pad` does not support `mode` of `median`.")
E           NotImplementedError: `pad` does not support `mode` of `median`.

/home/swe-bench/miniconda3/envs/pydata__xarray__0.12/lib/python3.10/site-packages/dask/array/creation.py:1140: NotImplementedError
____________ TestVariableWithDask.test_pad[xr_arg4-np_arg4-reflect] ____________

self = <xarray.tests.test_variable.TestVariableWithDask object at 0x77b324228640>
mode = 'reflect', xr_arg = {'x': (3, 1), 'z': 2}
np_arg = ((3, 1), (0, 0), (2, 2))

    @pytest.mark.parametrize(
        "mode",
        [
            "mean",
            pytest.param(
                "median",
                marks=pytest.mark.xfail(reason="median is not implemented by Dask"),
            ),
            pytest.param(
                "reflect", marks=pytest.mark.xfail(reason="dask.array.pad bug")
            ),
            "edge",
            pytest.param(
                "linear_ramp",
                marks=pytest.mark.xfail(
                    reason="pint bug: https://github.com/hgrecco/pint/issues/1026"
                ),
            ),
            "maximum",
            "minimum",
            "symmetric",
            "wrap",
        ],
    )
    @pytest.mark.parametrize("xr_arg, np_arg", _PAD_XR_NP_ARGS)
    @pytest.mark.filterwarnings(
        r"ignore:dask.array.pad.+? converts integers to floats."
    )
    def test_pad(self, mode, xr_arg, np_arg):
        data = np.arange(4 * 3 * 2).reshape(4, 3, 2)
        v = self.cls(["x", "y", "z"], data)
    
>       actual = v.pad(mode=mode, **xr_arg)

/home/swe-bench/pydata__xarray/xarray/tests/test_variable.py:845: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/home/swe-bench/pydata__xarray/xarray/core/variable.py:1357: in pad
    array = duck_array_ops.pad(
/home/swe-bench/pydata__xarray/xarray/core/duck_array_ops.py:56: in f
    return wrapped(*args, **kwargs)
/home/swe-bench/pydata__xarray/xarray/core/dask_array_compat.py:57: in pad
    _validate_pad_output_shape(array.shape, pad_width, padded.shape)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

input_shape = (4, 3, 2), pad_width = array([4, 0, 4]), output_shape = (8, 3, 3)

    def _validate_pad_output_shape(input_shape, pad_width, output_shape):
        """Validates the output shape of dask.array.pad, raising a RuntimeError if they do not match.
        In the current versions of dask (2.2/2.4), dask.array.pad with mode='reflect' sometimes returns
        an invalid shape.
        """
        isint = lambda i: isinstance(i, int)
    
        if isint(pad_width):
            pass
        elif len(pad_width) == 2 and all(map(isint, pad_width)):
            pad_width = sum(pad_width)
        elif (
            len(pad_width) == len(input_shape)
            and all(map(lambda x: len(x) == 2, pad_width))
            and all(isint(i) for p in pad_width for i in p)
        ):
            pad_width = np.sum(pad_width, axis=1)
        else:
            # unreachable: dask.array.pad should already have thrown an error
            raise ValueError("Invalid value for `pad_width`")
    
        if not np.array_equal(np.array(input_shape) + pad_width, output_shape):
>           raise RuntimeError(
                "There seems to be something wrong with the shape of the output of dask.array.pad, "
                "try upgrading Dask, use a different pad mode e.g. mode='constant' or first convert "
                "your DataArray/Dataset to one backed by a numpy array by calling the `compute()` method."
                "See: https://github.com/dask/dask/issues/5303"
            )
E           RuntimeError: There seems to be something wrong with the shape of the output of dask.array.pad, try upgrading Dask, use a different pad mode e.g. mode='constant' or first convert your DataArray/Dataset to one backed by a numpy array by calling the `compute()` method.See: https://github.com/dask/dask/issues/5303

/home/swe-bench/pydata__xarray/xarray/core/dask_array_compat.py:37: RuntimeError
_____________ TestVariableWithDask.test_0d_object_array_with_list ______________

self = <xarray.tests.test_variable.TestVariableWithDask object at 0x77b324800310>

    @pytest.mark.xfail
    def test_0d_object_array_with_list(self):
>       super().test_0d_object_array_with_list()

/home/swe-bench/pydata__xarray/xarray/tests/test_variable.py:1982: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/home/swe-bench/pydata__xarray/xarray/tests/test_variable.py:239: in test_0d_object_array_with_list
    assert_array_equal(x[0].data, listarray.squeeze())
/home/swe-bench/miniconda3/envs/pydata__xarray__0.12/lib/python3.10/contextlib.py:79: in inner
    return func(*args, **kwds)
/home/swe-bench/miniconda3/envs/pydata__xarray__0.12/lib/python3.10/site-packages/dask/array/core.py:1700: in __array__
    x = self.compute()
/home/swe-bench/miniconda3/envs/pydata__xarray__0.12/lib/python3.10/site-packages/dask/base.py:375: in compute
    (result,) = compute(self, traverse=False, **kwargs)
/home/swe-bench/miniconda3/envs/pydata__xarray__0.12/lib/python3.10/site-packages/dask/base.py:663: in compute
    return repack([f(r, *a) for r, (f, a) in zip(results, postcomputes)])
/home/swe-bench/miniconda3/envs/pydata__xarray__0.12/lib/python3.10/site-packages/dask/base.py:663: in <listcomp>
    return repack([f(r, *a) for r, (f, a) in zip(results, postcomputes)])
/home/swe-bench/miniconda3/envs/pydata__xarray__0.12/lib/python3.10/site-packages/dask/array/core.py:1282: in finalize
    return concatenate3(results)
/home/swe-bench/miniconda3/envs/pydata__xarray__0.12/lib/python3.10/site-packages/dask/array/core.py:5307: in concatenate3
    chunks = chunks_from_arrays(arrays)
/home/swe-bench/miniconda3/envs/pydata__xarray__0.12/lib/python3.10/site-packages/dask/array/core.py:5094: in chunks_from_arrays
    result.append(tuple(shape(deepfirst(a))[dim] for a in arrays))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

.0 = <list_iterator object at 0x77b31c163ac0>

>   result.append(tuple(shape(deepfirst(a))[dim] for a in arrays))
E   IndexError: tuple index out of range

/home/swe-bench/miniconda3/envs/pydata__xarray__0.12/lib/python3.10/site-packages/dask/array/core.py:5094: IndexError
__________________ TestVariableWithDask.test_array_interface ___________________

arg = dask.array<array, shape=(5,), dtype=int64, chunksize=(5,), chunktype=numpy.ndarray>
name = 'argsort', args = (), kwargs = {}

    def _call_possibly_missing_method(arg, name, args, kwargs):
        try:
>           method = getattr(arg, name)
E           AttributeError: 'Array' object has no attribute 'argsort'

/home/swe-bench/pydata__xarray/xarray/core/ops.py:206: AttributeError

During handling of the above exception, another exception occurred:

self = <xarray.tests.test_variable.TestVariableWithDask object at 0x77b3248017b0>

    @pytest.mark.xfail
    def test_array_interface(self):
        # dask array does not have `argsort`
>       super().test_array_interface()

/home/swe-bench/pydata__xarray/xarray/tests/test_variable.py:1987: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/home/swe-bench/pydata__xarray/xarray/tests/test_variable.py:381: in test_array_interface
    assert_identical(v.argsort(), v.to_base_variable())
/home/swe-bench/pydata__xarray/xarray/core/variable.py:2285: in func
    result = self.__array_wrap__(f(self.data, *args, **kwargs))
/home/swe-bench/pydata__xarray/xarray/core/ops.py:227: in func
    return _call_possibly_missing_method(self, name, args, kwargs)
/home/swe-bench/pydata__xarray/xarray/core/ops.py:208: in _call_possibly_missing_method
    duck_array_ops.fail_on_dask_array_input(arg, func_name=name)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

values = dask.array<array, shape=(5,), dtype=int64, chunksize=(5,), chunktype=numpy.ndarray>
msg = '%r is not yet a valid method on dask arrays', func_name = 'argsort'

    def fail_on_dask_array_input(values, msg=None, func_name=None):
        if is_duck_dask_array(values):
            if msg is None:
                msg = "%r is not yet a valid method on dask arrays"
            if func_name is None:
                func_name = inspect.stack()[1][3]
>           raise NotImplementedError(msg % func_name)
E           NotImplementedError: 'argsort' is not yet a valid method on dask arrays

/home/swe-bench/pydata__xarray/xarray/core/duck_array_ops.py:72: NotImplementedError
_____________________ TestVariableWithDask.test_copy_index _____________________

self = <xarray.tests.test_variable.TestVariableWithDask object at 0x77b324800d00>

    @pytest.mark.xfail
    def test_copy_index(self):
>       super().test_copy_index()

/home/swe-bench/pydata__xarray/xarray/tests/test_variable.py:1991: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <xarray.tests.test_variable.TestVariableWithDask object at 0x77b324800d00>

    def test_copy_index(self):
        midx = pd.MultiIndex.from_product(
            [["a", "b"], [1, 2], [-1, -2]], names=("one", "two", "three")
        )
        v = self.cls("x", midx)
        for deep in [True, False]:
            w = v.copy(deep=deep)
>           assert isinstance(w._data, PandasIndexAdapter)
E           assert False
E            +  where False = isinstance(dask.array<array, shape=(8,), dtype=object, chunksize=(8,), chunktype=numpy.ndarray>, PandasIndexAdapter)
E            +    where dask.array<array, shape=(8,), dtype=object, chunksize=(8,), chunktype=numpy.ndarray> = <xarray.Variable (x: 8)>\ndask.array<array, shape=(8,), dtype=object, chunksize=(8,), chunktype=numpy.ndarray>._data

/home/swe-bench/pydata__xarray/xarray/tests/test_variable.py:533: AssertionError
________________ TestIndexVariable.test_timedelta64_valid_range ________________

>   ???

pandas/_libs/tslibs/np_datetime.pyx:368: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???
E   pandas._libs.tslibs.np_datetime.OutOfBoundsDatetime: Out of bounds nanosecond timestamp: 2517-08-01 00:00:00

pandas/_libs/tslibs/np_datetime.pyx:212: OutOfBoundsDatetime

The above exception was the direct cause of the following exception:

self = <xarray.tests.test_variable.TestIndexVariable object at 0x77b3243a6020>

    @pytest.mark.xfail(reason="pandas issue 36615")
    def test_timedelta64_valid_range(self):
        data = np.timedelta64("200000", "D")
        pderror = pd.errors.OutOfBoundsTimedelta
        with raises_regex(pderror, "Out of bounds nanosecond"):
>           self.cls(["t"], [data])

/home/swe-bench/pydata__xarray/xarray/tests/test_variable.py:308: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/home/swe-bench/pydata__xarray/xarray/core/variable.py:2514: in __init__
    super().__init__(dims, data, attrs, encoding, fastpath)
/home/swe-bench/pydata__xarray/xarray/core/variable.py:340: in __init__
    self._data = as_compatible_data(data, fastpath=fastpath)
/home/swe-bench/pydata__xarray/xarray/core/variable.py:264: in as_compatible_data
    data = _possibly_convert_objects(data)
/home/swe-bench/pydata__xarray/xarray/core/variable.py:196: in _possibly_convert_objects
    return np.asarray(pd.Series(values.ravel())).reshape(values.shape)
/home/swe-bench/miniconda3/envs/pydata__xarray__0.12/lib/python3.10/site-packages/pandas/core/series.py:470: in __init__
    data = sanitize_array(data, index, dtype, copy)
/home/swe-bench/miniconda3/envs/pydata__xarray__0.12/lib/python3.10/site-packages/pandas/core/construction.py:597: in sanitize_array
    subarr = _try_cast(data, dtype, copy, raise_cast_failure)
/home/swe-bench/miniconda3/envs/pydata__xarray__0.12/lib/python3.10/site-packages/pandas/core/construction.py:775: in _try_cast
    return sanitize_to_nanoseconds(arr, copy=copy)
/home/swe-bench/miniconda3/envs/pydata__xarray__0.12/lib/python3.10/site-packages/pandas/core/dtypes/cast.py:1431: in sanitize_to_nanoseconds
    values = astype_overflowsafe(values, dtype=TD64NS_DTYPE)
pandas/_libs/tslibs/np_datetime.pyx:288: in pandas._libs.tslibs.np_datetime.astype_overflowsafe
    ???
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???
E   pandas._libs.tslibs.np_datetime.OutOfBoundsTimedelta: Cannot convert 200000 days to timedelta64[ns] without overflow

pandas/_libs/tslibs/np_datetime.pyx:377: OutOfBoundsTimedelta

During handling of the above exception, another exception occurred:

self = <xarray.tests.test_variable.TestIndexVariable object at 0x77b3243a6020>

    @pytest.mark.xfail(reason="pandas issue 36615")
    def test_timedelta64_valid_range(self):
        data = np.timedelta64("200000", "D")
        pderror = pd.errors.OutOfBoundsTimedelta
>       with raises_regex(pderror, "Out of bounds nanosecond"):

/home/swe-bench/pydata__xarray/xarray/tests/test_variable.py:307: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <contextlib._GeneratorContextManager object at 0x77b321e7bd60>
typ = <class 'pandas._libs.tslibs.np_datetime.OutOfBoundsTimedelta'>
value = OutOfBoundsTimedelta('Cannot convert 200000 days to timedelta64[ns] without overflow')
traceback = <traceback object at 0x77b31e991340>

    def __exit__(self, typ, value, traceback):
        if typ is None:
            try:
                next(self.gen)
            except StopIteration:
                return False
            else:
                raise RuntimeError("generator didn't stop")
        else:
            if value is None:
                # Need to force instantiation so we can reliably
                # tell if we get the same exception back
                value = typ()
            try:
>               self.gen.throw(typ, value, traceback)
E               AssertionError: exception OutOfBoundsTimedelta('Cannot convert 200000 days to timedelta64[ns] without overflow') did not match pattern 'Out of bounds nanosecond'

/home/swe-bench/miniconda3/envs/pydata__xarray__0.12/lib/python3.10/contextlib.py:153: AssertionError
_____________________ TestIndexVariable.test_getitem_error _____________________

self = <xarray.tests.test_variable.TestIndexVariable object at 0x77b324606b30>

    @pytest.mark.xfail
    def test_getitem_error(self):
>       super().test_getitem_error()

/home/swe-bench/pydata__xarray/xarray/tests/test_variable.py:2126: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/home/swe-bench/pydata__xarray/xarray/tests/test_variable.py:794: in test_getitem_error
    v = self.cls(["x", "y"], [[0, 1, 2], [3, 4, 5]])
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <xarray.IndexVariable 'x' (x: 2, y: 3)>
array([[0, 1, 2],
       [3, 4, 5]])
dims = ['x', 'y'], data = [[0, 1, 2], [3, 4, 5]], attrs = None, encoding = None
fastpath = False

    def __init__(self, dims, data, attrs=None, encoding=None, fastpath=False):
        super().__init__(dims, data, attrs, encoding, fastpath)
        if self.ndim != 1:
>           raise ValueError("%s objects must be 1-dimensional" % type(self).__name__)
E           ValueError: IndexVariable objects must be 1-dimensional

/home/swe-bench/pydata__xarray/xarray/core/variable.py:2516: ValueError
___________________ TestIndexVariable.test_getitem_advanced ____________________

self = <xarray.tests.test_variable.TestIndexVariable object at 0x77b324606da0>

    @pytest.mark.xfail
    def test_getitem_advanced(self):
>       super().test_getitem_advanced()

/home/swe-bench/pydata__xarray/xarray/tests/test_variable.py:2130: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/home/swe-bench/pydata__xarray/xarray/tests/test_variable.py:630: in test_getitem_advanced
    v = self.cls(["x", "y"], [[0, 1, 2], [3, 4, 5]])
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <xarray.IndexVariable 'x' (x: 2, y: 3)>
array([[0, 1, 2],
       [3, 4, 5]])
dims = ['x', 'y'], data = [[0, 1, 2], [3, 4, 5]], attrs = None, encoding = None
fastpath = False

    def __init__(self, dims, data, attrs=None, encoding=None, fastpath=False):
        super().__init__(dims, data, attrs, encoding, fastpath)
        if self.ndim != 1:
>           raise ValueError("%s objects must be 1-dimensional" % type(self).__name__)
E           ValueError: IndexVariable objects must be 1-dimensional

/home/swe-bench/pydata__xarray/xarray/core/variable.py:2516: ValueError
_____________________ TestIndexVariable.test_getitem_fancy _____________________

self = <xarray.tests.test_variable.TestIndexVariable object at 0x77b324607010>

    @pytest.mark.xfail
    def test_getitem_fancy(self):
>       super().test_getitem_fancy()

/home/swe-bench/pydata__xarray/xarray/tests/test_variable.py:2134: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/home/swe-bench/pydata__xarray/xarray/tests/test_variable.py:707: in test_getitem_fancy
    v = self.cls(["x", "y"], [[0, 1, 2], [3, 4, 5]])
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <xarray.IndexVariable 'x' (x: 2, y: 3)>
array([[0, 1, 2],
       [3, 4, 5]])
dims = ['x', 'y'], data = [[0, 1, 2], [3, 4, 5]], attrs = None, encoding = None
fastpath = False

    def __init__(self, dims, data, attrs=None, encoding=None, fastpath=False):
        super().__init__(dims, data, attrs, encoding, fastpath)
        if self.ndim != 1:
>           raise ValueError("%s objects must be 1-dimensional" % type(self).__name__)
E           ValueError: IndexVariable objects must be 1-dimensional

/home/swe-bench/pydata__xarray/xarray/core/variable.py:2516: ValueError
_____________________ TestIndexVariable.test_getitem_uint ______________________

self = <xarray.tests.test_variable.TestIndexVariable object at 0x77b324607280>

    @pytest.mark.xfail
    def test_getitem_uint(self):
>       super().test_getitem_fancy()

/home/swe-bench/pydata__xarray/xarray/tests/test_variable.py:2138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/home/swe-bench/pydata__xarray/xarray/tests/test_variable.py:707: in test_getitem_fancy
    v = self.cls(["x", "y"], [[0, 1, 2], [3, 4, 5]])
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <xarray.IndexVariable 'x' (x: 2, y: 3)>
array([[0, 1, 2],
       [3, 4, 5]])
dims = ['x', 'y'], data = [[0, 1, 2], [3, 4, 5]], attrs = None, encoding = None
fastpath = False

    def __init__(self, dims, data, attrs=None, encoding=None, fastpath=False):
        super().__init__(dims, data, attrs, encoding, fastpath)
        if self.ndim != 1:
>           raise ValueError("%s objects must be 1-dimensional" % type(self).__name__)
E           ValueError: IndexVariable objects must be 1-dimensional

/home/swe-bench/pydata__xarray/xarray/core/variable.py:2516: ValueError
_______________ TestIndexVariable.test_pad[xr_arg0-np_arg0-mean] _______________

self = <xarray.tests.test_variable.TestIndexVariable object at 0x77b324607820>
mode = 'mean', xr_arg = {'x': (2, 1)}, np_arg = ((2, 1), (0, 0), (0, 0))

    @pytest.mark.xfail
    @pytest.mark.parametrize(
        "mode",
        [
            "mean",
            "median",
            "reflect",
            "edge",
            "linear_ramp",
            "maximum",
            "minimum",
            "symmetric",
            "wrap",
        ],
    )
    @pytest.mark.parametrize("xr_arg, np_arg", _PAD_XR_NP_ARGS)
    def test_pad(self, mode, xr_arg, np_arg):
>       super().test_pad(mode, xr_arg, np_arg)

/home/swe-bench/pydata__xarray/xarray/tests/test_variable.py:2157: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/home/swe-bench/pydata__xarray/xarray/tests/test_variable.py:843: in test_pad
    v = self.cls(["x", "y", "z"], data)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <xarray.IndexVariable 'x' (x: 4, y: 3, z: 2)>
array([[[ 0,  1],
        [ 2,  3],
        [ 4,  5]],

       [[ 6,  7]... 11]],

       [[12, 13],
        [14, 15],
        [16, 17]],

       [[18, 19],
        [20, 21],
        [22, 23]]])
dims = ['x', 'y', 'z']
data = array([[[ 0,  1],
        [ 2,  3],
        [ 4,  5]],

       [[ 6,  7],
        [ 8,  9],
        [10, 11]],

       [[12, 13],
        [14, 15],
        [16, 17]],

       [[18, 19],
        [20, 21],
        [22, 23]]])
attrs = None, encoding = None, fastpath = False

    def __init__(self, dims, data, attrs=None, encoding=None, fastpath=False):
        super().__init__(dims, data, attrs, encoding, fastpath)
        if self.ndim != 1:
>           raise ValueError("%s objects must be 1-dimensional" % type(self).__name__)
E           ValueError: IndexVariable objects must be 1-dimensional

/home/swe-bench/pydata__xarray/xarray/core/variable.py:2516: ValueError
______________ TestIndexVariable.test_pad[xr_arg0-np_arg0-median] ______________

self = <xarray.tests.test_variable.TestIndexVariable object at 0x77b324607700>
mode = 'median', xr_arg = {'x': (2, 1)}, np_arg = ((2, 1), (0, 0), (0, 0))

    @pytest.mark.xfail
    @pytest.mark.parametrize(
        "mode",
        [
            "mean",
            "median",
            "reflect",
            "edge",
            "linear_ramp",
            "maximum",
            "minimum",
            "symmetric",
            "wrap",
        ],
    )
    @pytest.mark.parametrize("xr_arg, np_arg", _PAD_XR_NP_ARGS)
    def test_pad(self, mode, xr_arg, np_arg):
>       super().test_pad(mode, xr_arg, np_arg)

/home/swe-bench/pydata__xarray/xarray/tests/test_variable.py:2157: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/home/swe-bench/pydata__xarray/xarray/tests/test_variable.py:843: in test_pad
    v = self.cls(["x", "y", "z"], data)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <xarray.IndexVariable 'x' (x: 4, y: 3, z: 2)>
array([[[ 0,  1],
        [ 2,  3],
        [ 4,  5]],

       [[ 6,  7]... 11]],

       [[12, 13],
        [14, 15],
        [16, 17]],

       [[18, 19],
        [20, 21],
        [22, 23]]])
dims = ['x', 'y', 'z']
data = array([[[ 0,  1],
        [ 2,  3],
        [ 4,  5]],

       [[ 6,  7],
        [ 8,  9],
        [10, 11]],

       [[12, 13],
        [14, 15],
        [16, 17]],

       [[18, 19],
        [20, 21],
        [22, 23]]])
attrs = None, encoding = None, fastpath = False

    def __init__(self, dims, data, attrs=None, encoding=None, fastpath=False):
        super().__init__(dims, data, attrs, encoding, fastpath)
        if self.ndim != 1:
>           raise ValueError("%s objects must be 1-dimensional" % type(self).__name__)
E           ValueError: IndexVariable objects must be 1-dimensional

/home/swe-bench/pydata__xarray/xarray/core/variable.py:2516: ValueError
_____________ TestIndexVariable.test_pad[xr_arg0-np_arg0-reflect] ______________

self = <xarray.tests.test_variable.TestIndexVariable object at 0x77b3246077c0>
mode = 'reflect', xr_arg = {'x': (2, 1)}, np_arg = ((2, 1), (0, 0), (0, 0))

    @pytest.mark.xfail
    @pytest.mark.parametrize(
        "mode",
        [
            "mean",
            "median",
            "reflect",
            "edge",
            "linear_ramp",
            "maximum",
            "minimum",
            "symmetric",
            "wrap",
        ],
    )
    @pytest.mark.parametrize("xr_arg, np_arg", _PAD_XR_NP_ARGS)
    def test_pad(self, mode, xr_arg, np_arg):
>       super().test_pad(mode, xr_arg, np_arg)

/home/swe-bench/pydata__xarray/xarray/tests/test_variable.py:2157: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/home/swe-bench/pydata__xarray/xarray/tests/test_variable.py:843: in test_pad
    v = self.cls(["x", "y", "z"], data)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <xarray.IndexVariable 'x' (x: 4, y: 3, z: 2)>
array([[[ 0,  1],
        [ 2,  3],
        [ 4,  5]],

       [[ 6,  7]... 11]],

       [[12, 13],
        [14, 15],
        [16, 17]],

       [[18, 19],
        [20, 21],
        [22, 23]]])
dims = ['x', 'y', 'z']
data = array([[[ 0,  1],
        [ 2,  3],
        [ 4,  5]],

       [[ 6,  7],
        [ 8,  9],
        [10, 11]],

       [[12, 13],
        [14, 15],
        [16, 17]],

       [[18, 19],
        [20, 21],
        [22, 23]]])
attrs = None, encoding = None, fastpath = False

    def __init__(self, dims, data, attrs=None, encoding=None, fastpath=False):
        super().__init__(dims, data, attrs, encoding, fastpath)
        if self.ndim != 1:
>           raise ValueError("%s objects must be 1-dimensional" % type(self).__name__)
E           ValueError: IndexVariable objects must be 1-dimensional

/home/swe-bench/pydata__xarray/xarray/core/variable.py:2516: ValueError
_______________ TestIndexVariable.test_pad[xr_arg0-np_arg0-edge] _______________

self = <xarray.tests.test_variable.TestIndexVariable object at 0x77b324607550>
mode = 'edge', xr_arg = {'x': (2, 1)}, np_arg = ((2, 1), (0, 0), (0, 0))

    @pytest.mark.xfail
    @pytest.mark.parametrize(
        "mode",
        [
            "mean",
            "median",
            "reflect",
            "edge",
            "linear_ramp",
            "maximum",
            "minimum",
            "symmetric",
            "wrap",
        ],
    )
    @pytest.mark.parametrize("xr_arg, np_arg", _PAD_XR_NP_ARGS)
    def test_pad(self, mode, xr_arg, np_arg):
>       super().test_pad(mode, xr_arg, np_arg)

/home/swe-bench/pydata__xarray/xarray/tests/test_variable.py:2157: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/home/swe-bench/pydata__xarray/xarray/tests/test_variable.py:843: in test_pad
    v = self.cls(["x", "y", "z"], data)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <xarray.IndexVariable 'x' (x: 4, y: 3, z: 2)>
array([[[ 0,  1],
        [ 2,  3],
        [ 4,  5]],

       [[ 6,  7]... 11]],

       [[12, 13],
        [14, 15],
        [16, 17]],

       [[18, 19],
        [20, 21],
        [22, 23]]])
dims = ['x', 'y', 'z']
data = array([[[ 0,  1],
        [ 2,  3],
        [ 4,  5]],

       [[ 6,  7],
        [ 8,  9],
        [10, 11]],

       [[12, 13],
        [14, 15],
        [16, 17]],

       [[18, 19],
        [20, 21],
        [22, 23]]])
attrs = None, encoding = None, fastpath = False

    def __init__(self, dims, data, attrs=None, encoding=None, fastpath=False):
        super().__init__(dims, data, attrs, encoding, fastpath)
        if self.ndim != 1:
>           raise ValueError("%s objects must be 1-dimensional" % type(self).__name__)
E           ValueError: IndexVariable objects must be 1-dimensional

/home/swe-bench/pydata__xarray/xarray/core/variable.py:2516: ValueError
___________ TestIndexVariable.test_pad[xr_arg0-np_arg0-linear_ramp] ____________

self = <xarray.tests.test_variable.TestIndexVariable object at 0x77b324440400>
mode = 'linear_ramp', xr_arg = {'x': (2, 1)}, np_arg = ((2, 1), (0, 0), (0, 0))

    @pytest.mark.xfail
    @pytest.mark.parametrize(
        "mode",
        [
            "mean",
            "median",
            "reflect",
            "edge",
            "linear_ramp",
            "maximum",
            "minimum",
            "symmetric",
            "wrap",
        ],
    )
    @pytest.mark.parametrize("xr_arg, np_arg", _PAD_XR_NP_ARGS)
    def test_pad(self, mode, xr_arg, np_arg):
>       super().test_pad(mode, xr_arg, np_arg)

/home/swe-bench/pydata__xarray/xarray/tests/test_variable.py:2157: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/home/swe-bench/pydata__xarray/xarray/tests/test_variable.py:843: in test_pad
    v = self.cls(["x", "y", "z"], data)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <xarray.IndexVariable 'x' (x: 4, y: 3, z: 2)>
array([[[ 0,  1],
        [ 2,  3],
        [ 4,  5]],

       [[ 6,  7]... 11]],

       [[12, 13],
        [14, 15],
        [16, 17]],

       [[18, 19],
        [20, 21],
        [22, 23]]])
dims = ['x', 'y', 'z']
data = array([[[ 0,  1],
        [ 2,  3],
        [ 4,  5]],

       [[ 6,  7],
        [ 8,  9],
        [10, 11]],

       [[12, 13],
        [14, 15],
        [16, 17]],

       [[18, 19],
        [20, 21],
        [22, 23]]])
attrs = None, encoding = None, fastpath = False

    def __init__(self, dims, data, attrs=None, encoding=None, fastpath=False):
        super().__init__(dims, data, attrs, encoding, fastpath)
        if self.ndim != 1:
>           raise ValueError("%s objects must be 1-dimensional" % type(self).__name__)
E           ValueError: IndexVariable objects must be 1-dimensional

/home/swe-bench/pydata__xarray/xarray/core/variable.py:2516: ValueError
_____________ TestIndexVariable.test_pad[xr_arg0-np_arg0-maximum] ______________

self = <xarray.tests.test_variable.TestIndexVariable object at 0x77b3244404c0>
mode = 'maximum', xr_arg = {'x': (2, 1)}, np_arg = ((2, 1), (0, 0), (0, 0))

    @pytest.mark.xfail
    @pytest.mark.parametrize(
        "mode",
        [
            "mean",
            "median",
            "reflect",
            "edge",
            "linear_ramp",
            "maximum",
            "minimum",
            "symmetric",
            "wrap",
        ],
    )
    @pytest.mark.parametrize("xr_arg, np_arg", _PAD_XR_NP_ARGS)
    def test_pad(self, mode, xr_arg, np_arg):
>       super().test_pad(mode, xr_arg, np_arg)

/home/swe-bench/pydata__xarray/xarray/tests/test_variable.py:2157: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/home/swe-bench/pydata__xarray/xarray/tests/test_variable.py:843: in test_pad
    v = self.cls(["x", "y", "z"], data)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <xarray.IndexVariable 'x' (x: 4, y: 3, z: 2)>
array([[[ 0,  1],
        [ 2,  3],
        [ 4,  5]],

       [[ 6,  7]... 11]],

       [[12, 13],
        [14, 15],
        [16, 17]],

       [[18, 19],
        [20, 21],
        [22, 23]]])
dims = ['x', 'y', 'z']
data = array([[[ 0,  1],
        [ 2,  3],
        [ 4,  5]],

       [[ 6,  7],
        [ 8,  9],
        [10, 11]],

       [[12, 13],
        [14, 15],
        [16, 17]],

       [[18, 19],
        [20, 21],
        [22, 23]]])
attrs = None, encoding = None, fastpath = False

    def __init__(self, dims, data, attrs=None, encoding=None, fastpath=False):
        super().__init__(dims, data, attrs, encoding, fastpath)
        if self.ndim != 1:
>           raise ValueError("%s objects must be 1-dimensional" % type(self).__name__)
E           ValueError: IndexVariable objects must be 1-dimensional

/home/swe-bench/pydata__xarray/xarray/core/variable.py:2516: ValueError
_____________ TestIndexVariable.test_pad[xr_arg0-np_arg0-minimum] ______________

self = <xarray.tests.test_variable.TestIndexVariable object at 0x77b324440580>
mode = 'minimum', xr_arg = {'x': (2, 1)}, np_arg = ((2, 1), (0, 0), (0, 0))

    @pytest.mark.xfail
    @pytest.mark.parametrize(
        "mode",
        [
            "mean",
            "median",
            "reflect",
            "edge",
            "linear_ramp",
            "maximum",
            "minimum",
            "symmetric",
            "wrap",
        ],
    )
    @pytest.mark.parametrize("xr_arg, np_arg", _PAD_XR_NP_ARGS)
    def test_pad(self, mode, xr_arg, np_arg):
>       super().test_pad(mode, xr_arg, np_arg)

/home/swe-bench/pydata__xarray/xarray/tests/test_variable.py:2157: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/home/swe-bench/pydata__xarray/xarray/tests/test_variable.py:843: in test_pad
    v = self.cls(["x", "y", "z"], data)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <xarray.IndexVariable 'x' (x: 4, y: 3, z: 2)>
array([[[ 0,  1],
        [ 2,  3],
        [ 4,  5]],

       [[ 6,  7]... 11]],

       [[12, 13],
        [14, 15],
        [16, 17]],

       [[18, 19],
        [20, 21],
        [22, 23]]])
dims = ['x', 'y', 'z']
data = array([[[ 0,  1],
        [ 2,  3],
        [ 4,  5]],

       [[ 6,  7],
        [ 8,  9],
        [10, 11]],

       [[12, 13],
        [14, 15],
        [16, 17]],

       [[18, 19],
        [20, 21],
        [22, 23]]])
attrs = None, encoding = None, fastpath = False

    def __init__(self, dims, data, attrs=None, encoding=None, fastpath=False):
        super().__init__(dims, data, attrs, encoding, fastpath)
        if self.ndim != 1:
>           raise ValueError("%s objects must be 1-dimensional" % type(self).__name__)
E           ValueError: IndexVariable objects must be 1-dimensional

/home/swe-bench/pydata__xarray/xarray/core/variable.py:2516: ValueError
____________ TestIndexVariable.test_pad[xr_arg0-np_arg0-symmetric] _____________

self = <xarray.tests.test_variable.TestIndexVariable object at 0x77b324440640>
mode = 'symmetric', xr_arg = {'x': (2, 1)}, np_arg = ((2, 1), (0, 0), (0, 0))

    @pytest.mark.xfail
    @pytest.mark.parametrize(
        "mode",
        [
            "mean",
            "median",
            "reflect",
            "edge",
            "linear_ramp",
            "maximum",
            "minimum",
            "symmetric",
            "wrap",
        ],
    )
    @pytest.mark.parametrize("xr_arg, np_arg", _PAD_XR_NP_ARGS)
    def test_pad(self, mode, xr_arg, np_arg):
>       super().test_pad(mode, xr_arg, np_arg)

/home/swe-bench/pydata__xarray/xarray/tests/test_variable.py:2157: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/home/swe-bench/pydata__xarray/xarray/tests/test_variable.py:843: in test_pad
    v = self.cls(["x", "y", "z"], data)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <xarray.IndexVariable 'x' (x: 4, y: 3, z: 2)>
array([[[ 0,  1],
        [ 2,  3],
        [ 4,  5]],

       [[ 6,  7]... 11]],

       [[12, 13],
        [14, 15],
        [16, 17]],

       [[18, 19],
        [20, 21],
        [22, 23]]])
dims = ['x', 'y', 'z']
data = array([[[ 0,  1],
        [ 2,  3],
        [ 4,  5]],

       [[ 6,  7],
        [ 8,  9],
        [10, 11]],

       [[12, 13],
        [14, 15],
        [16, 17]],

       [[18, 19],
        [20, 21],
        [22, 23]]])
attrs = None, encoding = None, fastpath = False

    def __init__(self, dims, data, attrs=None, encoding=None, fastpath=False):
        super().__init__(dims, data, attrs, encoding, fastpath)
        if self.ndim != 1:
>           raise ValueError("%s objects must be 1-dimensional" % type(self).__name__)
E           ValueError: IndexVariable objects must be 1-dimensional

/home/swe-bench/pydata__xarray/xarray/core/variable.py:2516: ValueError
_______________ TestIndexVariable.test_pad[xr_arg0-np_arg0-wrap] _______________

self = <xarray.tests.test_variable.TestIndexVariable object at 0x77b324440700>
mode = 'wrap', xr_arg = {'x': (2, 1)}, np_arg = ((2, 1), (0, 0), (0, 0))

    @pytest.mark.xfail
    @pytest.mark.parametrize(
        "mode",
        [
            "mean",
            "median",
            "reflect",
            "edge",
            "linear_ramp",
            "maximum",
            "minimum",
            "symmetric",
            "wrap",
        ],
    )
    @pytest.mark.parametrize("xr_arg, np_arg", _PAD_XR_NP_ARGS)
    def test_pad(self, mode, xr_arg, np_arg):
>       super().test_pad(mode, xr_arg, np_arg)

/home/swe-bench/pydata__xarray/xarray/tests/test_variable.py:2157: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/home/swe-bench/pydata__xarray/xarray/tests/test_variable.py:843: in test_pad
    v = self.cls(["x", "y", "z"], data)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <xarray.IndexVariable 'x' (x: 4, y: 3, z: 2)>
array([[[ 0,  1],
        [ 2,  3],
        [ 4,  5]],

       [[ 6,  7]... 11]],

       [[12, 13],
        [14, 15],
        [16, 17]],

       [[18, 19],
        [20, 21],
        [22, 23]]])
dims = ['x', 'y', 'z']
data = array([[[ 0,  1],
        [ 2,  3],
        [ 4,  5]],

       [[ 6,  7],
        [ 8,  9],
        [10, 11]],

       [[12, 13],
        [14, 15],
        [16, 17]],

       [[18, 19],
        [20, 21],
        [22, 23]]])
attrs = None, encoding = None, fastpath = False

    def __init__(self, dims, data, attrs=None, encoding=None, fastpath=False):
        super().__init__(dims, data, attrs, encoding, fastpath)
        if self.ndim != 1:
>           raise ValueError("%s objects must be 1-dimensional" % type(self).__name__)
E           ValueError: IndexVariable objects must be 1-dimensional

/home/swe-bench/pydata__xarray/xarray/core/variable.py:2516: ValueError
_______________ TestIndexVariable.test_pad[xr_arg1-np_arg1-mean] _______________

self = <xarray.tests.test_variable.TestIndexVariable object at 0x77b3244407c0>
mode = 'mean', xr_arg = {'x': 1}, np_arg = ((1, 1), (0, 0), (0, 0))

    @pytest.mark.xfail
    @pytest.mark.parametrize(
        "mode",
        [
            "mean",
            "median",
            "reflect",
            "edge",
            "linear_ramp",
            "maximum",
            "minimum",
            "symmetric",
            "wrap",
        ],
    )
    @pytest.mark.parametrize("xr_arg, np_arg", _PAD_XR_NP_ARGS)
    def test_pad(self, mode, xr_arg, np_arg):
>       super().test_pad(mode, xr_arg, np_arg)

/home/swe-bench/pydata__xarray/xarray/tests/test_variable.py:2157: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/home/swe-bench/pydata__xarray/xarray/tests/test_variable.py:843: in test_pad
    v = self.cls(["x", "y", "z"], data)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <xarray.IndexVariable 'x' (x: 4, y: 3, z: 2)>
array([[[ 0,  1],
        [ 2,  3],
        [ 4,  5]],

       [[ 6,  7]... 11]],

       [[12, 13],
        [14, 15],
        [16, 17]],

       [[18, 19],
        [20, 21],
        [22, 23]]])
dims = ['x', 'y', 'z']
data = array([[[ 0,  1],
        [ 2,  3],
        [ 4,  5]],

       [[ 6,  7],
        [ 8,  9],
        [10, 11]],

       [[12, 13],
        [14, 15],
        [16, 17]],

       [[18, 19],
        [20, 21],
        [22, 23]]])
attrs = None, encoding = None, fastpath = False

    def __init__(self, dims, data, attrs=None, encoding=None, fastpath=False):
        super().__init__(dims, data, attrs, encoding, fastpath)
        if self.ndim != 1:
>           raise ValueError("%s objects must be 1-dimensional" % type(self).__name__)
E           ValueError: IndexVariable objects must be 1-dimensional

/home/swe-bench/pydata__xarray/xarray/core/variable.py:2516: ValueError
______________ TestIndexVariable.test_pad[xr_arg1-np_arg1-median] ______________

self = <xarray.tests.test_variable.TestIndexVariable object at 0x77b324440880>
mode = 'median', xr_arg = {'x': 1}, np_arg = ((1, 1), (0, 0), (0, 0))

    @pytest.mark.xfail
    @pytest.mark.parametrize(
        "mode",
        [
            "mean",
            "median",
            "reflect",
            "edge",
            "linear_ramp",
            "maximum",
            "minimum",
            "symmetric",
            "wrap",
        ],
    )
    @pytest.mark.parametrize("xr_arg, np_arg", _PAD_XR_NP_ARGS)
    def test_pad(self, mode, xr_arg, np_arg):
>       super().test_pad(mode, xr_arg, np_arg)

/home/swe-bench/pydata__xarray/xarray/tests/test_variable.py:2157: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/home/swe-bench/pydata__xarray/xarray/tests/test_variable.py:843: in test_pad
    v = self.cls(["x", "y", "z"], data)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <xarray.IndexVariable 'x' (x: 4, y: 3, z: 2)>
array([[[ 0,  1],
        [ 2,  3],
        [ 4,  5]],

       [[ 6,  7]... 11]],

       [[12, 13],
        [14, 15],
        [16, 17]],

       [[18, 19],
        [20, 21],
        [22, 23]]])
dims = ['x', 'y', 'z']
data = array([[[ 0,  1],
        [ 2,  3],
        [ 4,  5]],

       [[ 6,  7],
        [ 8,  9],
        [10, 11]],

       [[12, 13],
        [14, 15],
        [16, 17]],

       [[18, 19],
        [20, 21],
        [22, 23]]])
attrs = None, encoding = None, fastpath = False

    def __init__(self, dims, data, attrs=None, encoding=None, fastpath=False):
        super().__init__(dims, data, attrs, encoding, fastpath)
        if self.ndim != 1:
>           raise ValueError("%s objects must be 1-dimensional" % type(self).__name__)
E           ValueError: IndexVariable objects must be 1-dimensional

/home/swe-bench/pydata__xarray/xarray/core/variable.py:2516: ValueError
_____________ TestIndexVariable.test_pad[xr_arg1-np_arg1-reflect] ______________

self = <xarray.tests.test_variable.TestIndexVariable object at 0x77b324440940>
mode = 'reflect', xr_arg = {'x': 1}, np_arg = ((1, 1), (0, 0), (0, 0))

    @pytest.mark.xfail
    @pytest.mark.parametrize(
        "mode",
        [
            "mean",
            "median",
            "reflect",
            "edge",
            "linear_ramp",
            "maximum",
            "minimum",
            "symmetric",
            "wrap",
        ],
    )
    @pytest.mark.parametrize("xr_arg, np_arg", _PAD_XR_NP_ARGS)
    def test_pad(self, mode, xr_arg, np_arg):
>       super().test_pad(mode, xr_arg, np_arg)

/home/swe-bench/pydata__xarray/xarray/tests/test_variable.py:2157: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/home/swe-bench/pydata__xarray/xarray/tests/test_variable.py:843: in test_pad
    v = self.cls(["x", "y", "z"], data)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <xarray.IndexVariable 'x' (x: 4, y: 3, z: 2)>
array([[[ 0,  1],
        [ 2,  3],
        [ 4,  5]],

       [[ 6,  7]... 11]],

       [[12, 13],
        [14, 15],
        [16, 17]],

       [[18, 19],
        [20, 21],
        [22, 23]]])
dims = ['x', 'y', 'z']
data = array([[[ 0,  1],
        [ 2,  3],
        [ 4,  5]],

       [[ 6,  7],
        [ 8,  9],
        [10, 11]],

       [[12, 13],
        [14, 15],
        [16, 17]],

       [[18, 19],
        [20, 21],
        [22, 23]]])
attrs = None, encoding = None, fastpath = False

    def __init__(self, dims, data, attrs=None, encoding=None, fastpath=False):
        super().__init__(dims, data, attrs, encoding, fastpath)
        if self.ndim != 1:
>           raise ValueError("%s objects must be 1-dimensional" % type(self).__name__)
E           ValueError: IndexVariable objects must be 1-dimensional

/home/swe-bench/pydata__xarray/xarray/core/variable.py:2516: ValueError
_______________ TestIndexVariable.test_pad[xr_arg1-np_arg1-edge] _______________

self = <xarray.tests.test_variable.TestIndexVariable object at 0x77b324440a00>
mode = 'edge', xr_arg = {'x': 1}, np_arg = ((1, 1), (0, 0), (0, 0))

    @pytest.mark.xfail
    @pytest.mark.parametrize(
        "mode",
        [
            "mean",
            "median",
            "reflect",
            "edge",
            "linear_ramp",
            "maximum",
            "minimum",
            "symmetric",
            "wrap",
        ],
    )
    @pytest.mark.parametrize("xr_arg, np_arg", _PAD_XR_NP_ARGS)
    def test_pad(self, mode, xr_arg, np_arg):
>       super().test_pad(mode, xr_arg, np_arg)

/home/swe-bench/pydata__xarray/xarray/tests/test_variable.py:2157: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/home/swe-bench/pydata__xarray/xarray/tests/test_variable.py:843: in test_pad
    v = self.cls(["x", "y", "z"], data)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <xarray.IndexVariable 'x' (x: 4, y: 3, z: 2)>
array([[[ 0,  1],
        [ 2,  3],
        [ 4,  5]],

       [[ 6,  7]... 11]],

       [[12, 13],
        [14, 15],
        [16, 17]],

       [[18, 19],
        [20, 21],
        [22, 23]]])
dims = ['x', 'y', 'z']
data = array([[[ 0,  1],
        [ 2,  3],
        [ 4,  5]],

       [[ 6,  7],
        [ 8,  9],
        [10, 11]],

       [[12, 13],
        [14, 15],
        [16, 17]],

       [[18, 19],
        [20, 21],
        [22, 23]]])
attrs = None, encoding = None, fastpath = False

    def __init__(self, dims, data, attrs=None, encoding=None, fastpath=False):
        super().__init__(dims, data, attrs, encoding, fastpath)
        if self.ndim != 1:
>           raise ValueError("%s objects must be 1-dimensional" % type(self).__name__)
E           ValueError: IndexVariable objects must be 1-dimensional

/home/swe-bench/pydata__xarray/xarray/core/variable.py:2516: ValueError
___________ TestIndexVariable.test_pad[xr_arg1-np_arg1-linear_ramp] ____________

self = <xarray.tests.test_variable.TestIndexVariable object at 0x77b324440ac0>
mode = 'linear_ramp', xr_arg = {'x': 1}, np_arg = ((1, 1), (0, 0), (0, 0))

    @pytest.mark.xfail
    @pytest.mark.parametrize(
        "mode",
        [
            "mean",
            "median",
            "reflect",
            "edge",
            "linear_ramp",
            "maximum",
            "minimum",
            "symmetric",
            "wrap",
        ],
    )
    @pytest.mark.parametrize("xr_arg, np_arg", _PAD_XR_NP_ARGS)
    def test_pad(self, mode, xr_arg, np_arg):
>       super().test_pad(mode, xr_arg, np_arg)

/home/swe-bench/pydata__xarray/xarray/tests/test_variable.py:2157: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/home/swe-bench/pydata__xarray/xarray/tests/test_variable.py:843: in test_pad
    v = self.cls(["x", "y", "z"], data)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <xarray.IndexVariable 'x' (x: 4, y: 3, z: 2)>
array([[[ 0,  1],
        [ 2,  3],
        [ 4,  5]],

       [[ 6,  7]... 11]],

       [[12, 13],
        [14, 15],
        [16, 17]],

       [[18, 19],
        [20, 21],
        [22, 23]]])
dims = ['x', 'y', 'z']
data = array([[[ 0,  1],
        [ 2,  3],
        [ 4,  5]],

       [[ 6,  7],
        [ 8,  9],
        [10, 11]],

       [[12, 13],
        [14, 15],
        [16, 17]],

       [[18, 19],
        [20, 21],
        [22, 23]]])
attrs = None, encoding = None, fastpath = False

    def __init__(self, dims, data, attrs=None, encoding=None, fastpath=False):
        super().__init__(dims, data, attrs, encoding, fastpath)
        if self.ndim != 1:
>           raise ValueError("%s objects must be 1-dimensional" % type(self).__name__)
E           ValueError: IndexVariable objects must be 1-dimensional

/home/swe-bench/pydata__xarray/xarray/core/variable.py:2516: ValueError
_____________ TestIndexVariable.test_pad[xr_arg1-np_arg1-maximum] ______________

self = <xarray.tests.test_variable.TestIndexVariable object at 0x77b324440b80>
mode = 'maximum', xr_arg = {'x': 1}, np_arg = ((1, 1), (0, 0), (0, 0))

    @pytest.mark.xfail
    @pytest.mark.parametrize(
        "mode",
        [
            "mean",
            "median",
            "reflect",
            "edge",
            "linear_ramp",
            "maximum",
            "minimum",
            "symmetric",
            "wrap",
        ],
    )
    @pytest.mark.parametrize("xr_arg, np_arg", _PAD_XR_NP_ARGS)
    def test_pad(self, mode, xr_arg, np_arg):
>       super().test_pad(mode, xr_arg, np_arg)

/home/swe-bench/pydata__xarray/xarray/tests/test_variable.py:2157: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/home/swe-bench/pydata__xarray/xarray/tests/test_variable.py:843: in test_pad
    v = self.cls(["x", "y", "z"], data)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <xarray.IndexVariable 'x' (x: 4, y: 3, z: 2)>
array([[[ 0,  1],
        [ 2,  3],
        [ 4,  5]],

       [[ 6,  7]... 11]],

       [[12, 13],
        [14, 15],
        [16, 17]],

       [[18, 19],
        [20, 21],
        [22, 23]]])
dims = ['x', 'y', 'z']
data = array([[[ 0,  1],
        [ 2,  3],
        [ 4,  5]],

       [[ 6,  7],
        [ 8,  9],
        [10, 11]],

       [[12, 13],
        [14, 15],
        [16, 17]],

       [[18, 19],
        [20, 21],
        [22, 23]]])
attrs = None, encoding = None, fastpath = False

    def __init__(self, dims, data, attrs=None, encoding=None, fastpath=False):
        super().__init__(dims, data, attrs, encoding, fastpath)
        if self.ndim != 1:
>           raise ValueError("%s objects must be 1-dimensional" % type(self).__name__)
E           ValueError: IndexVariable objects must be 1-dimensional

/home/swe-bench/pydata__xarray/xarray/core/variable.py:2516: ValueError
_____________ TestIndexVariable.test_pad[xr_arg1-np_arg1-minimum] ______________

self = <xarray.tests.test_variable.TestIndexVariable object at 0x77b324440c40>
mode = 'minimum', xr_arg = {'x': 1}, np_arg = ((1, 1), (0, 0), (0, 0))

    @pytest.mark.xfail
    @pytest.mark.parametrize(
        "mode",
        [
            "mean",
            "median",
            "reflect",
            "edge",
            "linear_ramp",
            "maximum",
            "minimum",
            "symmetric",
            "wrap",
        ],
    )
    @pytest.mark.parametrize("xr_arg, np_arg", _PAD_XR_NP_ARGS)
    def test_pad(self, mode, xr_arg, np_arg):
>       super().test_pad(mode, xr_arg, np_arg)

/home/swe-bench/pydata__xarray/xarray/tests/test_variable.py:2157: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/home/swe-bench/pydata__xarray/xarray/tests/test_variable.py:843: in test_pad
    v = self.cls(["x", "y", "z"], data)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <xarray.IndexVariable 'x' (x: 4, y: 3, z: 2)>
array([[[ 0,  1],
        [ 2,  3],
        [ 4,  5]],

       [[ 6,  7]... 11]],

       [[12, 13],
        [14, 15],
        [16, 17]],

       [[18, 19],
        [20, 21],
        [22, 23]]])
dims = ['x', 'y', 'z']
data = array([[[ 0,  1],
        [ 2,  3],
        [ 4,  5]],

       [[ 6,  7],
        [ 8,  9],
        [10, 11]],

       [[12, 13],
        [14, 15],
        [16, 17]],

       [[18, 19],
        [20, 21],
        [22, 23]]])
attrs = None, encoding = None, fastpath = False

    def __init__(self, dims, data, attrs=None, encoding=None, fastpath=False):
        super().__init__(dims, data, attrs, encoding, fastpath)
        if self.ndim != 1:
>           raise ValueError("%s objects must be 1-dimensional" % type(self).__name__)
E           ValueError: IndexVariable objects must be 1-dimensional

/home/swe-bench/pydata__xarray/xarray/core/variable.py:2516: ValueError
____________ TestIndexVariable.test_pad[xr_arg1-np_arg1-symmetric] _____________

self = <xarray.tests.test_variable.TestIndexVariable object at 0x77b324440d00>
mode = 'symmetric', xr_arg = {'x': 1}, np_arg = ((1, 1), (0, 0), (0, 0))

    @pytest.mark.xfail
    @pytest.mark.parametrize(
        "mode",
        [
            "mean",
            "median",
            "reflect",
            "edge",
            "linear_ramp",
            "maximum",
            "minimum",
            "symmetric",
            "wrap",
        ],
    )
    @pytest.mark.parametrize("xr_arg, np_arg", _PAD_XR_NP_ARGS)
    def test_pad(self, mode, xr_arg, np_arg):
>       super().test_pad(mode, xr_arg, np_arg)

/home/swe-bench/pydata__xarray/xarray/tests/test_variable.py:2157: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/home/swe-bench/pydata__xarray/xarray/tests/test_variable.py:843: in test_pad
    v = self.cls(["x", "y", "z"], data)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <xarray.IndexVariable 'x' (x: 4, y: 3, z: 2)>
array([[[ 0,  1],
        [ 2,  3],
        [ 4,  5]],

       [[ 6,  7]... 11]],

       [[12, 13],
        [14, 15],
        [16, 17]],

       [[18, 19],
        [20, 21],
        [22, 23]]])
dims = ['x', 'y', 'z']
data = array([[[ 0,  1],
        [ 2,  3],
        [ 4,  5]],

       [[ 6,  7],
        [ 8,  9],
        [10, 11]],

       [[12, 13],
        [14, 15],
        [16, 17]],

       [[18, 19],
        [20, 21],
        [22, 23]]])
attrs = None, encoding = None, fastpath = False

    def __init__(self, dims, data, attrs=None, encoding=None, fastpath=False):
        super().__init__(dims, data, attrs, encoding, fastpath)
        if self.ndim != 1:
>           raise ValueError("%s objects must be 1-dimensional" % type(self).__name__)
E           ValueError: IndexVariable objects must be 1-dimensional

/home/swe-bench/pydata__xarray/xarray/core/variable.py:2516: ValueError
_______________ TestIndexVariable.test_pad[xr_arg1-np_arg1-wrap] _______________

self = <xarray.tests.test_variable.TestIndexVariable object at 0x77b324440dc0>
mode = 'wrap', xr_arg = {'x': 1}, np_arg = ((1, 1), (0, 0), (0, 0))

    @pytest.mark.xfail
    @pytest.mark.parametrize(
        "mode",
        [
            "mean",
            "median",
            "reflect",
            "edge",
            "linear_ramp",
            "maximum",
            "minimum",
            "symmetric",
            "wrap",
        ],
    )
    @pytest.mark.parametrize("xr_arg, np_arg", _PAD_XR_NP_ARGS)
    def test_pad(self, mode, xr_arg, np_arg):
>       super().test_pad(mode, xr_arg, np_arg)

/home/swe-bench/pydata__xarray/xarray/tests/test_variable.py:2157: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/home/swe-bench/pydata__xarray/xarray/tests/test_variable.py:843: in test_pad
    v = self.cls(["x", "y", "z"], data)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <xarray.IndexVariable 'x' (x: 4, y: 3, z: 2)>
array([[[ 0,  1],
        [ 2,  3],
        [ 4,  5]],

       [[ 6,  7]... 11]],

       [[12, 13],
        [14, 15],
        [16, 17]],

       [[18, 19],
        [20, 21],
        [22, 23]]])
dims = ['x', 'y', 'z']
data = array([[[ 0,  1],
        [ 2,  3],
        [ 4,  5]],

       [[ 6,  7],
        [ 8,  9],
        [10, 11]],

       [[12, 13],
        [14, 15],
        [16, 17]],

       [[18, 19],
        [20, 21],
        [22, 23]]])
attrs = None, encoding = None, fastpath = False

    def __init__(self, dims, data, attrs=None, encoding=None, fastpath=False):
        super().__init__(dims, data, attrs, encoding, fastpath)
        if self.ndim != 1:
>           raise ValueError("%s objects must be 1-dimensional" % type(self).__name__)
E           ValueError: IndexVariable objects must be 1-dimensional

/home/swe-bench/pydata__xarray/xarray/core/variable.py:2516: ValueError
_______________ TestIndexVariable.test_pad[xr_arg2-np_arg2-mean] _______________

self = <xarray.tests.test_variable.TestIndexVariable object at 0x77b324440e80>
mode = 'mean', xr_arg = {'y': (0, 3)}, np_arg = ((0, 0), (0, 3), (0, 0))

    @pytest.mark.xfail
    @pytest.mark.parametrize(
        "mode",
        [
            "mean",
            "median",
            "reflect",
            "edge",
            "linear_ramp",
            "maximum",
            "minimum",
            "symmetric",
            "wrap",
        ],
    )
    @pytest.mark.parametrize("xr_arg, np_arg", _PAD_XR_NP_ARGS)
    def test_pad(self, mode, xr_arg, np_arg):
>       super().test_pad(mode, xr_arg, np_arg)

/home/swe-bench/pydata__xarray/xarray/tests/test_variable.py:2157: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/home/swe-bench/pydata__xarray/xarray/tests/test_variable.py:843: in test_pad
    v = self.cls(["x", "y", "z"], data)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <xarray.IndexVariable 'x' (x: 4, y: 3, z: 2)>
array([[[ 0,  1],
        [ 2,  3],
        [ 4,  5]],

       [[ 6,  7]... 11]],

       [[12, 13],
        [14, 15],
        [16, 17]],

       [[18, 19],
        [20, 21],
        [22, 23]]])
dims = ['x', 'y', 'z']
data = array([[[ 0,  1],
        [ 2,  3],
        [ 4,  5]],

       [[ 6,  7],
        [ 8,  9],
        [10, 11]],

       [[12, 13],
        [14, 15],
        [16, 17]],

       [[18, 19],
        [20, 21],
        [22, 23]]])
attrs = None, encoding = None, fastpath = False

    def __init__(self, dims, data, attrs=None, encoding=None, fastpath=False):
        super().__init__(dims, data, attrs, encoding, fastpath)
        if self.ndim != 1:
>           raise ValueError("%s objects must be 1-dimensional" % type(self).__name__)
E           ValueError: IndexVariable objects must be 1-dimensional

/home/swe-bench/pydata__xarray/xarray/core/variable.py:2516: ValueError
______________ TestIndexVariable.test_pad[xr_arg2-np_arg2-median] ______________

self = <xarray.tests.test_variable.TestIndexVariable object at 0x77b324440f40>
mode = 'median', xr_arg = {'y': (0, 3)}, np_arg = ((0, 0), (0, 3), (0, 0))

    @pytest.mark.xfail
    @pytest.mark.parametrize(
        "mode",
        [
            "mean",
            "median",
            "reflect",
            "edge",
            "linear_ramp",
            "maximum",
            "minimum",
            "symmetric",
            "wrap",
        ],
    )
    @pytest.mark.parametrize("xr_arg, np_arg", _PAD_XR_NP_ARGS)
    def test_pad(self, mode, xr_arg, np_arg):
>       super().test_pad(mode, xr_arg, np_arg)

/home/swe-bench/pydata__xarray/xarray/tests/test_variable.py:2157: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/home/swe-bench/pydata__xarray/xarray/tests/test_variable.py:843: in test_pad
    v = self.cls(["x", "y", "z"], data)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <xarray.IndexVariable 'x' (x: 4, y: 3, z: 2)>
array([[[ 0,  1],
        [ 2,  3],
        [ 4,  5]],

       [[ 6,  7]... 11]],

       [[12, 13],
        [14, 15],
        [16, 17]],

       [[18, 19],
        [20, 21],
        [22, 23]]])
dims = ['x', 'y', 'z']
data = array([[[ 0,  1],
        [ 2,  3],
        [ 4,  5]],

       [[ 6,  7],
        [ 8,  9],
        [10, 11]],

       [[12, 13],
        [14, 15],
        [16, 17]],

       [[18, 19],
        [20, 21],
        [22, 23]]])
attrs = None, encoding = None, fastpath = False

    def __init__(self, dims, data, attrs=None, encoding=None, fastpath=False):
        super().__init__(dims, data, attrs, encoding, fastpath)
        if self.ndim != 1:
>           raise ValueError("%s objects must be 1-dimensional" % type(self).__name__)
E           ValueError: IndexVariable objects must be 1-dimensional

/home/swe-bench/pydata__xarray/xarray/core/variable.py:2516: ValueError
_____________ TestIndexVariable.test_pad[xr_arg2-np_arg2-reflect] ______________

self = <xarray.tests.test_variable.TestIndexVariable object at 0x77b324441000>
mode = 'reflect', xr_arg = {'y': (0, 3)}, np_arg = ((0, 0), (0, 3), (0, 0))

    @pytest.mark.xfail
    @pytest.mark.parametrize(
        "mode",
        [
            "mean",
            "median",
            "reflect",
            "edge",
            "linear_ramp",
            "maximum",
            "minimum",
            "symmetric",
            "wrap",
        ],
    )
    @pytest.mark.parametrize("xr_arg, np_arg", _PAD_XR_NP_ARGS)
    def test_pad(self, mode, xr_arg, np_arg):
>       super().test_pad(mode, xr_arg, np_arg)

/home/swe-bench/pydata__xarray/xarray/tests/test_variable.py:2157: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/home/swe-bench/pydata__xarray/xarray/tests/test_variable.py:843: in test_pad
    v = self.cls(["x", "y", "z"], data)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <xarray.IndexVariable 'x' (x: 4, y: 3, z: 2)>
array([[[ 0,  1],
        [ 2,  3],
        [ 4,  5]],

       [[ 6,  7]... 11]],

       [[12, 13],
        [14, 15],
        [16, 17]],

       [[18, 19],
        [20, 21],
        [22, 23]]])
dims = ['x', 'y', 'z']
data = array([[[ 0,  1],
        [ 2,  3],
        [ 4,  5]],

       [[ 6,  7],
        [ 8,  9],
        [10, 11]],

       [[12, 13],
        [14, 15],
        [16, 17]],

       [[18, 19],
        [20, 21],
        [22, 23]]])
attrs = None, encoding = None, fastpath = False

    def __init__(self, dims, data, attrs=None, encoding=None, fastpath=False):
        super().__init__(dims, data, attrs, encoding, fastpath)
        if self.ndim != 1:
>           raise ValueError("%s objects must be 1-dimensional" % type(self).__name__)
E           ValueError: IndexVariable objects must be 1-dimensional

/home/swe-bench/pydata__xarray/xarray/core/variable.py:2516: ValueError
_______________ TestIndexVariable.test_pad[xr_arg2-np_arg2-edge] _______________

self = <xarray.tests.test_variable.TestIndexVariable object at 0x77b3244410c0>
mode = 'edge', xr_arg = {'y': (0, 3)}, np_arg = ((0, 0), (0, 3), (0, 0))

    @pytest.mark.xfail
    @pytest.mark.parametrize(
        "mode",
        [
            "mean",
            "median",
            "reflect",
            "edge",
            "linear_ramp",
            "maximum",
            "minimum",
            "symmetric",
            "wrap",
        ],
    )
    @pytest.mark.parametrize("xr_arg, np_arg", _PAD_XR_NP_ARGS)
    def test_pad(self, mode, xr_arg, np_arg):
>       super().test_pad(mode, xr_arg, np_arg)

/home/swe-bench/pydata__xarray/xarray/tests/test_variable.py:2157: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/home/swe-bench/pydata__xarray/xarray/tests/test_variable.py:843: in test_pad
    v = self.cls(["x", "y", "z"], data)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <xarray.IndexVariable 'x' (x: 4, y: 3, z: 2)>
array([[[ 0,  1],
        [ 2,  3],
        [ 4,  5]],

       [[ 6,  7]... 11]],

       [[12, 13],
        [14, 15],
        [16, 17]],

       [[18, 19],
        [20, 21],
        [22, 23]]])
dims = ['x', 'y', 'z']
data = array([[[ 0,  1],
        [ 2,  3],
        [ 4,  5]],

       [[ 6,  7],
        [ 8,  9],
        [10, 11]],

       [[12, 13],
        [14, 15],
        [16, 17]],

       [[18, 19],
        [20, 21],
        [22, 23]]])
attrs = None, encoding = None, fastpath = False

    def __init__(self, dims, data, attrs=None, encoding=None, fastpath=False):
        super().__init__(dims, data, attrs, encoding, fastpath)
        if self.ndim != 1:
>           raise ValueError("%s objects must be 1-dimensional" % type(self).__name__)
E           ValueError: IndexVariable objects must be 1-dimensional

/home/swe-bench/pydata__xarray/xarray/core/variable.py:2516: ValueError
___________ TestIndexVariable.test_pad[xr_arg2-np_arg2-linear_ramp] ____________

self = <xarray.tests.test_variable.TestIndexVariable object at 0x77b324441180>
mode = 'linear_ramp', xr_arg = {'y': (0, 3)}, np_arg = ((0, 0), (0, 3), (0, 0))

    @pytest.mark.xfail
    @pytest.mark.parametrize(
        "mode",
        [
            "mean",
            "median",
            "reflect",
            "edge",
            "linear_ramp",
            "maximum",
            "minimum",
            "symmetric",
            "wrap",
        ],
    )
    @pytest.mark.parametrize("xr_arg, np_arg", _PAD_XR_NP_ARGS)
    def test_pad(self, mode, xr_arg, np_arg):
>       super().test_pad(mode, xr_arg, np_arg)

/home/swe-bench/pydata__xarray/xarray/tests/test_variable.py:2157: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/home/swe-bench/pydata__xarray/xarray/tests/test_variable.py:843: in test_pad
    v = self.cls(["x", "y", "z"], data)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <xarray.IndexVariable 'x' (x: 4, y: 3, z: 2)>
array([[[ 0,  1],
        [ 2,  3],
        [ 4,  5]],

       [[ 6,  7]... 11]],

       [[12, 13],
        [14, 15],
        [16, 17]],

       [[18, 19],
        [20, 21],
        [22, 23]]])
dims = ['x', 'y', 'z']
data = array([[[ 0,  1],
        [ 2,  3],
        [ 4,  5]],

       [[ 6,  7],
        [ 8,  9],
        [10, 11]],

       [[12, 13],
        [14, 15],
        [16, 17]],

       [[18, 19],
        [20, 21],
        [22, 23]]])
attrs = None, encoding = None, fastpath = False

    def __init__(self, dims, data, attrs=None, encoding=None, fastpath=False):
        super().__init__(dims, data, attrs, encoding, fastpath)
        if self.ndim != 1:
>           raise ValueError("%s objects must be 1-dimensional" % type(self).__name__)
E           ValueError: IndexVariable objects must be 1-dimensional

/home/swe-bench/pydata__xarray/xarray/core/variable.py:2516: ValueError
_____________ TestIndexVariable.test_pad[xr_arg2-np_arg2-maximum] ______________

self = <xarray.tests.test_variable.TestIndexVariable object at 0x77b324441240>
mode = 'maximum', xr_arg = {'y': (0, 3)}, np_arg = ((0, 0), (0, 3), (0, 0))

    @pytest.mark.xfail
    @pytest.mark.parametrize(
        "mode",
        [
            "mean",
            "median",
            "reflect",
            "edge",
            "linear_ramp",
            "maximum",
            "minimum",
            "symmetric",
            "wrap",
        ],
    )
    @pytest.mark.parametrize("xr_arg, np_arg", _PAD_XR_NP_ARGS)
    def test_pad(self, mode, xr_arg, np_arg):
>       super().test_pad(mode, xr_arg, np_arg)

/home/swe-bench/pydata__xarray/xarray/tests/test_variable.py:2157: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/home/swe-bench/pydata__xarray/xarray/tests/test_variable.py:843: in test_pad
    v = self.cls(["x", "y", "z"], data)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <xarray.IndexVariable 'x' (x: 4, y: 3, z: 2)>
array([[[ 0,  1],
        [ 2,  3],
        [ 4,  5]],

       [[ 6,  7]... 11]],

       [[12, 13],
        [14, 15],
        [16, 17]],

       [[18, 19],
        [20, 21],
        [22, 23]]])
dims = ['x', 'y', 'z']
data = array([[[ 0,  1],
        [ 2,  3],
        [ 4,  5]],

       [[ 6,  7],
        [ 8,  9],
        [10, 11]],

       [[12, 13],
        [14, 15],
        [16, 17]],

       [[18, 19],
        [20, 21],
        [22, 23]]])
attrs = None, encoding = None, fastpath = False

    def __init__(self, dims, data, attrs=None, encoding=None, fastpath=False):
        super().__init__(dims, data, attrs, encoding, fastpath)
        if self.ndim != 1:
>           raise ValueError("%s objects must be 1-dimensional" % type(self).__name__)
E           ValueError: IndexVariable objects must be 1-dimensional

/home/swe-bench/pydata__xarray/xarray/core/variable.py:2516: ValueError
_____________ TestIndexVariable.test_pad[xr_arg2-np_arg2-minimum] ______________

self = <xarray.tests.test_variable.TestIndexVariable object at 0x77b324441300>
mode = 'minimum', xr_arg = {'y': (0, 3)}, np_arg = ((0, 0), (0, 3), (0, 0))

    @pytest.mark.xfail
    @pytest.mark.parametrize(
        "mode",
        [
            "mean",
            "median",
            "reflect",
            "edge",
            "linear_ramp",
            "maximum",
            "minimum",
            "symmetric",
            "wrap",
        ],
    )
    @pytest.mark.parametrize("xr_arg, np_arg", _PAD_XR_NP_ARGS)
    def test_pad(self, mode, xr_arg, np_arg):
>       super().test_pad(mode, xr_arg, np_arg)

/home/swe-bench/pydata__xarray/xarray/tests/test_variable.py:2157: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/home/swe-bench/pydata__xarray/xarray/tests/test_variable.py:843: in test_pad
    v = self.cls(["x", "y", "z"], data)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <xarray.IndexVariable 'x' (x: 4, y: 3, z: 2)>
array([[[ 0,  1],
        [ 2,  3],
        [ 4,  5]],

       [[ 6,  7]... 11]],

       [[12, 13],
        [14, 15],
        [16, 17]],

       [[18, 19],
        [20, 21],
        [22, 23]]])
dims = ['x', 'y', 'z']
data = array([[[ 0,  1],
        [ 2,  3],
        [ 4,  5]],

       [[ 6,  7],
        [ 8,  9],
        [10, 11]],

       [[12, 13],
        [14, 15],
        [16, 17]],

       [[18, 19],
        [20, 21],
        [22, 23]]])
attrs = None, encoding = None, fastpath = False

    def __init__(self, dims, data, attrs=None, encoding=None, fastpath=False):
        super().__init__(dims, data, attrs, encoding, fastpath)
        if self.ndim != 1:
>           raise ValueError("%s objects must be 1-dimensional" % type(self).__name__)
E           ValueError: IndexVariable objects must be 1-dimensional

/home/swe-bench/pydata__xarray/xarray/core/variable.py:2516: ValueError
____________ TestIndexVariable.test_pad[xr_arg2-np_arg2-symmetric] _____________

self = <xarray.tests.test_variable.TestIndexVariable object at 0x77b3244413c0>
mode = 'symmetric', xr_arg = {'y': (0, 3)}, np_arg = ((0, 0), (0, 3), (0, 0))

    @pytest.mark.xfail
    @pytest.mark.parametrize(
        "mode",
        [
            "mean",
            "median",
            "reflect",
            "edge",
            "linear_ramp",
            "maximum",
            "minimum",
            "symmetric",
            "wrap",
        ],
    )
    @pytest.mark.parametrize("xr_arg, np_arg", _PAD_XR_NP_ARGS)
    def test_pad(self, mode, xr_arg, np_arg):
>       super().test_pad(mode, xr_arg, np_arg)

/home/swe-bench/pydata__xarray/xarray/tests/test_variable.py:2157: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/home/swe-bench/pydata__xarray/xarray/tests/test_variable.py:843: in test_pad
    v = self.cls(["x", "y", "z"], data)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <xarray.IndexVariable 'x' (x: 4, y: 3, z: 2)>
array([[[ 0,  1],
        [ 2,  3],
        [ 4,  5]],

       [[ 6,  7]... 11]],

       [[12, 13],
        [14, 15],
        [16, 17]],

       [[18, 19],
        [20, 21],
        [22, 23]]])
dims = ['x', 'y', 'z']
data = array([[[ 0,  1],
        [ 2,  3],
        [ 4,  5]],

       [[ 6,  7],
        [ 8,  9],
        [10, 11]],

       [[12, 13],
        [14, 15],
        [16, 17]],

       [[18, 19],
        [20, 21],
        [22, 23]]])
attrs = None, encoding = None, fastpath = False

    def __init__(self, dims, data, attrs=None, encoding=None, fastpath=False):
        super().__init__(dims, data, attrs, encoding, fastpath)
        if self.ndim != 1:
>           raise ValueError("%s objects must be 1-dimensional" % type(self).__name__)
E           ValueError: IndexVariable objects must be 1-dimensional

/home/swe-bench/pydata__xarray/xarray/core/variable.py:2516: ValueError
_______________ TestIndexVariable.test_pad[xr_arg2-np_arg2-wrap] _______________

self = <xarray.tests.test_variable.TestIndexVariable object at 0x77b324441480>
mode = 'wrap', xr_arg = {'y': (0, 3)}, np_arg = ((0, 0), (0, 3), (0, 0))

    @pytest.mark.xfail
    @pytest.mark.parametrize(
        "mode",
        [
            "mean",
            "median",
            "reflect",
            "edge",
            "linear_ramp",
            "maximum",
            "minimum",
            "symmetric",
            "wrap",
        ],
    )
    @pytest.mark.parametrize("xr_arg, np_arg", _PAD_XR_NP_ARGS)
    def test_pad(self, mode, xr_arg, np_arg):
>       super().test_pad(mode, xr_arg, np_arg)

/home/swe-bench/pydata__xarray/xarray/tests/test_variable.py:2157: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/home/swe-bench/pydata__xarray/xarray/tests/test_variable.py:843: in test_pad
    v = self.cls(["x", "y", "z"], data)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <xarray.IndexVariable 'x' (x: 4, y: 3, z: 2)>
array([[[ 0,  1],
        [ 2,  3],
        [ 4,  5]],

       [[ 6,  7]... 11]],

       [[12, 13],
        [14, 15],
        [16, 17]],

       [[18, 19],
        [20, 21],
        [22, 23]]])
dims = ['x', 'y', 'z']
data = array([[[ 0,  1],
        [ 2,  3],
        [ 4,  5]],

       [[ 6,  7],
        [ 8,  9],
        [10, 11]],

       [[12, 13],
        [14, 15],
        [16, 17]],

       [[18, 19],
        [20, 21],
        [22, 23]]])
attrs = None, encoding = None, fastpath = False

    def __init__(self, dims, data, attrs=None, encoding=None, fastpath=False):
        super().__init__(dims, data, attrs, encoding, fastpath)
        if self.ndim != 1:
>           raise ValueError("%s objects must be 1-dimensional" % type(self).__name__)
E           ValueError: IndexVariable objects must be 1-dimensional

/home/swe-bench/pydata__xarray/xarray/core/variable.py:2516: ValueError
_______________ TestIndexVariable.test_pad[xr_arg3-np_arg3-mean] _______________

self = <xarray.tests.test_variable.TestIndexVariable object at 0x77b324441540>
mode = 'mean', xr_arg = {'x': (3, 1), 'z': (2, 0)}
np_arg = ((3, 1), (0, 0), (2, 0))

    @pytest.mark.xfail
    @pytest.mark.parametrize(
        "mode",
        [
            "mean",
            "median",
            "reflect",
            "edge",
            "linear_ramp",
            "maximum",
            "minimum",
            "symmetric",
            "wrap",
        ],
    )
    @pytest.mark.parametrize("xr_arg, np_arg", _PAD_XR_NP_ARGS)
    def test_pad(self, mode, xr_arg, np_arg):
>       super().test_pad(mode, xr_arg, np_arg)

/home/swe-bench/pydata__xarray/xarray/tests/test_variable.py:2157: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/home/swe-bench/pydata__xarray/xarray/tests/test_variable.py:843: in test_pad
    v = self.cls(["x", "y", "z"], data)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <xarray.IndexVariable 'x' (x: 4, y: 3, z: 2)>
array([[[ 0,  1],
        [ 2,  3],
        [ 4,  5]],

       [[ 6,  7]... 11]],

       [[12, 13],
        [14, 15],
        [16, 17]],

       [[18, 19],
        [20, 21],
        [22, 23]]])
dims = ['x', 'y', 'z']
data = array([[[ 0,  1],
        [ 2,  3],
        [ 4,  5]],

       [[ 6,  7],
        [ 8,  9],
        [10, 11]],

       [[12, 13],
        [14, 15],
        [16, 17]],

       [[18, 19],
        [20, 21],
        [22, 23]]])
attrs = None, encoding = None, fastpath = False

    def __init__(self, dims, data, attrs=None, encoding=None, fastpath=False):
        super().__init__(dims, data, attrs, encoding, fastpath)
        if self.ndim != 1:
>           raise ValueError("%s objects must be 1-dimensional" % type(self).__name__)
E           ValueError: IndexVariable objects must be 1-dimensional

/home/swe-bench/pydata__xarray/xarray/core/variable.py:2516: ValueError
______________ TestIndexVariable.test_pad[xr_arg3-np_arg3-median] ______________

self = <xarray.tests.test_variable.TestIndexVariable object at 0x77b324441600>
mode = 'median', xr_arg = {'x': (3, 1), 'z': (2, 0)}
np_arg = ((3, 1), (0, 0), (2, 0))

    @pytest.mark.xfail
    @pytest.mark.parametrize(
        "mode",
        [
            "mean",
            "median",
            "reflect",
            "edge",
            "linear_ramp",
            "maximum",
            "minimum",
            "symmetric",
            "wrap",
        ],
    )
    @pytest.mark.parametrize("xr_arg, np_arg", _PAD_XR_NP_ARGS)
    def test_pad(self, mode, xr_arg, np_arg):
>       super().test_pad(mode, xr_arg, np_arg)

/home/swe-bench/pydata__xarray/xarray/tests/test_variable.py:2157: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/home/swe-bench/pydata__xarray/xarray/tests/test_variable.py:843: in test_pad
    v = self.cls(["x", "y", "z"], data)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <xarray.IndexVariable 'x' (x: 4, y: 3, z: 2)>
array([[[ 0,  1],
        [ 2,  3],
        [ 4,  5]],

       [[ 6,  7]... 11]],

       [[12, 13],
        [14, 15],
        [16, 17]],

       [[18, 19],
        [20, 21],
        [22, 23]]])
dims = ['x', 'y', 'z']
data = array([[[ 0,  1],
        [ 2,  3],
        [ 4,  5]],

       [[ 6,  7],
        [ 8,  9],
        [10, 11]],

       [[12, 13],
        [14, 15],
        [16, 17]],

       [[18, 19],
        [20, 21],
        [22, 23]]])
attrs = None, encoding = None, fastpath = False

    def __init__(self, dims, data, attrs=None, encoding=None, fastpath=False):
        super().__init__(dims, data, attrs, encoding, fastpath)
        if self.ndim != 1:
>           raise ValueError("%s objects must be 1-dimensional" % type(self).__name__)
E           ValueError: IndexVariable objects must be 1-dimensional

/home/swe-bench/pydata__xarray/xarray/core/variable.py:2516: ValueError
_____________ TestIndexVariable.test_pad[xr_arg3-np_arg3-reflect] ______________

self = <xarray.tests.test_variable.TestIndexVariable object at 0x77b3244416c0>
mode = 'reflect', xr_arg = {'x': (3, 1), 'z': (2, 0)}
np_arg = ((3, 1), (0, 0), (2, 0))

    @pytest.mark.xfail
    @pytest.mark.parametrize(
        "mode",
        [
            "mean",
            "median",
            "reflect",
            "edge",
            "linear_ramp",
            "maximum",
            "minimum",
            "symmetric",
            "wrap",
        ],
    )
    @pytest.mark.parametrize("xr_arg, np_arg", _PAD_XR_NP_ARGS)
    def test_pad(self, mode, xr_arg, np_arg):
>       super().test_pad(mode, xr_arg, np_arg)

/home/swe-bench/pydata__xarray/xarray/tests/test_variable.py:2157: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/home/swe-bench/pydata__xarray/xarray/tests/test_variable.py:843: in test_pad
    v = self.cls(["x", "y", "z"], data)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <xarray.IndexVariable 'x' (x: 4, y: 3, z: 2)>
array([[[ 0,  1],
        [ 2,  3],
        [ 4,  5]],

       [[ 6,  7]... 11]],

       [[12, 13],
        [14, 15],
        [16, 17]],

       [[18, 19],
        [20, 21],
        [22, 23]]])
dims = ['x', 'y', 'z']
data = array([[[ 0,  1],
        [ 2,  3],
        [ 4,  5]],

       [[ 6,  7],
        [ 8,  9],
        [10, 11]],

       [[12, 13],
        [14, 15],
        [16, 17]],

       [[18, 19],
        [20, 21],
        [22, 23]]])
attrs = None, encoding = None, fastpath = False

    def __init__(self, dims, data, attrs=None, encoding=None, fastpath=False):
        super().__init__(dims, data, attrs, encoding, fastpath)
        if self.ndim != 1:
>           raise ValueError("%s objects must be 1-dimensional" % type(self).__name__)
E           ValueError: IndexVariable objects must be 1-dimensional

/home/swe-bench/pydata__xarray/xarray/core/variable.py:2516: ValueError
_______________ TestIndexVariable.test_pad[xr_arg3-np_arg3-edge] _______________

self = <xarray.tests.test_variable.TestIndexVariable object at 0x77b324441780>
mode = 'edge', xr_arg = {'x': (3, 1), 'z': (2, 0)}
np_arg = ((3, 1), (0, 0), (2, 0))

    @pytest.mark.xfail
    @pytest.mark.parametrize(
        "mode",
        [
            "mean",
            "median",
            "reflect",
            "edge",
            "linear_ramp",
            "maximum",
            "minimum",
            "symmetric",
            "wrap",
        ],
    )
    @pytest.mark.parametrize("xr_arg, np_arg", _PAD_XR_NP_ARGS)
    def test_pad(self, mode, xr_arg, np_arg):
>       super().test_pad(mode, xr_arg, np_arg)

/home/swe-bench/pydata__xarray/xarray/tests/test_variable.py:2157: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/home/swe-bench/pydata__xarray/xarray/tests/test_variable.py:843: in test_pad
    v = self.cls(["x", "y", "z"], data)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <xarray.IndexVariable 'x' (x: 4, y: 3, z: 2)>
array([[[ 0,  1],
        [ 2,  3],
        [ 4,  5]],

       [[ 6,  7]... 11]],

       [[12, 13],
        [14, 15],
        [16, 17]],

       [[18, 19],
        [20, 21],
        [22, 23]]])
dims = ['x', 'y', 'z']
data = array([[[ 0,  1],
        [ 2,  3],
        [ 4,  5]],

       [[ 6,  7],
        [ 8,  9],
        [10, 11]],

       [[12, 13],
        [14, 15],
        [16, 17]],

       [[18, 19],
        [20, 21],
        [22, 23]]])
attrs = None, encoding = None, fastpath = False

    def __init__(self, dims, data, attrs=None, encoding=None, fastpath=False):
        super().__init__(dims, data, attrs, encoding, fastpath)
        if self.ndim != 1:
>           raise ValueError("%s objects must be 1-dimensional" % type(self).__name__)
E           ValueError: IndexVariable objects must be 1-dimensional

/home/swe-bench/pydata__xarray/xarray/core/variable.py:2516: ValueError
___________ TestIndexVariable.test_pad[xr_arg3-np_arg3-linear_ramp] ____________

self = <xarray.tests.test_variable.TestIndexVariable object at 0x77b324441840>
mode = 'linear_ramp', xr_arg = {'x': (3, 1), 'z': (2, 0)}
np_arg = ((3, 1), (0, 0), (2, 0))

    @pytest.mark.xfail
    @pytest.mark.parametrize(
        "mode",
        [
            "mean",
            "median",
            "reflect",
            "edge",
            "linear_ramp",
            "maximum",
            "minimum",
            "symmetric",
            "wrap",
        ],
    )
    @pytest.mark.parametrize("xr_arg, np_arg", _PAD_XR_NP_ARGS)
    def test_pad(self, mode, xr_arg, np_arg):
>       super().test_pad(mode, xr_arg, np_arg)

/home/swe-bench/pydata__xarray/xarray/tests/test_variable.py:2157: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/home/swe-bench/pydata__xarray/xarray/tests/test_variable.py:843: in test_pad
    v = self.cls(["x", "y", "z"], data)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <xarray.IndexVariable 'x' (x: 4, y: 3, z: 2)>
array([[[ 0,  1],
        [ 2,  3],
        [ 4,  5]],

       [[ 6,  7]... 11]],

       [[12, 13],
        [14, 15],
        [16, 17]],

       [[18, 19],
        [20, 21],
        [22, 23]]])
dims = ['x', 'y', 'z']
data = array([[[ 0,  1],
        [ 2,  3],
        [ 4,  5]],

       [[ 6,  7],
        [ 8,  9],
        [10, 11]],

       [[12, 13],
        [14, 15],
        [16, 17]],

       [[18, 19],
        [20, 21],
        [22, 23]]])
attrs = None, encoding = None, fastpath = False

    def __init__(self, dims, data, attrs=None, encoding=None, fastpath=False):
        super().__init__(dims, data, attrs, encoding, fastpath)
        if self.ndim != 1:
>           raise ValueError("%s objects must be 1-dimensional" % type(self).__name__)
E           ValueError: IndexVariable objects must be 1-dimensional

/home/swe-bench/pydata__xarray/xarray/core/variable.py:2516: ValueError
_____________ TestIndexVariable.test_pad[xr_arg3-np_arg3-maximum] ______________

self = <xarray.tests.test_variable.TestIndexVariable object at 0x77b324441900>
mode = 'maximum', xr_arg = {'x': (3, 1), 'z': (2, 0)}
np_arg = ((3, 1), (0, 0), (2, 0))

    @pytest.mark.xfail
    @pytest.mark.parametrize(
        "mode",
        [
            "mean",
            "median",
            "reflect",
            "edge",
            "linear_ramp",
            "maximum",
            "minimum",
            "symmetric",
            "wrap",
        ],
    )
    @pytest.mark.parametrize("xr_arg, np_arg", _PAD_XR_NP_ARGS)
    def test_pad(self, mode, xr_arg, np_arg):
>       super().test_pad(mode, xr_arg, np_arg)

/home/swe-bench/pydata__xarray/xarray/tests/test_variable.py:2157: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/home/swe-bench/pydata__xarray/xarray/tests/test_variable.py:843: in test_pad
    v = self.cls(["x", "y", "z"], data)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <xarray.IndexVariable 'x' (x: 4, y: 3, z: 2)>
array([[[ 0,  1],
        [ 2,  3],
        [ 4,  5]],

       [[ 6,  7]... 11]],

       [[12, 13],
        [14, 15],
        [16, 17]],

       [[18, 19],
        [20, 21],
        [22, 23]]])
dims = ['x', 'y', 'z']
data = array([[[ 0,  1],
        [ 2,  3],
        [ 4,  5]],

       [[ 6,  7],
        [ 8,  9],
        [10, 11]],

       [[12, 13],
        [14, 15],
        [16, 17]],

       [[18, 19],
        [20, 21],
        [22, 23]]])
attrs = None, encoding = None, fastpath = False

    def __init__(self, dims, data, attrs=None, encoding=None, fastpath=False):
        super().__init__(dims, data, attrs, encoding, fastpath)
        if self.ndim != 1:
>           raise ValueError("%s objects must be 1-dimensional" % type(self).__name__)
E           ValueError: IndexVariable objects must be 1-dimensional

/home/swe-bench/pydata__xarray/xarray/core/variable.py:2516: ValueError
_____________ TestIndexVariable.test_pad[xr_arg3-np_arg3-minimum] ______________

self = <xarray.tests.test_variable.TestIndexVariable object at 0x77b3244419c0>
mode = 'minimum', xr_arg = {'x': (3, 1), 'z': (2, 0)}
np_arg = ((3, 1), (0, 0), (2, 0))

    @pytest.mark.xfail
    @pytest.mark.parametrize(
        "mode",
        [
            "mean",
            "median",
            "reflect",
            "edge",
            "linear_ramp",
            "maximum",
            "minimum",
            "symmetric",
            "wrap",
        ],
    )
    @pytest.mark.parametrize("xr_arg, np_arg", _PAD_XR_NP_ARGS)
    def test_pad(self, mode, xr_arg, np_arg):
>       super().test_pad(mode, xr_arg, np_arg)

/home/swe-bench/pydata__xarray/xarray/tests/test_variable.py:2157: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/home/swe-bench/pydata__xarray/xarray/tests/test_variable.py:843: in test_pad
    v = self.cls(["x", "y", "z"], data)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <xarray.IndexVariable 'x' (x: 4, y: 3, z: 2)>
array([[[ 0,  1],
        [ 2,  3],
        [ 4,  5]],

       [[ 6,  7]... 11]],

       [[12, 13],
        [14, 15],
        [16, 17]],

       [[18, 19],
        [20, 21],
        [22, 23]]])
dims = ['x', 'y', 'z']
data = array([[[ 0,  1],
        [ 2,  3],
        [ 4,  5]],

       [[ 6,  7],
        [ 8,  9],
        [10, 11]],

       [[12, 13],
        [14, 15],
        [16, 17]],

       [[18, 19],
        [20, 21],
        [22, 23]]])
attrs = None, encoding = None, fastpath = False

    def __init__(self, dims, data, attrs=None, encoding=None, fastpath=False):
        super().__init__(dims, data, attrs, encoding, fastpath)
        if self.ndim != 1:
>           raise ValueError("%s objects must be 1-dimensional" % type(self).__name__)
E           ValueError: IndexVariable objects must be 1-dimensional

/home/swe-bench/pydata__xarray/xarray/core/variable.py:2516: ValueError
____________ TestIndexVariable.test_pad[xr_arg3-np_arg3-symmetric] _____________

self = <xarray.tests.test_variable.TestIndexVariable object at 0x77b324441a80>
mode = 'symmetric', xr_arg = {'x': (3, 1), 'z': (2, 0)}
np_arg = ((3, 1), (0, 0), (2, 0))

    @pytest.mark.xfail
    @pytest.mark.parametrize(
        "mode",
        [
            "mean",
            "median",
            "reflect",
            "edge",
            "linear_ramp",
            "maximum",
            "minimum",
            "symmetric",
            "wrap",
        ],
    )
    @pytest.mark.parametrize("xr_arg, np_arg", _PAD_XR_NP_ARGS)
    def test_pad(self, mode, xr_arg, np_arg):
>       super().test_pad(mode, xr_arg, np_arg)

/home/swe-bench/pydata__xarray/xarray/tests/test_variable.py:2157: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/home/swe-bench/pydata__xarray/xarray/tests/test_variable.py:843: in test_pad
    v = self.cls(["x", "y", "z"], data)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <xarray.IndexVariable 'x' (x: 4, y: 3, z: 2)>
array([[[ 0,  1],
        [ 2,  3],
        [ 4,  5]],

       [[ 6,  7]... 11]],

       [[12, 13],
        [14, 15],
        [16, 17]],

       [[18, 19],
        [20, 21],
        [22, 23]]])
dims = ['x', 'y', 'z']
data = array([[[ 0,  1],
        [ 2,  3],
        [ 4,  5]],

       [[ 6,  7],
        [ 8,  9],
        [10, 11]],

       [[12, 13],
        [14, 15],
        [16, 17]],

       [[18, 19],
        [20, 21],
        [22, 23]]])
attrs = None, encoding = None, fastpath = False

    def __init__(self, dims, data, attrs=None, encoding=None, fastpath=False):
        super().__init__(dims, data, attrs, encoding, fastpath)
        if self.ndim != 1:
>           raise ValueError("%s objects must be 1-dimensional" % type(self).__name__)
E           ValueError: IndexVariable objects must be 1-dimensional

/home/swe-bench/pydata__xarray/xarray/core/variable.py:2516: ValueError
_______________ TestIndexVariable.test_pad[xr_arg3-np_arg3-wrap] _______________

self = <xarray.tests.test_variable.TestIndexVariable object at 0x77b324441b40>
mode = 'wrap', xr_arg = {'x': (3, 1), 'z': (2, 0)}
np_arg = ((3, 1), (0, 0), (2, 0))

    @pytest.mark.xfail
    @pytest.mark.parametrize(
        "mode",
        [
            "mean",
            "median",
            "reflect",
            "edge",
            "linear_ramp",
            "maximum",
            "minimum",
            "symmetric",
            "wrap",
        ],
    )
    @pytest.mark.parametrize("xr_arg, np_arg", _PAD_XR_NP_ARGS)
    def test_pad(self, mode, xr_arg, np_arg):
>       super().test_pad(mode, xr_arg, np_arg)

/home/swe-bench/pydata__xarray/xarray/tests/test_variable.py:2157: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/home/swe-bench/pydata__xarray/xarray/tests/test_variable.py:843: in test_pad
    v = self.cls(["x", "y", "z"], data)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <xarray.IndexVariable 'x' (x: 4, y: 3, z: 2)>
array([[[ 0,  1],
        [ 2,  3],
        [ 4,  5]],

       [[ 6,  7]... 11]],

       [[12, 13],
        [14, 15],
        [16, 17]],

       [[18, 19],
        [20, 21],
        [22, 23]]])
dims = ['x', 'y', 'z']
data = array([[[ 0,  1],
        [ 2,  3],
        [ 4,  5]],

       [[ 6,  7],
        [ 8,  9],
        [10, 11]],

       [[12, 13],
        [14, 15],
        [16, 17]],

       [[18, 19],
        [20, 21],
        [22, 23]]])
attrs = None, encoding = None, fastpath = False

    def __init__(self, dims, data, attrs=None, encoding=None, fastpath=False):
        super().__init__(dims, data, attrs, encoding, fastpath)
        if self.ndim != 1:
>           raise ValueError("%s objects must be 1-dimensional" % type(self).__name__)
E           ValueError: IndexVariable objects must be 1-dimensional

/home/swe-bench/pydata__xarray/xarray/core/variable.py:2516: ValueError
_______________ TestIndexVariable.test_pad[xr_arg4-np_arg4-mean] _______________

self = <xarray.tests.test_variable.TestIndexVariable object at 0x77b324441c00>
mode = 'mean', xr_arg = {'x': (3, 1), 'z': 2}, np_arg = ((3, 1), (0, 0), (2, 2))

    @pytest.mark.xfail
    @pytest.mark.parametrize(
        "mode",
        [
            "mean",
            "median",
            "reflect",
            "edge",
            "linear_ramp",
            "maximum",
            "minimum",
            "symmetric",
            "wrap",
        ],
    )
    @pytest.mark.parametrize("xr_arg, np_arg", _PAD_XR_NP_ARGS)
    def test_pad(self, mode, xr_arg, np_arg):
>       super().test_pad(mode, xr_arg, np_arg)

/home/swe-bench/pydata__xarray/xarray/tests/test_variable.py:2157: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/home/swe-bench/pydata__xarray/xarray/tests/test_variable.py:843: in test_pad
    v = self.cls(["x", "y", "z"], data)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <xarray.IndexVariable 'x' (x: 4, y: 3, z: 2)>
array([[[ 0,  1],
        [ 2,  3],
        [ 4,  5]],

       [[ 6,  7]... 11]],

       [[12, 13],
        [14, 15],
        [16, 17]],

       [[18, 19],
        [20, 21],
        [22, 23]]])
dims = ['x', 'y', 'z']
data = array([[[ 0,  1],
        [ 2,  3],
        [ 4,  5]],

       [[ 6,  7],
        [ 8,  9],
        [10, 11]],

       [[12, 13],
        [14, 15],
        [16, 17]],

       [[18, 19],
        [20, 21],
        [22, 23]]])
attrs = None, encoding = None, fastpath = False

    def __init__(self, dims, data, attrs=None, encoding=None, fastpath=False):
        super().__init__(dims, data, attrs, encoding, fastpath)
        if self.ndim != 1:
>           raise ValueError("%s objects must be 1-dimensional" % type(self).__name__)
E           ValueError: IndexVariable objects must be 1-dimensional

/home/swe-bench/pydata__xarray/xarray/core/variable.py:2516: ValueError
______________ TestIndexVariable.test_pad[xr_arg4-np_arg4-median] ______________

self = <xarray.tests.test_variable.TestIndexVariable object at 0x77b324441cc0>
mode = 'median', xr_arg = {'x': (3, 1), 'z': 2}
np_arg = ((3, 1), (0, 0), (2, 2))

    @pytest.mark.xfail
    @pytest.mark.parametrize(
        "mode",
        [
            "mean",
            "median",
            "reflect",
            "edge",
            "linear_ramp",
            "maximum",
            "minimum",
            "symmetric",
            "wrap",
        ],
    )
    @pytest.mark.parametrize("xr_arg, np_arg", _PAD_XR_NP_ARGS)
    def test_pad(self, mode, xr_arg, np_arg):
>       super().test_pad(mode, xr_arg, np_arg)

/home/swe-bench/pydata__xarray/xarray/tests/test_variable.py:2157: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/home/swe-bench/pydata__xarray/xarray/tests/test_variable.py:843: in test_pad
    v = self.cls(["x", "y", "z"], data)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <xarray.IndexVariable 'x' (x: 4, y: 3, z: 2)>
array([[[ 0,  1],
        [ 2,  3],
        [ 4,  5]],

       [[ 6,  7]... 11]],

       [[12, 13],
        [14, 15],
        [16, 17]],

       [[18, 19],
        [20, 21],
        [22, 23]]])
dims = ['x', 'y', 'z']
data = array([[[ 0,  1],
        [ 2,  3],
        [ 4,  5]],

       [[ 6,  7],
        [ 8,  9],
        [10, 11]],

       [[12, 13],
        [14, 15],
        [16, 17]],

       [[18, 19],
        [20, 21],
        [22, 23]]])
attrs = None, encoding = None, fastpath = False

    def __init__(self, dims, data, attrs=None, encoding=None, fastpath=False):
        super().__init__(dims, data, attrs, encoding, fastpath)
        if self.ndim != 1:
>           raise ValueError("%s objects must be 1-dimensional" % type(self).__name__)
E           ValueError: IndexVariable objects must be 1-dimensional

/home/swe-bench/pydata__xarray/xarray/core/variable.py:2516: ValueError
_____________ TestIndexVariable.test_pad[xr_arg4-np_arg4-reflect] ______________

self = <xarray.tests.test_variable.TestIndexVariable object at 0x77b324441d80>
mode = 'reflect', xr_arg = {'x': (3, 1), 'z': 2}
np_arg = ((3, 1), (0, 0), (2, 2))

    @pytest.mark.xfail
    @pytest.mark.parametrize(
        "mode",
        [
            "mean",
            "median",
            "reflect",
            "edge",
            "linear_ramp",
            "maximum",
            "minimum",
            "symmetric",
            "wrap",
        ],
    )
    @pytest.mark.parametrize("xr_arg, np_arg", _PAD_XR_NP_ARGS)
    def test_pad(self, mode, xr_arg, np_arg):
>       super().test_pad(mode, xr_arg, np_arg)

/home/swe-bench/pydata__xarray/xarray/tests/test_variable.py:2157: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/home/swe-bench/pydata__xarray/xarray/tests/test_variable.py:843: in test_pad
    v = self.cls(["x", "y", "z"], data)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <xarray.IndexVariable 'x' (x: 4, y: 3, z: 2)>
array([[[ 0,  1],
        [ 2,  3],
        [ 4,  5]],

       [[ 6,  7]... 11]],

       [[12, 13],
        [14, 15],
        [16, 17]],

       [[18, 19],
        [20, 21],
        [22, 23]]])
dims = ['x', 'y', 'z']
data = array([[[ 0,  1],
        [ 2,  3],
        [ 4,  5]],

       [[ 6,  7],
        [ 8,  9],
        [10, 11]],

       [[12, 13],
        [14, 15],
        [16, 17]],

       [[18, 19],
        [20, 21],
        [22, 23]]])
attrs = None, encoding = None, fastpath = False

    def __init__(self, dims, data, attrs=None, encoding=None, fastpath=False):
        super().__init__(dims, data, attrs, encoding, fastpath)
        if self.ndim != 1:
>           raise ValueError("%s objects must be 1-dimensional" % type(self).__name__)
E           ValueError: IndexVariable objects must be 1-dimensional

/home/swe-bench/pydata__xarray/xarray/core/variable.py:2516: ValueError
_______________ TestIndexVariable.test_pad[xr_arg4-np_arg4-edge] _______________

self = <xarray.tests.test_variable.TestIndexVariable object at 0x77b324441e40>
mode = 'edge', xr_arg = {'x': (3, 1), 'z': 2}, np_arg = ((3, 1), (0, 0), (2, 2))

    @pytest.mark.xfail
    @pytest.mark.parametrize(
        "mode",
        [
            "mean",
            "median",
            "reflect",
            "edge",
            "linear_ramp",
            "maximum",
            "minimum",
            "symmetric",
            "wrap",
        ],
    )
    @pytest.mark.parametrize("xr_arg, np_arg", _PAD_XR_NP_ARGS)
    def test_pad(self, mode, xr_arg, np_arg):
>       super().test_pad(mode, xr_arg, np_arg)

/home/swe-bench/pydata__xarray/xarray/tests/test_variable.py:2157: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/home/swe-bench/pydata__xarray/xarray/tests/test_variable.py:843: in test_pad
    v = self.cls(["x", "y", "z"], data)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <xarray.IndexVariable 'x' (x: 4, y: 3, z: 2)>
array([[[ 0,  1],
        [ 2,  3],
        [ 4,  5]],

       [[ 6,  7]... 11]],

       [[12, 13],
        [14, 15],
        [16, 17]],

       [[18, 19],
        [20, 21],
        [22, 23]]])
dims = ['x', 'y', 'z']
data = array([[[ 0,  1],
        [ 2,  3],
        [ 4,  5]],

       [[ 6,  7],
        [ 8,  9],
        [10, 11]],

       [[12, 13],
        [14, 15],
        [16, 17]],

       [[18, 19],
        [20, 21],
        [22, 23]]])
attrs = None, encoding = None, fastpath = False

    def __init__(self, dims, data, attrs=None, encoding=None, fastpath=False):
        super().__init__(dims, data, attrs, encoding, fastpath)
        if self.ndim != 1:
>           raise ValueError("%s objects must be 1-dimensional" % type(self).__name__)
E           ValueError: IndexVariable objects must be 1-dimensional

/home/swe-bench/pydata__xarray/xarray/core/variable.py:2516: ValueError
___________ TestIndexVariable.test_pad[xr_arg4-np_arg4-linear_ramp] ____________

self = <xarray.tests.test_variable.TestIndexVariable object at 0x77b324441f00>
mode = 'linear_ramp', xr_arg = {'x': (3, 1), 'z': 2}
np_arg = ((3, 1), (0, 0), (2, 2))

    @pytest.mark.xfail
    @pytest.mark.parametrize(
        "mode",
        [
            "mean",
            "median",
            "reflect",
            "edge",
            "linear_ramp",
            "maximum",
            "minimum",
            "symmetric",
            "wrap",
        ],
    )
    @pytest.mark.parametrize("xr_arg, np_arg", _PAD_XR_NP_ARGS)
    def test_pad(self, mode, xr_arg, np_arg):
>       super().test_pad(mode, xr_arg, np_arg)

/home/swe-bench/pydata__xarray/xarray/tests/test_variable.py:2157: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/home/swe-bench/pydata__xarray/xarray/tests/test_variable.py:843: in test_pad
    v = self.cls(["x", "y", "z"], data)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <xarray.IndexVariable 'x' (x: 4, y: 3, z: 2)>
array([[[ 0,  1],
        [ 2,  3],
        [ 4,  5]],

       [[ 6,  7]... 11]],

       [[12, 13],
        [14, 15],
        [16, 17]],

       [[18, 19],
        [20, 21],
        [22, 23]]])
dims = ['x', 'y', 'z']
data = array([[[ 0,  1],
        [ 2,  3],
        [ 4,  5]],

       [[ 6,  7],
        [ 8,  9],
        [10, 11]],

       [[12, 13],
        [14, 15],
        [16, 17]],

       [[18, 19],
        [20, 21],
        [22, 23]]])
attrs = None, encoding = None, fastpath = False

    def __init__(self, dims, data, attrs=None, encoding=None, fastpath=False):
        super().__init__(dims, data, attrs, encoding, fastpath)
        if self.ndim != 1:
>           raise ValueError("%s objects must be 1-dimensional" % type(self).__name__)
E           ValueError: IndexVariable objects must be 1-dimensional

/home/swe-bench/pydata__xarray/xarray/core/variable.py:2516: ValueError
_____________ TestIndexVariable.test_pad[xr_arg4-np_arg4-maximum] ______________

self = <xarray.tests.test_variable.TestIndexVariable object at 0x77b324441fc0>
mode = 'maximum', xr_arg = {'x': (3, 1), 'z': 2}
np_arg = ((3, 1), (0, 0), (2, 2))

    @pytest.mark.xfail
    @pytest.mark.parametrize(
        "mode",
        [
            "mean",
            "median",
            "reflect",
            "edge",
            "linear_ramp",
            "maximum",
            "minimum",
            "symmetric",
            "wrap",
        ],
    )
    @pytest.mark.parametrize("xr_arg, np_arg", _PAD_XR_NP_ARGS)
    def test_pad(self, mode, xr_arg, np_arg):
>       super().test_pad(mode, xr_arg, np_arg)

/home/swe-bench/pydata__xarray/xarray/tests/test_variable.py:2157: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/home/swe-bench/pydata__xarray/xarray/tests/test_variable.py:843: in test_pad
    v = self.cls(["x", "y", "z"], data)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <xarray.IndexVariable 'x' (x: 4, y: 3, z: 2)>
array([[[ 0,  1],
        [ 2,  3],
        [ 4,  5]],

       [[ 6,  7]... 11]],

       [[12, 13],
        [14, 15],
        [16, 17]],

       [[18, 19],
        [20, 21],
        [22, 23]]])
dims = ['x', 'y', 'z']
data = array([[[ 0,  1],
        [ 2,  3],
        [ 4,  5]],

       [[ 6,  7],
        [ 8,  9],
        [10, 11]],

       [[12, 13],
        [14, 15],
        [16, 17]],

       [[18, 19],
        [20, 21],
        [22, 23]]])
attrs = None, encoding = None, fastpath = False

    def __init__(self, dims, data, attrs=None, encoding=None, fastpath=False):
        super().__init__(dims, data, attrs, encoding, fastpath)
        if self.ndim != 1:
>           raise ValueError("%s objects must be 1-dimensional" % type(self).__name__)
E           ValueError: IndexVariable objects must be 1-dimensional

/home/swe-bench/pydata__xarray/xarray/core/variable.py:2516: ValueError
_____________ TestIndexVariable.test_pad[xr_arg4-np_arg4-minimum] ______________

self = <xarray.tests.test_variable.TestIndexVariable object at 0x77b324442080>
mode = 'minimum', xr_arg = {'x': (3, 1), 'z': 2}
np_arg = ((3, 1), (0, 0), (2, 2))

    @pytest.mark.xfail
    @pytest.mark.parametrize(
        "mode",
        [
            "mean",
            "median",
            "reflect",
            "edge",
            "linear_ramp",
            "maximum",
            "minimum",
            "symmetric",
            "wrap",
        ],
    )
    @pytest.mark.parametrize("xr_arg, np_arg", _PAD_XR_NP_ARGS)
    def test_pad(self, mode, xr_arg, np_arg):
>       super().test_pad(mode, xr_arg, np_arg)

/home/swe-bench/pydata__xarray/xarray/tests/test_variable.py:2157: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/home/swe-bench/pydata__xarray/xarray/tests/test_variable.py:843: in test_pad
    v = self.cls(["x", "y", "z"], data)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <xarray.IndexVariable 'x' (x: 4, y: 3, z: 2)>
array([[[ 0,  1],
        [ 2,  3],
        [ 4,  5]],

       [[ 6,  7]... 11]],

       [[12, 13],
        [14, 15],
        [16, 17]],

       [[18, 19],
        [20, 21],
        [22, 23]]])
dims = ['x', 'y', 'z']
data = array([[[ 0,  1],
        [ 2,  3],
        [ 4,  5]],

       [[ 6,  7],
        [ 8,  9],
        [10, 11]],

       [[12, 13],
        [14, 15],
        [16, 17]],

       [[18, 19],
        [20, 21],
        [22, 23]]])
attrs = None, encoding = None, fastpath = False

    def __init__(self, dims, data, attrs=None, encoding=None, fastpath=False):
        super().__init__(dims, data, attrs, encoding, fastpath)
        if self.ndim != 1:
>           raise ValueError("%s objects must be 1-dimensional" % type(self).__name__)
E           ValueError: IndexVariable objects must be 1-dimensional

/home/swe-bench/pydata__xarray/xarray/core/variable.py:2516: ValueError
____________ TestIndexVariable.test_pad[xr_arg4-np_arg4-symmetric] _____________

self = <xarray.tests.test_variable.TestIndexVariable object at 0x77b324442140>
mode = 'symmetric', xr_arg = {'x': (3, 1), 'z': 2}
np_arg = ((3, 1), (0, 0), (2, 2))

    @pytest.mark.xfail
    @pytest.mark.parametrize(
        "mode",
        [
            "mean",
            "median",
            "reflect",
            "edge",
            "linear_ramp",
            "maximum",
            "minimum",
            "symmetric",
            "wrap",
        ],
    )
    @pytest.mark.parametrize("xr_arg, np_arg", _PAD_XR_NP_ARGS)
    def test_pad(self, mode, xr_arg, np_arg):
>       super().test_pad(mode, xr_arg, np_arg)

/home/swe-bench/pydata__xarray/xarray/tests/test_variable.py:2157: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/home/swe-bench/pydata__xarray/xarray/tests/test_variable.py:843: in test_pad
    v = self.cls(["x", "y", "z"], data)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <xarray.IndexVariable 'x' (x: 4, y: 3, z: 2)>
array([[[ 0,  1],
        [ 2,  3],
        [ 4,  5]],

       [[ 6,  7]... 11]],

       [[12, 13],
        [14, 15],
        [16, 17]],

       [[18, 19],
        [20, 21],
        [22, 23]]])
dims = ['x', 'y', 'z']
data = array([[[ 0,  1],
        [ 2,  3],
        [ 4,  5]],

       [[ 6,  7],
        [ 8,  9],
        [10, 11]],

       [[12, 13],
        [14, 15],
        [16, 17]],

       [[18, 19],
        [20, 21],
        [22, 23]]])
attrs = None, encoding = None, fastpath = False

    def __init__(self, dims, data, attrs=None, encoding=None, fastpath=False):
        super().__init__(dims, data, attrs, encoding, fastpath)
        if self.ndim != 1:
>           raise ValueError("%s objects must be 1-dimensional" % type(self).__name__)
E           ValueError: IndexVariable objects must be 1-dimensional

/home/swe-bench/pydata__xarray/xarray/core/variable.py:2516: ValueError
_______________ TestIndexVariable.test_pad[xr_arg4-np_arg4-wrap] _______________

self = <xarray.tests.test_variable.TestIndexVariable object at 0x77b324442200>
mode = 'wrap', xr_arg = {'x': (3, 1), 'z': 2}, np_arg = ((3, 1), (0, 0), (2, 2))

    @pytest.mark.xfail
    @pytest.mark.parametrize(
        "mode",
        [
            "mean",
            "median",
            "reflect",
            "edge",
            "linear_ramp",
            "maximum",
            "minimum",
            "symmetric",
            "wrap",
        ],
    )
    @pytest.mark.parametrize("xr_arg, np_arg", _PAD_XR_NP_ARGS)
    def test_pad(self, mode, xr_arg, np_arg):
>       super().test_pad(mode, xr_arg, np_arg)

/home/swe-bench/pydata__xarray/xarray/tests/test_variable.py:2157: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/home/swe-bench/pydata__xarray/xarray/tests/test_variable.py:843: in test_pad
    v = self.cls(["x", "y", "z"], data)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <xarray.IndexVariable 'x' (x: 4, y: 3, z: 2)>
array([[[ 0,  1],
        [ 2,  3],
        [ 4,  5]],

       [[ 6,  7]... 11]],

       [[12, 13],
        [14, 15],
        [16, 17]],

       [[18, 19],
        [20, 21],
        [22, 23]]])
dims = ['x', 'y', 'z']
data = array([[[ 0,  1],
        [ 2,  3],
        [ 4,  5]],

       [[ 6,  7],
        [ 8,  9],
        [10, 11]],

       [[12, 13],
        [14, 15],
        [16, 17]],

       [[18, 19],
        [20, 21],
        [22, 23]]])
attrs = None, encoding = None, fastpath = False

    def __init__(self, dims, data, attrs=None, encoding=None, fastpath=False):
        super().__init__(dims, data, attrs, encoding, fastpath)
        if self.ndim != 1:
>           raise ValueError("%s objects must be 1-dimensional" % type(self).__name__)
E           ValueError: IndexVariable objects must be 1-dimensional

/home/swe-bench/pydata__xarray/xarray/core/variable.py:2516: ValueError
_________ TestIndexVariable.test_pad_constant_values[xr_arg0-np_arg0] __________

self = <xarray.tests.test_variable.TestIndexVariable object at 0x77b3244424a0>
xr_arg = {'x': (2, 1)}, np_arg = ((2, 1), (0, 0), (0, 0))

    @pytest.mark.xfail
    @pytest.mark.parametrize("xr_arg, np_arg", _PAD_XR_NP_ARGS)
    def test_pad_constant_values(self, xr_arg, np_arg):
>       super().test_pad_constant_values(xr_arg, np_arg)

/home/swe-bench/pydata__xarray/xarray/tests/test_variable.py:2162: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/home/swe-bench/pydata__xarray/xarray/tests/test_variable.py:854: in test_pad_constant_values
    v = self.cls(["x", "y", "z"], data)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <xarray.IndexVariable 'x' (x: 4, y: 3, z: 2)>
array([[[ 0,  1],
        [ 2,  3],
        [ 4,  5]],

       [[ 6,  7]... 11]],

       [[12, 13],
        [14, 15],
        [16, 17]],

       [[18, 19],
        [20, 21],
        [22, 23]]])
dims = ['x', 'y', 'z']
data = array([[[ 0,  1],
        [ 2,  3],
        [ 4,  5]],

       [[ 6,  7],
        [ 8,  9],
        [10, 11]],

       [[12, 13],
        [14, 15],
        [16, 17]],

       [[18, 19],
        [20, 21],
        [22, 23]]])
attrs = None, encoding = None, fastpath = False

    def __init__(self, dims, data, attrs=None, encoding=None, fastpath=False):
        super().__init__(dims, data, attrs, encoding, fastpath)
        if self.ndim != 1:
>           raise ValueError("%s objects must be 1-dimensional" % type(self).__name__)
E           ValueError: IndexVariable objects must be 1-dimensional

/home/swe-bench/pydata__xarray/xarray/core/variable.py:2516: ValueError
_________ TestIndexVariable.test_pad_constant_values[xr_arg1-np_arg1] __________

self = <xarray.tests.test_variable.TestIndexVariable object at 0x77b3244425c0>
xr_arg = {'x': 1}, np_arg = ((1, 1), (0, 0), (0, 0))

    @pytest.mark.xfail
    @pytest.mark.parametrize("xr_arg, np_arg", _PAD_XR_NP_ARGS)
    def test_pad_constant_values(self, xr_arg, np_arg):
>       super().test_pad_constant_values(xr_arg, np_arg)

/home/swe-bench/pydata__xarray/xarray/tests/test_variable.py:2162: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/home/swe-bench/pydata__xarray/xarray/tests/test_variable.py:854: in test_pad_constant_values
    v = self.cls(["x", "y", "z"], data)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <xarray.IndexVariable 'x' (x: 4, y: 3, z: 2)>
array([[[ 0,  1],
        [ 2,  3],
        [ 4,  5]],

       [[ 6,  7]... 11]],

       [[12, 13],
        [14, 15],
        [16, 17]],

       [[18, 19],
        [20, 21],
        [22, 23]]])
dims = ['x', 'y', 'z']
data = array([[[ 0,  1],
        [ 2,  3],
        [ 4,  5]],

       [[ 6,  7],
        [ 8,  9],
        [10, 11]],

       [[12, 13],
        [14, 15],
        [16, 17]],

       [[18, 19],
        [20, 21],
        [22, 23]]])
attrs = None, encoding = None, fastpath = False

    def __init__(self, dims, data, attrs=None, encoding=None, fastpath=False):
        super().__init__(dims, data, attrs, encoding, fastpath)
        if self.ndim != 1:
>           raise ValueError("%s objects must be 1-dimensional" % type(self).__name__)
E           ValueError: IndexVariable objects must be 1-dimensional

/home/swe-bench/pydata__xarray/xarray/core/variable.py:2516: ValueError
_________ TestIndexVariable.test_pad_constant_values[xr_arg2-np_arg2] __________

self = <xarray.tests.test_variable.TestIndexVariable object at 0x77b324442860>
xr_arg = {'y': (0, 3)}, np_arg = ((0, 0), (0, 3), (0, 0))

    @pytest.mark.xfail
    @pytest.mark.parametrize("xr_arg, np_arg", _PAD_XR_NP_ARGS)
    def test_pad_constant_values(self, xr_arg, np_arg):
>       super().test_pad_constant_values(xr_arg, np_arg)

/home/swe-bench/pydata__xarray/xarray/tests/test_variable.py:2162: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/home/swe-bench/pydata__xarray/xarray/tests/test_variable.py:854: in test_pad_constant_values
    v = self.cls(["x", "y", "z"], data)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <xarray.IndexVariable 'x' (x: 4, y: 3, z: 2)>
array([[[ 0,  1],
        [ 2,  3],
        [ 4,  5]],

       [[ 6,  7]... 11]],

       [[12, 13],
        [14, 15],
        [16, 17]],

       [[18, 19],
        [20, 21],
        [22, 23]]])
dims = ['x', 'y', 'z']
data = array([[[ 0,  1],
        [ 2,  3],
        [ 4,  5]],

       [[ 6,  7],
        [ 8,  9],
        [10, 11]],

       [[12, 13],
        [14, 15],
        [16, 17]],

       [[18, 19],
        [20, 21],
        [22, 23]]])
attrs = None, encoding = None, fastpath = False

    def __init__(self, dims, data, attrs=None, encoding=None, fastpath=False):
        super().__init__(dims, data, attrs, encoding, fastpath)
        if self.ndim != 1:
>           raise ValueError("%s objects must be 1-dimensional" % type(self).__name__)
E           ValueError: IndexVariable objects must be 1-dimensional

/home/swe-bench/pydata__xarray/xarray/core/variable.py:2516: ValueError
_________ TestIndexVariable.test_pad_constant_values[xr_arg3-np_arg3] __________

self = <xarray.tests.test_variable.TestIndexVariable object at 0x77b324442920>
xr_arg = {'x': (3, 1), 'z': (2, 0)}, np_arg = ((3, 1), (0, 0), (2, 0))

    @pytest.mark.xfail
    @pytest.mark.parametrize("xr_arg, np_arg", _PAD_XR_NP_ARGS)
    def test_pad_constant_values(self, xr_arg, np_arg):
>       super().test_pad_constant_values(xr_arg, np_arg)

/home/swe-bench/pydata__xarray/xarray/tests/test_variable.py:2162: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/home/swe-bench/pydata__xarray/xarray/tests/test_variable.py:854: in test_pad_constant_values
    v = self.cls(["x", "y", "z"], data)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <xarray.IndexVariable 'x' (x: 4, y: 3, z: 2)>
array([[[ 0,  1],
        [ 2,  3],
        [ 4,  5]],

       [[ 6,  7]... 11]],

       [[12, 13],
        [14, 15],
        [16, 17]],

       [[18, 19],
        [20, 21],
        [22, 23]]])
dims = ['x', 'y', 'z']
data = array([[[ 0,  1],
        [ 2,  3],
        [ 4,  5]],

       [[ 6,  7],
        [ 8,  9],
        [10, 11]],

       [[12, 13],
        [14, 15],
        [16, 17]],

       [[18, 19],
        [20, 21],
        [22, 23]]])
attrs = None, encoding = None, fastpath = False

    def __init__(self, dims, data, attrs=None, encoding=None, fastpath=False):
        super().__init__(dims, data, attrs, encoding, fastpath)
        if self.ndim != 1:
>           raise ValueError("%s objects must be 1-dimensional" % type(self).__name__)
E           ValueError: IndexVariable objects must be 1-dimensional

/home/swe-bench/pydata__xarray/xarray/core/variable.py:2516: ValueError
_________ TestIndexVariable.test_pad_constant_values[xr_arg4-np_arg4] __________

self = <xarray.tests.test_variable.TestIndexVariable object at 0x77b3244429e0>
xr_arg = {'x': (3, 1), 'z': 2}, np_arg = ((3, 1), (0, 0), (2, 2))

    @pytest.mark.xfail
    @pytest.mark.parametrize("xr_arg, np_arg", _PAD_XR_NP_ARGS)
    def test_pad_constant_values(self, xr_arg, np_arg):
>       super().test_pad_constant_values(xr_arg, np_arg)

/home/swe-bench/pydata__xarray/xarray/tests/test_variable.py:2162: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/home/swe-bench/pydata__xarray/xarray/tests/test_variable.py:854: in test_pad_constant_values
    v = self.cls(["x", "y", "z"], data)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <xarray.IndexVariable 'x' (x: 4, y: 3, z: 2)>
array([[[ 0,  1],
        [ 2,  3],
        [ 4,  5]],

       [[ 6,  7]... 11]],

       [[12, 13],
        [14, 15],
        [16, 17]],

       [[18, 19],
        [20, 21],
        [22, 23]]])
dims = ['x', 'y', 'z']
data = array([[[ 0,  1],
        [ 2,  3],
        [ 4,  5]],

       [[ 6,  7],
        [ 8,  9],
        [10, 11]],

       [[12, 13],
        [14, 15],
        [16, 17]],

       [[18, 19],
        [20, 21],
        [22, 23]]])
attrs = None, encoding = None, fastpath = False

    def __init__(self, dims, data, attrs=None, encoding=None, fastpath=False):
        super().__init__(dims, data, attrs, encoding, fastpath)
        if self.ndim != 1:
>           raise ValueError("%s objects must be 1-dimensional" % type(self).__name__)
E           ValueError: IndexVariable objects must be 1-dimensional

/home/swe-bench/pydata__xarray/xarray/core/variable.py:2516: ValueError
____________________ TestIndexVariable.test_rolling_window _____________________

self = <xarray.tests.test_variable.TestIndexVariable object at 0x77b324442c20>

    @pytest.mark.xfail
    def test_rolling_window(self):
>       super().test_rolling_window()

/home/swe-bench/pydata__xarray/xarray/tests/test_variable.py:2166: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/home/swe-bench/pydata__xarray/xarray/tests/test_variable.py:878: in test_rolling_window
    v = self.cls(["x", "y", "z"], np.arange(40 * 30 * 2).reshape(40, 30, 2))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <xarray.IndexVariable 'x' (x: 40, y: 30, z: 2)>
array([[[   0,    1],
        [   2,    3],
        [   4,    5],
    ...   [2342, 2343],
        [2344, 2345],
        ...,
        [2394, 2395],
        [2396, 2397],
        [2398, 2399]]])
dims = ['x', 'y', 'z']
data = array([[[   0,    1],
        [   2,    3],
        [   4,    5],
        ...,
        [  54,   55],
        [  56,   ...   [2342, 2343],
        [2344, 2345],
        ...,
        [2394, 2395],
        [2396, 2397],
        [2398, 2399]]])
attrs = None, encoding = None, fastpath = False

    def __init__(self, dims, data, attrs=None, encoding=None, fastpath=False):
        super().__init__(dims, data, attrs, encoding, fastpath)
        if self.ndim != 1:
>           raise ValueError("%s objects must be 1-dimensional" % type(self).__name__)
E           ValueError: IndexVariable objects must be 1-dimensional

/home/swe-bench/pydata__xarray/xarray/core/variable.py:2516: ValueError
______________________ TestIndexVariable.test_coarsen_2d _______________________

self = <xarray.tests.test_variable.TestIndexVariable object at 0x77b324442e90>

    @pytest.mark.xfail
    def test_coarsen_2d(self):
>       super().test_coarsen_2d()
E       AttributeError: 'super' object has no attribute 'test_coarsen_2d'

/home/swe-bench/pydata__xarray/xarray/tests/test_variable.py:2170: AttributeError
=============================== warnings summary ===============================
xarray/__init__.py:1
  /home/swe-bench/pydata__xarray/xarray/__init__.py:1: DeprecationWarning: pkg_resources is deprecated as an API. See https://setuptools.pypa.io/en/latest/pkg_resources.html
    import pkg_resources

../miniconda3/envs/pydata__xarray__0.12/lib/python3.10/site-packages/pkg_resources/__init__.py:2832
  /home/swe-bench/miniconda3/envs/pydata__xarray__0.12/lib/python3.10/site-packages/pkg_resources/__init__.py:2832: DeprecationWarning: Deprecated call to `pkg_resources.declare_namespace('pydap')`.
  Implementing implicit namespace packages (as specified in PEP 420) is preferred to `pkg_resources.declare_namespace`. See https://setuptools.pypa.io/en/latest/references/keywords.html#keyword-namespace-packages
    declare_namespace(pkg)

../miniconda3/envs/pydata__xarray__0.12/lib/python3.10/site-packages/pkg_resources/__init__.py:2832
  /home/swe-bench/miniconda3/envs/pydata__xarray__0.12/lib/python3.10/site-packages/pkg_resources/__init__.py:2832: DeprecationWarning: Deprecated call to `pkg_resources.declare_namespace('pydap.responses')`.
  Implementing implicit namespace packages (as specified in PEP 420) is preferred to `pkg_resources.declare_namespace`. See https://setuptools.pypa.io/en/latest/references/keywords.html#keyword-namespace-packages
    declare_namespace(pkg)

../miniconda3/envs/pydata__xarray__0.12/lib/python3.10/site-packages/pkg_resources/__init__.py:2317
../miniconda3/envs/pydata__xarray__0.12/lib/python3.10/site-packages/pkg_resources/__init__.py:2317
../miniconda3/envs/pydata__xarray__0.12/lib/python3.10/site-packages/pkg_resources/__init__.py:2317
  /home/swe-bench/miniconda3/envs/pydata__xarray__0.12/lib/python3.10/site-packages/pkg_resources/__init__.py:2317: DeprecationWarning: Deprecated call to `pkg_resources.declare_namespace('pydap')`.
  Implementing implicit namespace packages (as specified in PEP 420) is preferred to `pkg_resources.declare_namespace`. See https://setuptools.pypa.io/en/latest/references/keywords.html#keyword-namespace-packages
    declare_namespace(parent)

../miniconda3/envs/pydata__xarray__0.12/lib/python3.10/site-packages/pkg_resources/__init__.py:2832
  /home/swe-bench/miniconda3/envs/pydata__xarray__0.12/lib/python3.10/site-packages/pkg_resources/__init__.py:2832: DeprecationWarning: Deprecated call to `pkg_resources.declare_namespace('pydap.handlers')`.
  Implementing implicit namespace packages (as specified in PEP 420) is preferred to `pkg_resources.declare_namespace`. See https://setuptools.pypa.io/en/latest/references/keywords.html#keyword-namespace-packages
    declare_namespace(pkg)

../miniconda3/envs/pydata__xarray__0.12/lib/python3.10/site-packages/pkg_resources/__init__.py:2832
  /home/swe-bench/miniconda3/envs/pydata__xarray__0.12/lib/python3.10/site-packages/pkg_resources/__init__.py:2832: DeprecationWarning: Deprecated call to `pkg_resources.declare_namespace('pydap.tests')`.
  Implementing implicit namespace packages (as specified in PEP 420) is preferred to `pkg_resources.declare_namespace`. See https://setuptools.pypa.io/en/latest/references/keywords.html#keyword-namespace-packages
    declare_namespace(pkg)

xarray/core/dask_array_compat.py:61
xarray/core/dask_array_compat.py:61
  /home/swe-bench/pydata__xarray/xarray/core/dask_array_compat.py:61: DeprecationWarning: distutils Version classes are deprecated. Use packaging.version instead.
    if LooseVersion(dask_version) > LooseVersion("2.9.0"):

xarray/core/pdcompat.py:45
  /home/swe-bench/pydata__xarray/xarray/core/pdcompat.py:45: DeprecationWarning: distutils Version classes are deprecated. Use packaging.version instead.
    if LooseVersion(pd.__version__) < "0.25.0":

../miniconda3/envs/pydata__xarray__0.12/lib/python3.10/site-packages/setuptools/_distutils/version.py:337: 7 warnings
xarray/tests/test_dataset.py: 4 warnings
xarray/tests/test_variable.py: 14 warnings
  /home/swe-bench/miniconda3/envs/pydata__xarray__0.12/lib/python3.10/site-packages/setuptools/_distutils/version.py:337: DeprecationWarning: distutils Version classes are deprecated. Use packaging.version instead.
    other = LooseVersion(other)

xarray/tests/__init__.py:59
xarray/tests/__init__.py:59
xarray/tests/__init__.py:59
xarray/tests/__init__.py:59
xarray/tests/__init__.py:59
xarray/tests/__init__.py:59
xarray/tests/__init__.py:59
  /home/swe-bench/pydata__xarray/xarray/tests/__init__.py:59: DeprecationWarning: distutils Version classes are deprecated. Use packaging.version instead.
    return version.LooseVersion(vstring)

xarray/tests/test_dask.py:587
  /home/swe-bench/pydata__xarray/xarray/tests/test_dask.py:587: DeprecationWarning: distutils Version classes are deprecated. Use packaging.version instead.
    @pytest.mark.skipif(LooseVersion(dask.__version__) >= "2.0", reason="no meta")

xarray/tests/test_dask.py:605
  /home/swe-bench/pydata__xarray/xarray/tests/test_dask.py:605: DeprecationWarning: distutils Version classes are deprecated. Use packaging.version instead.
    @pytest.mark.skipif(LooseVersion(dask.__version__) < "2.0", reason="needs meta")

xarray/tests/test_dask.py:623
  /home/swe-bench/pydata__xarray/xarray/tests/test_dask.py:623: DeprecationWarning: distutils Version classes are deprecated. Use packaging.version instead.
    @pytest.mark.skipif(LooseVersion(dask.__version__) < "2.0", reason="needs meta")

xarray/tests/test_dask.py::TestVariable::test_chunk
  /home/swe-bench/pydata__xarray/xarray/core/variable.py:1062: FutureWarning: None value for 'chunks' is deprecated. It will raise an error in the future. Use instead '{}'
    warnings.warn(

xarray/tests/test_dask.py::TestDataArrayAndDataset::test_groupby
xarray/tests/test_dask.py::TestDataArrayAndDataset::test_groupby
xarray/tests/test_dataset.py::TestDataset::test_groupby
xarray/tests/test_dataset.py::TestDataset::test_groupby
xarray/tests/test_dataset.py::TestDataset::test_groupby
xarray/tests/test_dataset.py::TestDataset::test_groupby_math
xarray/tests/test_dataset.py::TestDataset::test_groupby_math
  /home/swe-bench/pydata__xarray/xarray/core/groupby.py:207: FutureWarning: is_monotonic is deprecated and will be removed in a future version. Use is_monotonic_increasing instead.
    return index.is_unique and index.is_monotonic

xarray/tests/test_dask.py: 4 warnings
xarray/tests/test_dataset.py: 4 warnings
xarray/tests/test_interp.py: 139 warnings
  /home/swe-bench/miniconda3/envs/pydata__xarray__0.12/lib/python3.10/site-packages/pandas/core/dtypes/cast.py:1641: DeprecationWarning: np.find_common_type is deprecated.  Please use `np.result_type` or `np.promote_types`.
  See https://numpy.org/devdocs/release/1.25.0-notes.html and the docs for more information.  (Deprecated NumPy 1.25)
    return np.find_common_type(types, [])

xarray/tests/test_dask.py: 4 warnings
xarray/tests/test_dataset.py: 25 warnings
xarray/tests/test_variable.py: 10 warnings
  /home/swe-bench/miniconda3/envs/pydata__xarray__0.12/lib/python3.10/site-packages/pandas/core/indexes/multi.py:643: DeprecationWarning: `cumproduct` is deprecated as of NumPy 1.25.0, and will be removed in NumPy 2.0. Please use `cumprod` instead.
    codes = cartesian_product(codes)

xarray/tests/test_dask.py: 8 warnings
xarray/tests/test_dataset.py: 51 warnings
xarray/tests/test_variable.py: 23 warnings
  /home/swe-bench/miniconda3/envs/pydata__xarray__0.12/lib/python3.10/site-packages/pandas/core/reshape/util.py:60: DeprecationWarning: `product` is deprecated as of NumPy 1.25.0, and will be removed in NumPy 2.0. Please use `prod` instead.
    return [

xarray/tests/test_dask.py::test_map_blocks_kwargs[obj1]
xarray/tests/test_dataset.py::TestDataset::test_unstack
xarray/tests/test_dataset.py::TestDataset::test_unstack
xarray/tests/test_dataset.py::TestDataset::test_unstack
xarray/tests/test_dataset.py::TestDataset::test_stack_unstack_fast
xarray/tests/test_dataset.py::TestDataset::test_stack_unstack_fast
xarray/tests/test_dataset.py::TestDataset::test_stack_unstack_slow
xarray/tests/test_dataset.py::TestDataset::test_stack_unstack_slow
  /home/swe-bench/miniconda3/envs/pydata__xarray__0.12/lib/python3.10/site-packages/numpy/core/numeric.py:407: RuntimeWarning: invalid value encountered in cast
    multiarray.copyto(res, fill_value, casting='unsafe')

xarray/tests/test_dataset.py::TestDataset::test_constructor_pandas_single
  /home/swe-bench/pydata__xarray/xarray/core/merge.py:394: FutureWarning: iteritems is deprecated and will be removed in a future version. Use .items instead.
    obj = dict(obj.iteritems())

xarray/tests/test_dataset.py: 4 warnings
xarray/tests/test_variable.py: 14 warnings
  /home/swe-bench/pydata__xarray/xarray/core/variable.py:1088: DeprecationWarning: distutils Version classes are deprecated. Use packaging.version instead.
    if LooseVersion(dask.__version__) < "2.0.0":

xarray/tests/test_dataset.py: 48 warnings
  /home/swe-bench/pydata__xarray/xarray/core/dataset.py:3864: DeprecationWarning: distutils Version classes are deprecated. Use packaging.version instead.
    or LooseVersion(np.__version__) < LooseVersion("1.17")

xarray/tests/test_dataset.py::TestDataset::test_sel_method
xarray/tests/test_dataset.py::TestDataset::test_sel_method
xarray/tests/test_dataset.py::TestDataset::test_sel_method
xarray/tests/test_interp.py::test_interpolate_dimorder[3]
  /home/swe-bench/pydata__xarray/xarray/core/indexing.py:191: FutureWarning: Passing method to Float64Index.get_loc is deprecated and will raise in a future version. Use index.get_indexer([item], method=...) instead.
    indexer = index.get_loc(label_value, method=method, tolerance=tolerance)

xarray/tests/test_dataset.py: 14 warnings
xarray/tests/test_interp.py: 34 warnings
  /home/swe-bench/pydata__xarray/xarray/coding/cftimeindex.py:122: DeprecationWarning: distutils Version classes are deprecated. Use packaging.version instead.
    if LooseVersion(cftime.__version__) < LooseVersion("1.0.4"):

xarray/tests/test_dataset.py: 54 warnings
xarray/tests/test_interp.py: 10 warnings
  /home/swe-bench/pydata__xarray/xarray/coding/cftime_offsets.py:242: DeprecationWarning: distutils Version classes are deprecated. Use packaging.version instead.
    if LooseVersion(cftime.__version__) < LooseVersion("1.0.4"):

xarray/tests/test_dataset.py: 13 warnings
  /home/swe-bench/pydata__xarray/xarray/core/groupby.py:349: FutureWarning: is_monotonic is deprecated and will be removed in a future version. Use is_monotonic_increasing instead.
    if not index.is_monotonic:

xarray/tests/test_dataset.py::TestDataset::test_resample_loffset
  /home/swe-bench/pydata__xarray/xarray/tests/test_dataset.py:3904: FutureWarning: 'loffset' in .resample() and in Grouper() is deprecated.
  
  >>> df.resample(freq="3s", loffset="8H")
  
  becomes:
  
  >>> from pandas.tseries.frequencies import to_offset
  >>> df = df.resample(freq="3s").mean()
  >>> df.index = df.index.to_timestamp() + to_offset("8H")
  
    ds.bar.to_series().resample("24H", loffset="-12H").mean()

xarray/tests/test_dataset.py::TestDataset::test_resample_drop_nondim_coords
xarray/tests/test_interp.py::test_datetime[x_new0-expected0]
xarray/tests/test_interp.py::test_datetime[x_new1-expected1]
xarray/tests/test_interp.py::test_datetime[x_new2-expected2]
xarray/tests/test_interp.py::test_datetime[x_new3-expected3]
xarray/tests/test_interp.py::test_datetime[x_new4-0.5]
xarray/tests/test_interp.py::test_datetime[2000-01-01T12:00-0.5]
xarray/tests/test_interp.py::test_datetime_single_string
xarray/tests/test_interp.py::test_datetime_interp_noerror
  /home/swe-bench/pydata__xarray/xarray/core/missing.py:548: DeprecationWarning: distutils Version classes are deprecated. Use packaging.version instead.
    if np.issubdtype(new_x.dtype, np.datetime64) and LooseVersion(

xarray/tests/test_dataset.py::TestDataset::test_resample_drop_nondim_coords
xarray/tests/test_interp.py::test_datetime[x_new0-expected0]
xarray/tests/test_interp.py::test_datetime[x_new1-expected1]
xarray/tests/test_interp.py::test_datetime[x_new2-expected2]
xarray/tests/test_interp.py::test_datetime[x_new3-expected3]
xarray/tests/test_interp.py::test_datetime[x_new4-0.5]
xarray/tests/test_interp.py::test_datetime[2000-01-01T12:00-0.5]
xarray/tests/test_interp.py::test_datetime_single_string
xarray/tests/test_interp.py::test_datetime_interp_noerror
  /home/swe-bench/pydata__xarray/xarray/core/missing.py:550: DeprecationWarning: distutils Version classes are deprecated. Use packaging.version instead.
    ) < LooseVersion("1.18"):

xarray/tests/test_dataset.py::TestDataset::test_resample_drop_nondim_coords
xarray/tests/test_interp.py::test_datetime[x_new0-expected0]
xarray/tests/test_interp.py::test_datetime[x_new1-expected1]
xarray/tests/test_interp.py::test_datetime[x_new2-expected2]
xarray/tests/test_interp.py::test_datetime[x_new3-expected3]
xarray/tests/test_interp.py::test_datetime[x_new4-0.5]
xarray/tests/test_interp.py::test_datetime[2000-01-01T12:00-0.5]
xarray/tests/test_interp.py::test_datetime_single_string
xarray/tests/test_interp.py::test_datetime_interp_noerror
  /home/swe-bench/pydata__xarray/xarray/core/missing.py:559: FutureWarning: Passing method to DatetimeIndex.get_loc is deprecated and will raise in a future version. Use index.get_indexer([item], method=...) instead.
    imin = index.get_loc(minval, method="nearest")

xarray/tests/test_dataset.py::TestDataset::test_resample_drop_nondim_coords
xarray/tests/test_interp.py::test_datetime[x_new0-expected0]
xarray/tests/test_interp.py::test_datetime[x_new1-expected1]
xarray/tests/test_interp.py::test_datetime[x_new2-expected2]
xarray/tests/test_interp.py::test_datetime[x_new3-expected3]
xarray/tests/test_interp.py::test_datetime[x_new4-0.5]
xarray/tests/test_interp.py::test_datetime[2000-01-01T12:00-0.5]
xarray/tests/test_interp.py::test_datetime_single_string
xarray/tests/test_interp.py::test_datetime_interp_noerror
  /home/swe-bench/pydata__xarray/xarray/core/missing.py:560: FutureWarning: Passing method to DatetimeIndex.get_loc is deprecated and will raise in a future version. Use index.get_indexer([item], method=...) instead.
    imax = index.get_loc(maxval, method="nearest")

xarray/tests/test_dataset.py::TestDataset::test_from_dataframe_sparse
  /home/swe-bench/pydata__xarray/xarray/core/dataset.py:5017: FutureWarning: MultiIndex.is_lexsorted is deprecated as a public function, users should use MultiIndex.is_monotonic_increasing instead.
    is_sorted = idx.is_lexsorted()

xarray/tests/test_dataset.py: 64 warnings
xarray/tests/test_variable.py: 16 warnings
  /home/swe-bench/pydata__xarray/xarray/core/computation.py:724: DeprecationWarning: the `interpolation=` argument to nanquantile was renamed to `method=`, which has additional options.
  Users of the modes 'nearest', 'lower', 'higher', or 'midpoint' are encouraged to review the method they used. (Deprecated NumPy 1.22)
    result_data = func(*input_data)

xarray/tests/test_dataset.py: 64 warnings
xarray/tests/test_variable.py: 12 warnings
  /home/swe-bench/pydata__xarray/xarray/core/computation.py:724: DeprecationWarning: the `interpolation=` argument to quantile was renamed to `method=`, which has additional options.
  Users of the modes 'nearest', 'lower', 'higher', or 'midpoint' are encouraged to review the method they used. (Deprecated NumPy 1.22)
    result_data = func(*input_data)

xarray/tests/test_dataset.py::TestDataset::test_unary_ops
  /home/swe-bench/pydata__xarray/xarray/core/duck_array_ops.py:180: RuntimeWarning: invalid value encountered in cast
    return data.astype(dtype, **kwargs)

xarray/tests/test_dataset.py::test_coarsen_coords[1-True]
xarray/tests/test_dataset.py::test_coarsen_coords[1-False]
  /home/swe-bench/pydata__xarray/xarray/tests/test_dataset.py:6012: UserWarning: Parsing dates in DD/MM/YYYY format when dayfirst=False (the default) was specified. This may lead to inconsistently parsed dates! Specify a format to ensure consistent parsing.
    coords={"time": pd.date_range("15/12/1999", periods=364)},

xarray/tests/test_dataset.py::test_trapz_datetime[np-True]
xarray/tests/test_dataset.py::test_trapz_datetime[cftime-True]
  /home/swe-bench/miniconda3/envs/pydata__xarray__0.12/lib/python3.10/site-packages/dask/array/core.py:1712: FutureWarning: The `numpy.trapz` function is not implemented by Dask array. You may want to use the da.map_blocks function or something similar to silence this warning. Your code may stop working in a future release.
    warnings.warn(

xarray/tests/test_interp.py: 3766 warnings
  /home/swe-bench/pydata__xarray/xarray/core/missing.py:559: FutureWarning: Passing method to Float64Index.get_loc is deprecated and will raise in a future version. Use index.get_indexer([item], method=...) instead.
    imin = index.get_loc(minval, method="nearest")

xarray/tests/test_interp.py: 3696 warnings
  /home/swe-bench/pydata__xarray/xarray/core/missing.py:560: FutureWarning: Passing method to Float64Index.get_loc is deprecated and will raise in a future version. Use index.get_indexer([item], method=...) instead.
    imax = index.get_loc(maxval, method="nearest")

xarray/tests/test_interp.py: 20 warnings
  /home/swe-bench/pydata__xarray/xarray/core/missing.py:559: FutureWarning: Passing method to Int64Index.get_loc is deprecated and will raise in a future version. Use index.get_indexer([item], method=...) instead.
    imin = index.get_loc(minval, method="nearest")

xarray/tests/test_interp.py: 20 warnings
  /home/swe-bench/pydata__xarray/xarray/core/missing.py:560: FutureWarning: Passing method to Int64Index.get_loc is deprecated and will raise in a future version. Use index.get_indexer([item], method=...) instead.
    imax = index.get_loc(maxval, method="nearest")

xarray/tests/test_interp.py::test_cftime
xarray/tests/test_interp.py::test_cftime
xarray/tests/test_interp.py::test_cftime_type_error
xarray/tests/test_interp.py::test_cftime_list_of_strings
xarray/tests/test_interp.py::test_cftime_list_of_strings
xarray/tests/test_interp.py::test_cftime_single_string
xarray/tests/test_interp.py::test_cftime_single_string
xarray/tests/test_interp.py::test_3641
xarray/tests/test_interp.py::test_3641
  /home/swe-bench/pydata__xarray/xarray/coding/cftimeindex.py:460: FutureWarning: Passing method to CFTimeIndex.get_loc is deprecated and will raise in a future version. Use index.get_indexer([item], method=...) instead.
    return pd.Index.get_loc(self, key, method=method, tolerance=tolerance)

xarray/tests/test_interp.py::test_interpolate_chunk_advanced[linear]
xarray/tests/test_interp.py::test_interpolate_chunk_advanced[nearest]
  /home/swe-bench/pydata__xarray/xarray/core/missing.py:637: PerformanceWarning: Increasing number of chunks by factor of 35
    interped = interp_func(

xarray/tests/test_interp.py::test_interpolate_chunk_advanced[linear]
xarray/tests/test_interp.py::test_interpolate_chunk_advanced[nearest]
  /home/swe-bench/pydata__xarray/xarray/core/missing.py:740: PerformanceWarning: Increasing number of chunks by factor of 35
    return da.blockwise(

xarray/tests/test_variable.py: 12 warnings
  /home/swe-bench/pydata__xarray/xarray/core/computation.py:705: DeprecationWarning: distutils Version classes are deprecated. Use packaging.version instead.
    if LooseVersion(dask_version) < LooseVersion("2.17.0"):

xarray/tests/test_variable.py: 30 warnings
  /home/swe-bench/miniconda3/envs/pydata__xarray__0.12/lib/python3.10/site-packages/dask/core.py:127: DeprecationWarning: the `interpolation=` argument to nanquantile was renamed to `method=`, which has additional options.
  Users of the modes 'nearest', 'lower', 'higher', or 'midpoint' are encouraged to review the method they used. (Deprecated NumPy 1.22)
    return func(*(_execute_task(a, cache) for a in args))

-- Docs: https://docs.pytest.org/en/stable/how-to/capture-warnings.html
==================================== PASSES ====================================
____________________________ TestDataset.test_repr _____________________________
----------------------------- Captured stdout call -----------------------------
<xarray.Dataset>
Dimensions:  (dim1: 8, dim2: 9, dim3: 10, time: 20)
Coordinates:
  * time     (time) datetime64[ns] 2000-01-01 2000-01-02 ... 2000-01-20
  * dim2     (dim2) float64 0.0 0.5 1.0 1.5 2.0 2.5 3.0 3.5 4.0
  * dim3     (dim3) <U1 'a' 'b' 'c' 'd' 'e' 'f' 'g' 'h' 'i' 'j'
    numbers  (dim3) int64 0 1 2 0 0 1 1 2 2 3
Dimensions without coordinates: dim1
Data variables:
    var1     (dim1, dim2) float64 -1.086 0.9973 0.283 ... 0.1995 0.4684 -0.8312
    var2     (dim1, dim2) float64 1.162 -1.097 -2.123 ... 0.1302 1.267 0.3328
    var3     (dim3, dim1) float64 0.5565 -0.2121 0.4563 ... -0.2452 -0.3616
Attributes:
    foo:      bar
<xarray.Dataset>
Dimensions:  ()
Data variables:
    *empty*
<xarray.Dataset>
Dimensions:  ()
Data variables:
    foo      float64 1.0
_______________________ TestDataset.test_repr_multiindex _______________________
----------------------------- Captured stdout call -----------------------------
<xarray.Dataset>
Dimensions:  (x: 4)
Coordinates:
  * x        (x) MultiIndex
  - level_1  (x) object 'a' 'a' 'b' 'b'
  - level_2  (x) int64 1 2 1 2
Data variables:
    *empty*
<xarray.Dataset>
Dimensions:                  (x: 4)
Coordinates:
  * x                        (x) MultiIndex
  - a_quite_long_level_name  (x) object 'a' 'a' 'b' 'b'
  - level_2                  (x) int64 1 2 1 2
Data variables:
    *empty*
_______________________ TestDataset.test_constructor_0d ________________________
----------------------------- Captured stdout call -----------------------------
True
None
3.4
nan
hello
b'raw'
2000-01-01
2000-01-01 12:00:00
2000-01-01 12:00:00
<xarray.tests.test_dataset.TestDataset.test_constructor_0d.<locals>.Arbitrary object at 0x77b324b71fc0>
__________________ TestVariable.test_pandas_cateogrical_dtype __________________
----------------------------- Captured stdout call -----------------------------
<xarray.Variable (x: 10)>
array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])
_________________ TestVariable.test_pandas_datetime64_with_tz __________________
----------------------------- Captured stdout call -----------------------------
<xarray.Variable (x: 10)>
array([946702800000000000, 946706400000000000, 946710000000000000,
       946713600000000000, 946717200000000000, 946720800000000000,
       946724400000000000, 946728000000000000, 946731600000000000,
       946735200000000000], dtype=object)
______________ TestVariableWithDask.test_pandas_cateogrical_dtype ______________
----------------------------- Captured stdout call -----------------------------
<xarray.Variable (x: 10)>
dask.array<array, shape=(10,), dtype=int64, chunksize=(10,), chunktype=numpy.ndarray>
_____________ TestVariableWithDask.test_pandas_datetime64_with_tz ______________
----------------------------- Captured stdout call -----------------------------
<xarray.Variable (x: 10)>
dask.array<array, shape=(10,), dtype=object, chunksize=(10,), chunktype=numpy.ndarray>
_______________ TestIndexVariable.test_pandas_cateogrical_dtype ________________
----------------------------- Captured stdout call -----------------------------
<xarray.IndexVariable 'x' (x: 10)>
array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])
_______________ TestIndexVariable.test_pandas_datetime64_with_tz _______________
----------------------------- Captured stdout call -----------------------------
<xarray.IndexVariable 'x' (x: 10)>
array([946702800000000000, 946706400000000000, 946710000000000000,
       946713600000000000, 946717200000000000, 946720800000000000,
       946724400000000000, 946728000000000000, 946731600000000000,
       946735200000000000], dtype=object)
=================================== XPASSES ====================================
=========================== short test summary info ============================
PASSED xarray/tests/test_dask.py::test_raise_if_dask_computes
PASSED xarray/tests/test_dask.py::TestVariable::test_basics
PASSED xarray/tests/test_dask.py::TestVariable::test_copy
PASSED xarray/tests/test_dask.py::TestVariable::test_chunk
PASSED xarray/tests/test_dask.py::TestVariable::test_indexing
PASSED xarray/tests/test_dask.py::TestVariable::test_squeeze
PASSED xarray/tests/test_dask.py::TestVariable::test_equals
PASSED xarray/tests/test_dask.py::TestVariable::test_transpose
PASSED xarray/tests/test_dask.py::TestVariable::test_shift
PASSED xarray/tests/test_dask.py::TestVariable::test_roll
PASSED xarray/tests/test_dask.py::TestVariable::test_unary_op
PASSED xarray/tests/test_dask.py::TestVariable::test_binary_op
PASSED xarray/tests/test_dask.py::TestVariable::test_repr
PASSED xarray/tests/test_dask.py::TestVariable::test_pickle
PASSED xarray/tests/test_dask.py::TestVariable::test_reduce
PASSED xarray/tests/test_dask.py::TestVariable::test_missing_values
PASSED xarray/tests/test_dask.py::TestVariable::test_concat
PASSED xarray/tests/test_dask.py::TestVariable::test_missing_methods
PASSED xarray/tests/test_dask.py::TestVariable::test_univariate_ufunc
PASSED xarray/tests/test_dask.py::TestVariable::test_bivariate_ufunc
PASSED xarray/tests/test_dask.py::TestVariable::test_compute
PASSED xarray/tests/test_dask.py::TestVariable::test_persist
PASSED xarray/tests/test_dask.py::TestVariable::test_tokenize_duck_dask_array
PASSED xarray/tests/test_dask.py::TestDataArrayAndDataset::test_rechunk
PASSED xarray/tests/test_dask.py::TestDataArrayAndDataset::test_new_chunk
PASSED xarray/tests/test_dask.py::TestDataArrayAndDataset::test_lazy_dataset
PASSED xarray/tests/test_dask.py::TestDataArrayAndDataset::test_lazy_array
PASSED xarray/tests/test_dask.py::TestDataArrayAndDataset::test_compute
PASSED xarray/tests/test_dask.py::TestDataArrayAndDataset::test_persist
PASSED xarray/tests/test_dask.py::TestDataArrayAndDataset::test_concat_loads_variables
PASSED xarray/tests/test_dask.py::TestDataArrayAndDataset::test_groupby
PASSED xarray/tests/test_dask.py::TestDataArrayAndDataset::test_rolling
PASSED xarray/tests/test_dask.py::TestDataArrayAndDataset::test_groupby_first
PASSED xarray/tests/test_dask.py::TestDataArrayAndDataset::test_reindex
PASSED xarray/tests/test_dask.py::TestDataArrayAndDataset::test_to_dataset_roundtrip
PASSED xarray/tests/test_dask.py::TestDataArrayAndDataset::test_merge
PASSED xarray/tests/test_dask.py::TestDataArrayAndDataset::test_ufuncs
PASSED xarray/tests/test_dask.py::TestDataArrayAndDataset::test_where_dispatching
PASSED xarray/tests/test_dask.py::TestDataArrayAndDataset::test_simultaneous_compute
PASSED xarray/tests/test_dask.py::TestDataArrayAndDataset::test_stack
PASSED xarray/tests/test_dask.py::TestDataArrayAndDataset::test_dot
PASSED xarray/tests/test_dask.py::TestDataArrayAndDataset::test_dataarray_repr
PASSED xarray/tests/test_dask.py::TestDataArrayAndDataset::test_dataset_repr
PASSED xarray/tests/test_dask.py::TestDataArrayAndDataset::test_dataarray_pickle
PASSED xarray/tests/test_dask.py::TestDataArrayAndDataset::test_dataset_pickle
PASSED xarray/tests/test_dask.py::TestDataArrayAndDataset::test_dataarray_getattr
PASSED xarray/tests/test_dask.py::TestDataArrayAndDataset::test_dataset_getattr
PASSED xarray/tests/test_dask.py::TestDataArrayAndDataset::test_values
PASSED xarray/tests/test_dask.py::TestDataArrayAndDataset::test_from_dask_variable
PASSED xarray/tests/test_dask.py::TestDataArrayAndDataset::test_tokenize_duck_dask_array
PASSED xarray/tests/test_dask.py::TestToDaskDataFrame::test_to_dask_dataframe
PASSED xarray/tests/test_dask.py::TestToDaskDataFrame::test_to_dask_dataframe_2D
PASSED xarray/tests/test_dask.py::TestToDaskDataFrame::test_to_dask_dataframe_coordinates
PASSED xarray/tests/test_dask.py::TestToDaskDataFrame::test_to_dask_dataframe_not_daskarray
PASSED xarray/tests/test_dask.py::TestToDaskDataFrame::test_to_dask_dataframe_no_coordinate
PASSED xarray/tests/test_dask.py::TestToDaskDataFrame::test_to_dask_dataframe_dim_order
PASSED xarray/tests/test_dask.py::test_dask_kwargs_variable[load]
PASSED xarray/tests/test_dask.py::test_dask_kwargs_variable[compute]
PASSED xarray/tests/test_dask.py::test_dask_kwargs_dataarray[load]
PASSED xarray/tests/test_dask.py::test_dask_kwargs_dataarray[compute]
PASSED xarray/tests/test_dask.py::test_dask_kwargs_dataarray[persist]
PASSED xarray/tests/test_dask.py::test_dask_kwargs_dataset[load]
PASSED xarray/tests/test_dask.py::test_dask_kwargs_dataset[compute]
PASSED xarray/tests/test_dask.py::test_dask_kwargs_dataset[persist]
PASSED xarray/tests/test_dask.py::test_persist_Dataset[<lambda>0]
PASSED xarray/tests/test_dask.py::test_persist_DataArray[<lambda>0]
PASSED xarray/tests/test_dask.py::test_persist_DataArray[<lambda>1]
PASSED xarray/tests/test_dask.py::test_dataarray_with_dask_coords
PASSED xarray/tests/test_dask.py::test_basic_compute
PASSED xarray/tests/test_dask.py::test_dask_layers_and_dependencies
PASSED xarray/tests/test_dask.py::test_unify_chunks
PASSED xarray/tests/test_dask.py::test_unify_chunks_shallow_copy[<lambda>0-obj0]
PASSED xarray/tests/test_dask.py::test_unify_chunks_shallow_copy[<lambda>0-obj1]
PASSED xarray/tests/test_dask.py::test_unify_chunks_shallow_copy[<lambda>1-obj0]
PASSED xarray/tests/test_dask.py::test_unify_chunks_shallow_copy[<lambda>1-obj1]
PASSED xarray/tests/test_dask.py::test_auto_chunk_da[obj0]
PASSED xarray/tests/test_dask.py::test_make_meta
PASSED xarray/tests/test_dask.py::test_identical_coords_no_computes
PASSED xarray/tests/test_dask.py::test_token_changes_on_transform[<lambda>0-obj0]
PASSED xarray/tests/test_dask.py::test_token_changes_on_transform[<lambda>0-obj1]
PASSED xarray/tests/test_dask.py::test_token_changes_on_transform[<lambda>0-obj2]
PASSED xarray/tests/test_dask.py::test_token_changes_on_transform[<lambda>0-obj3]
PASSED xarray/tests/test_dask.py::test_token_changes_on_transform[<lambda>1-obj0]
PASSED xarray/tests/test_dask.py::test_token_changes_on_transform[<lambda>1-obj1]
PASSED xarray/tests/test_dask.py::test_token_changes_on_transform[<lambda>1-obj2]
PASSED xarray/tests/test_dask.py::test_token_changes_on_transform[<lambda>1-obj3]
PASSED xarray/tests/test_dask.py::test_token_changes_on_transform[<lambda>2-obj0]
PASSED xarray/tests/test_dask.py::test_token_changes_on_transform[<lambda>2-obj1]
PASSED xarray/tests/test_dask.py::test_token_changes_on_transform[<lambda>2-obj2]
PASSED xarray/tests/test_dask.py::test_token_changes_on_transform[<lambda>2-obj3]
PASSED xarray/tests/test_dask.py::test_token_changes_on_transform[<lambda>3-obj0]
PASSED xarray/tests/test_dask.py::test_token_changes_on_transform[<lambda>3-obj1]
PASSED xarray/tests/test_dask.py::test_token_changes_on_transform[<lambda>3-obj2]
PASSED xarray/tests/test_dask.py::test_token_changes_on_transform[<lambda>3-obj3]
PASSED xarray/tests/test_dask.py::test_token_changes_on_transform[<lambda>4-obj0]
PASSED xarray/tests/test_dask.py::test_token_changes_on_transform[<lambda>4-obj1]
PASSED xarray/tests/test_dask.py::test_token_changes_on_transform[<lambda>4-obj2]
PASSED xarray/tests/test_dask.py::test_token_changes_on_transform[<lambda>4-obj3]
PASSED xarray/tests/test_dask.py::test_token_changes_on_transform[<lambda>5-obj0]
PASSED xarray/tests/test_dask.py::test_token_changes_on_transform[<lambda>5-obj1]
PASSED xarray/tests/test_dask.py::test_token_changes_on_transform[<lambda>5-obj2]
PASSED xarray/tests/test_dask.py::test_token_changes_on_transform[<lambda>5-obj3]
PASSED xarray/tests/test_dask.py::test_token_changes_on_transform[<lambda>6-obj0]
PASSED xarray/tests/test_dask.py::test_token_changes_on_transform[<lambda>6-obj1]
PASSED xarray/tests/test_dask.py::test_token_changes_on_transform[<lambda>6-obj2]
PASSED xarray/tests/test_dask.py::test_token_changes_on_transform[<lambda>6-obj3]
PASSED xarray/tests/test_dask.py::test_token_changes_when_data_changes[obj0]
PASSED xarray/tests/test_dask.py::test_token_changes_when_data_changes[obj1]
PASSED xarray/tests/test_dask.py::test_token_changes_when_data_changes[obj2]
PASSED xarray/tests/test_dask.py::test_token_changes_when_data_changes[obj3]
PASSED xarray/tests/test_dask.py::test_token_changes_when_buffer_changes[obj0]
PASSED xarray/tests/test_dask.py::test_token_changes_when_buffer_changes[obj1]
PASSED xarray/tests/test_dask.py::test_token_identical[obj0-<lambda>0]
PASSED xarray/tests/test_dask.py::test_token_identical[obj0-<lambda>1]
PASSED xarray/tests/test_dask.py::test_token_identical[obj0-<lambda>2]
PASSED xarray/tests/test_dask.py::test_token_identical[obj1-<lambda>0]
PASSED xarray/tests/test_dask.py::test_token_identical[obj1-<lambda>1]
PASSED xarray/tests/test_dask.py::test_token_identical[obj1-<lambda>2]
PASSED xarray/tests/test_dask.py::test_token_identical[obj2-<lambda>0]
PASSED xarray/tests/test_dask.py::test_token_identical[obj2-<lambda>1]
PASSED xarray/tests/test_dask.py::test_token_identical[obj2-<lambda>2]
PASSED xarray/tests/test_dask.py::test_recursive_token
PASSED xarray/tests/test_dask.py::test_normalize_token_with_backend
PASSED xarray/tests/test_dask.py::test_lazy_array_equiv_variables[broadcast_equals]
PASSED xarray/tests/test_dask.py::test_lazy_array_equiv_variables[equals]
PASSED xarray/tests/test_dask.py::test_lazy_array_equiv_variables[identical]
PASSED xarray/tests/test_dask.py::test_lazy_array_equiv_variables[no_conflicts]
PASSED xarray/tests/test_dask.py::test_lazy_array_equiv_merge[broadcast_equals]
PASSED xarray/tests/test_dask.py::test_lazy_array_equiv_merge[equals]
PASSED xarray/tests/test_dask.py::test_lazy_array_equiv_merge[identical]
PASSED xarray/tests/test_dask.py::test_lazy_array_equiv_merge[no_conflicts]
PASSED xarray/tests/test_dask.py::test_transforms_pass_lazy_array_equiv[<lambda>0-obj0]
PASSED xarray/tests/test_dask.py::test_transforms_pass_lazy_array_equiv[<lambda>0-obj1]
PASSED xarray/tests/test_dask.py::test_transforms_pass_lazy_array_equiv[<lambda>1-obj0]
PASSED xarray/tests/test_dask.py::test_transforms_pass_lazy_array_equiv[<lambda>1-obj1]
PASSED xarray/tests/test_dask.py::test_transforms_pass_lazy_array_equiv[<lambda>2-obj0]
PASSED xarray/tests/test_dask.py::test_transforms_pass_lazy_array_equiv[<lambda>2-obj1]
PASSED xarray/tests/test_dask.py::test_transforms_pass_lazy_array_equiv[<lambda>3-obj0]
PASSED xarray/tests/test_dask.py::test_transforms_pass_lazy_array_equiv[<lambda>3-obj1]
PASSED xarray/tests/test_dask.py::test_transforms_pass_lazy_array_equiv[<lambda>4-obj0]
PASSED xarray/tests/test_dask.py::test_transforms_pass_lazy_array_equiv[<lambda>4-obj1]
PASSED xarray/tests/test_dask.py::test_transforms_pass_lazy_array_equiv[<lambda>5-obj0]
PASSED xarray/tests/test_dask.py::test_transforms_pass_lazy_array_equiv[<lambda>5-obj1]
PASSED xarray/tests/test_dask.py::test_transforms_pass_lazy_array_equiv[<lambda>6-obj0]
PASSED xarray/tests/test_dask.py::test_transforms_pass_lazy_array_equiv[<lambda>6-obj1]
PASSED xarray/tests/test_dask.py::test_transforms_pass_lazy_array_equiv[<lambda>7-obj0]
PASSED xarray/tests/test_dask.py::test_transforms_pass_lazy_array_equiv[<lambda>7-obj1]
PASSED xarray/tests/test_dask.py::test_transforms_pass_lazy_array_equiv[<lambda>8-obj0]
PASSED xarray/tests/test_dask.py::test_transforms_pass_lazy_array_equiv[<lambda>8-obj1]
PASSED xarray/tests/test_dask.py::test_transforms_pass_lazy_array_equiv[<lambda>9-obj0]
PASSED xarray/tests/test_dask.py::test_transforms_pass_lazy_array_equiv[<lambda>9-obj1]
PASSED xarray/tests/test_dask.py::test_transforms_pass_lazy_array_equiv[<lambda>10-obj0]
PASSED xarray/tests/test_dask.py::test_transforms_pass_lazy_array_equiv[<lambda>10-obj1]
PASSED xarray/tests/test_dask.py::test_transforms_pass_lazy_array_equiv[<lambda>11-obj0]
PASSED xarray/tests/test_dask.py::test_transforms_pass_lazy_array_equiv[<lambda>11-obj1]
PASSED xarray/tests/test_dask.py::test_transforms_pass_lazy_array_equiv[<lambda>12-obj0]
PASSED xarray/tests/test_dask.py::test_transforms_pass_lazy_array_equiv[<lambda>12-obj1]
PASSED xarray/tests/test_dask.py::test_transforms_pass_lazy_array_equiv[<lambda>13-obj0]
PASSED xarray/tests/test_dask.py::test_transforms_pass_lazy_array_equiv[<lambda>13-obj1]
PASSED xarray/tests/test_dask.py::test_transforms_pass_lazy_array_equiv[<lambda>14-obj0]
PASSED xarray/tests/test_dask.py::test_transforms_pass_lazy_array_equiv[<lambda>14-obj1]
PASSED xarray/tests/test_dask.py::test_transforms_pass_lazy_array_equiv[<lambda>15-obj0]
PASSED xarray/tests/test_dask.py::test_transforms_pass_lazy_array_equiv[<lambda>15-obj1]
PASSED xarray/tests/test_dask.py::test_transforms_pass_lazy_array_equiv[<lambda>16-obj0]
PASSED xarray/tests/test_dask.py::test_transforms_pass_lazy_array_equiv[<lambda>16-obj1]
PASSED xarray/tests/test_dask.py::test_transforms_pass_lazy_array_equiv[<lambda>17-obj0]
PASSED xarray/tests/test_dask.py::test_transforms_pass_lazy_array_equiv[<lambda>17-obj1]
PASSED xarray/tests/test_dask.py::test_more_transforms_pass_lazy_array_equiv
PASSED xarray/tests/test_dask.py::test_optimize
PASSED xarray/tests/test_dataset.py::TestDataset::test_repr
PASSED xarray/tests/test_dataset.py::TestDataset::test_repr_multiindex
PASSED xarray/tests/test_dataset.py::TestDataset::test_repr_period_index
PASSED xarray/tests/test_dataset.py::TestDataset::test_unicode_data
PASSED xarray/tests/test_dataset.py::TestDataset::test_repr_nep18
PASSED xarray/tests/test_dataset.py::TestDataset::test_info
PASSED xarray/tests/test_dataset.py::TestDataset::test_constructor
PASSED xarray/tests/test_dataset.py::TestDataset::test_constructor_invalid_dims
PASSED xarray/tests/test_dataset.py::TestDataset::test_constructor_1d
PASSED xarray/tests/test_dataset.py::TestDataset::test_constructor_0d
PASSED xarray/tests/test_dataset.py::TestDataset::test_constructor_deprecated
PASSED xarray/tests/test_dataset.py::TestDataset::test_constructor_auto_align
PASSED xarray/tests/test_dataset.py::TestDataset::test_constructor_pandas_sequence
PASSED xarray/tests/test_dataset.py::TestDataset::test_constructor_pandas_single
PASSED xarray/tests/test_dataset.py::TestDataset::test_constructor_compat
PASSED xarray/tests/test_dataset.py::TestDataset::test_constructor_with_coords
PASSED xarray/tests/test_dataset.py::TestDataset::test_properties
PASSED xarray/tests/test_dataset.py::TestDataset::test_asarray
PASSED xarray/tests/test_dataset.py::TestDataset::test_get_index
PASSED xarray/tests/test_dataset.py::TestDataset::test_attr_access
PASSED xarray/tests/test_dataset.py::TestDataset::test_variable
PASSED xarray/tests/test_dataset.py::TestDataset::test_modify_inplace
PASSED xarray/tests/test_dataset.py::TestDataset::test_coords_properties
PASSED xarray/tests/test_dataset.py::TestDataset::test_coords_modify
PASSED xarray/tests/test_dataset.py::TestDataset::test_update_index
PASSED xarray/tests/test_dataset.py::TestDataset::test_coords_setitem_with_new_dimension
PASSED xarray/tests/test_dataset.py::TestDataset::test_coords_setitem_multiindex
PASSED xarray/tests/test_dataset.py::TestDataset::test_coords_set
PASSED xarray/tests/test_dataset.py::TestDataset::test_coords_to_dataset
PASSED xarray/tests/test_dataset.py::TestDataset::test_coords_merge
PASSED xarray/tests/test_dataset.py::TestDataset::test_coords_merge_mismatched_shape
PASSED xarray/tests/test_dataset.py::TestDataset::test_data_vars_properties
PASSED xarray/tests/test_dataset.py::TestDataset::test_equals_and_identical
PASSED xarray/tests/test_dataset.py::TestDataset::test_equals_failures
PASSED xarray/tests/test_dataset.py::TestDataset::test_broadcast_equals
PASSED xarray/tests/test_dataset.py::TestDataset::test_attrs
PASSED xarray/tests/test_dataset.py::TestDataset::test_chunk
PASSED xarray/tests/test_dataset.py::TestDataset::test_dask_is_lazy
PASSED xarray/tests/test_dataset.py::TestDataset::test_isel
PASSED xarray/tests/test_dataset.py::TestDataset::test_isel_fancy
PASSED xarray/tests/test_dataset.py::TestDataset::test_isel_dataarray
PASSED xarray/tests/test_dataset.py::TestDataset::test_sel
PASSED xarray/tests/test_dataset.py::TestDataset::test_sel_dataarray
PASSED xarray/tests/test_dataset.py::TestDataset::test_sel_dataarray_mindex
PASSED xarray/tests/test_dataset.py::TestDataset::test_categorical_index
PASSED xarray/tests/test_dataset.py::TestDataset::test_categorical_reindex
PASSED xarray/tests/test_dataset.py::TestDataset::test_sel_drop
PASSED xarray/tests/test_dataset.py::TestDataset::test_isel_drop
PASSED xarray/tests/test_dataset.py::TestDataset::test_head
PASSED xarray/tests/test_dataset.py::TestDataset::test_tail
PASSED xarray/tests/test_dataset.py::TestDataset::test_thin
PASSED xarray/tests/test_dataset.py::TestDataset::test_sel_fancy
PASSED xarray/tests/test_dataset.py::TestDataset::test_sel_method
PASSED xarray/tests/test_dataset.py::TestDataset::test_loc
PASSED xarray/tests/test_dataset.py::TestDataset::test_selection_multiindex
PASSED xarray/tests/test_dataset.py::TestDataset::test_broadcast_like
PASSED xarray/tests/test_dataset.py::TestDataset::test_reindex_like
PASSED xarray/tests/test_dataset.py::TestDataset::test_reindex
PASSED xarray/tests/test_dataset.py::TestDataset::test_reindex_variables_copied
PASSED xarray/tests/test_dataset.py::TestDataset::test_reindex_method
PASSED xarray/tests/test_dataset.py::TestDataset::test_reindex_fill_value[fill_value0]
PASSED xarray/tests/test_dataset.py::TestDataset::test_reindex_fill_value[2]
PASSED xarray/tests/test_dataset.py::TestDataset::test_reindex_fill_value[2.0]
PASSED xarray/tests/test_dataset.py::TestDataset::test_reindex_fill_value[fill_value3]
PASSED xarray/tests/test_dataset.py::TestDataset::test_reindex_like_fill_value[fill_value0]
PASSED xarray/tests/test_dataset.py::TestDataset::test_reindex_like_fill_value[2]
PASSED xarray/tests/test_dataset.py::TestDataset::test_reindex_like_fill_value[2.0]
PASSED xarray/tests/test_dataset.py::TestDataset::test_reindex_like_fill_value[fill_value3]
PASSED xarray/tests/test_dataset.py::TestDataset::test_reindex_str_dtype[str]
PASSED xarray/tests/test_dataset.py::TestDataset::test_reindex_str_dtype[bytes]
PASSED xarray/tests/test_dataset.py::TestDataset::test_align_fill_value[fill_value0]
PASSED xarray/tests/test_dataset.py::TestDataset::test_align_fill_value[2]
PASSED xarray/tests/test_dataset.py::TestDataset::test_align_fill_value[2.0]
PASSED xarray/tests/test_dataset.py::TestDataset::test_align_fill_value[fill_value3]
PASSED xarray/tests/test_dataset.py::TestDataset::test_align
PASSED xarray/tests/test_dataset.py::TestDataset::test_align_exact
PASSED xarray/tests/test_dataset.py::TestDataset::test_align_override
PASSED xarray/tests/test_dataset.py::TestDataset::test_align_exclude
PASSED xarray/tests/test_dataset.py::TestDataset::test_align_nocopy
PASSED xarray/tests/test_dataset.py::TestDataset::test_align_indexes
PASSED xarray/tests/test_dataset.py::TestDataset::test_align_non_unique
PASSED xarray/tests/test_dataset.py::TestDataset::test_align_str_dtype
PASSED xarray/tests/test_dataset.py::TestDataset::test_broadcast
PASSED xarray/tests/test_dataset.py::TestDataset::test_broadcast_nocopy
PASSED xarray/tests/test_dataset.py::TestDataset::test_broadcast_exclude
PASSED xarray/tests/test_dataset.py::TestDataset::test_broadcast_misaligned
PASSED xarray/tests/test_dataset.py::TestDataset::test_variable_indexing
PASSED xarray/tests/test_dataset.py::TestDataset::test_drop_variables
PASSED xarray/tests/test_dataset.py::TestDataset::test_drop_labels_by_keyword
PASSED xarray/tests/test_dataset.py::TestDataset::test_drop_labels_by_position
PASSED xarray/tests/test_dataset.py::TestDataset::test_drop_dims
PASSED xarray/tests/test_dataset.py::TestDataset::test_copy
PASSED xarray/tests/test_dataset.py::TestDataset::test_copy_with_data
PASSED xarray/tests/test_dataset.py::TestDataset::test_copy_with_data_errors
PASSED xarray/tests/test_dataset.py::TestDataset::test_rename
PASSED xarray/tests/test_dataset.py::TestDataset::test_rename_old_name
PASSED xarray/tests/test_dataset.py::TestDataset::test_rename_same_name
PASSED xarray/tests/test_dataset.py::TestDataset::test_rename_dims
PASSED xarray/tests/test_dataset.py::TestDataset::test_rename_vars
PASSED xarray/tests/test_dataset.py::TestDataset::test_rename_multiindex
PASSED xarray/tests/test_dataset.py::TestDataset::test_rename_does_not_change_CFTimeIndex_type
PASSED xarray/tests/test_dataset.py::TestDataset::test_rename_does_not_change_DatetimeIndex_type
PASSED xarray/tests/test_dataset.py::TestDataset::test_swap_dims
PASSED xarray/tests/test_dataset.py::TestDataset::test_expand_dims_error
PASSED xarray/tests/test_dataset.py::TestDataset::test_expand_dims_int
PASSED xarray/tests/test_dataset.py::TestDataset::test_expand_dims_coords
PASSED xarray/tests/test_dataset.py::TestDataset::test_expand_dims_existing_scalar_coord
PASSED xarray/tests/test_dataset.py::TestDataset::test_isel_expand_dims_roundtrip
PASSED xarray/tests/test_dataset.py::TestDataset::test_expand_dims_mixed_int_and_coords
PASSED xarray/tests/test_dataset.py::TestDataset::test_expand_dims_kwargs_python36plus
PASSED xarray/tests/test_dataset.py::TestDataset::test_set_index
PASSED xarray/tests/test_dataset.py::TestDataset::test_reset_index
PASSED xarray/tests/test_dataset.py::TestDataset::test_reset_index_keep_attrs
PASSED xarray/tests/test_dataset.py::TestDataset::test_reorder_levels
PASSED xarray/tests/test_dataset.py::TestDataset::test_stack
PASSED xarray/tests/test_dataset.py::TestDataset::test_unstack
PASSED xarray/tests/test_dataset.py::TestDataset::test_unstack_errors
PASSED xarray/tests/test_dataset.py::TestDataset::test_unstack_fill_value
PASSED xarray/tests/test_dataset.py::TestDataset::test_unstack_sparse
PASSED xarray/tests/test_dataset.py::TestDataset::test_stack_unstack_fast
PASSED xarray/tests/test_dataset.py::TestDataset::test_stack_unstack_slow
PASSED xarray/tests/test_dataset.py::TestDataset::test_to_stacked_array_invalid_sample_dims
PASSED xarray/tests/test_dataset.py::TestDataset::test_to_stacked_array_name
PASSED xarray/tests/test_dataset.py::TestDataset::test_to_stacked_array_dtype_dims
PASSED xarray/tests/test_dataset.py::TestDataset::test_to_stacked_array_to_unstacked_dataset
PASSED xarray/tests/test_dataset.py::TestDataset::test_to_stacked_array_to_unstacked_dataset_different_dimension
PASSED xarray/tests/test_dataset.py::TestDataset::test_update
PASSED xarray/tests/test_dataset.py::TestDataset::test_update_overwrite_coords
PASSED xarray/tests/test_dataset.py::TestDataset::test_update_auto_align
PASSED xarray/tests/test_dataset.py::TestDataset::test_getitem
PASSED xarray/tests/test_dataset.py::TestDataset::test_getitem_hashable
PASSED xarray/tests/test_dataset.py::TestDataset::test_virtual_variables_default_coords
PASSED xarray/tests/test_dataset.py::TestDataset::test_virtual_variables_time
PASSED xarray/tests/test_dataset.py::TestDataset::test_virtual_variable_same_name
PASSED xarray/tests/test_dataset.py::TestDataset::test_virtual_variable_multiindex
PASSED xarray/tests/test_dataset.py::TestDataset::test_time_season
PASSED xarray/tests/test_dataset.py::TestDataset::test_slice_virtual_variable
PASSED xarray/tests/test_dataset.py::TestDataset::test_setitem
PASSED xarray/tests/test_dataset.py::TestDataset::test_setitem_pandas
PASSED xarray/tests/test_dataset.py::TestDataset::test_setitem_auto_align
PASSED xarray/tests/test_dataset.py::TestDataset::test_setitem_dimension_override
PASSED xarray/tests/test_dataset.py::TestDataset::test_setitem_with_coords
PASSED xarray/tests/test_dataset.py::TestDataset::test_setitem_align_new_indexes
PASSED xarray/tests/test_dataset.py::TestDataset::test_setitem_str_dtype[str]
PASSED xarray/tests/test_dataset.py::TestDataset::test_setitem_str_dtype[bytes]
PASSED xarray/tests/test_dataset.py::TestDataset::test_assign
PASSED xarray/tests/test_dataset.py::TestDataset::test_assign_coords
PASSED xarray/tests/test_dataset.py::TestDataset::test_assign_attrs
PASSED xarray/tests/test_dataset.py::TestDataset::test_assign_multiindex_level
PASSED xarray/tests/test_dataset.py::TestDataset::test_merge_multiindex_level
PASSED xarray/tests/test_dataset.py::TestDataset::test_setitem_original_non_unique_index
PASSED xarray/tests/test_dataset.py::TestDataset::test_setitem_both_non_unique_index
PASSED xarray/tests/test_dataset.py::TestDataset::test_setitem_multiindex_level
PASSED xarray/tests/test_dataset.py::TestDataset::test_delitem
PASSED xarray/tests/test_dataset.py::TestDataset::test_squeeze
PASSED xarray/tests/test_dataset.py::TestDataset::test_squeeze_drop
PASSED xarray/tests/test_dataset.py::TestDataset::test_groupby
PASSED xarray/tests/test_dataset.py::TestDataset::test_groupby_returns_new_type
PASSED xarray/tests/test_dataset.py::TestDataset::test_groupby_iter
PASSED xarray/tests/test_dataset.py::TestDataset::test_groupby_errors
PASSED xarray/tests/test_dataset.py::TestDataset::test_groupby_reduce
PASSED xarray/tests/test_dataset.py::TestDataset::test_groupby_math
PASSED xarray/tests/test_dataset.py::TestDataset::test_groupby_math_virtual
PASSED xarray/tests/test_dataset.py::TestDataset::test_groupby_nan
PASSED xarray/tests/test_dataset.py::TestDataset::test_groupby_order
PASSED xarray/tests/test_dataset.py::TestDataset::test_resample_and_first
PASSED xarray/tests/test_dataset.py::TestDataset::test_resample_min_count
PASSED xarray/tests/test_dataset.py::TestDataset::test_resample_by_mean_with_keep_attrs
PASSED xarray/tests/test_dataset.py::TestDataset::test_resample_loffset
PASSED xarray/tests/test_dataset.py::TestDataset::test_resample_by_mean_discarding_attrs
PASSED xarray/tests/test_dataset.py::TestDataset::test_resample_by_last_discarding_attrs
PASSED xarray/tests/test_dataset.py::TestDataset::test_resample_drop_nondim_coords
PASSED xarray/tests/test_dataset.py::TestDataset::test_resample_old_api
PASSED xarray/tests/test_dataset.py::TestDataset::test_resample_ds_da_are_the_same
PASSED xarray/tests/test_dataset.py::TestDataset::test_ds_resample_apply_func_args
PASSED xarray/tests/test_dataset.py::TestDataset::test_to_array
PASSED xarray/tests/test_dataset.py::TestDataset::test_to_and_from_dataframe
PASSED xarray/tests/test_dataset.py::TestDataset::test_from_dataframe_sparse
PASSED xarray/tests/test_dataset.py::TestDataset::test_to_and_from_empty_dataframe
PASSED xarray/tests/test_dataset.py::TestDataset::test_from_dataframe_multiindex
PASSED xarray/tests/test_dataset.py::TestDataset::test_from_dataframe_unsorted_levels
PASSED xarray/tests/test_dataset.py::TestDataset::test_from_dataframe_non_unique_columns
PASSED xarray/tests/test_dataset.py::TestDataset::test_convert_dataframe_with_many_types_and_multiindex
PASSED xarray/tests/test_dataset.py::TestDataset::test_to_and_from_dict
PASSED xarray/tests/test_dataset.py::TestDataset::test_to_and_from_dict_with_time_dim
PASSED xarray/tests/test_dataset.py::TestDataset::test_to_and_from_dict_with_nan_nat
PASSED xarray/tests/test_dataset.py::TestDataset::test_to_dict_with_numpy_attrs
PASSED xarray/tests/test_dataset.py::TestDataset::test_pickle
PASSED xarray/tests/test_dataset.py::TestDataset::test_lazy_load
PASSED xarray/tests/test_dataset.py::TestDataset::test_dropna
PASSED xarray/tests/test_dataset.py::TestDataset::test_fillna
PASSED xarray/tests/test_dataset.py::TestDataset::test_propagate_attrs[<lambda>0]
PASSED xarray/tests/test_dataset.py::TestDataset::test_propagate_attrs[<lambda>1]
PASSED xarray/tests/test_dataset.py::TestDataset::test_propagate_attrs[absolute]
PASSED xarray/tests/test_dataset.py::TestDataset::test_propagate_attrs[abs]
PASSED xarray/tests/test_dataset.py::TestDataset::test_where
PASSED xarray/tests/test_dataset.py::TestDataset::test_where_other
PASSED xarray/tests/test_dataset.py::TestDataset::test_where_drop
PASSED xarray/tests/test_dataset.py::TestDataset::test_where_drop_empty
PASSED xarray/tests/test_dataset.py::TestDataset::test_where_drop_no_indexes
PASSED xarray/tests/test_dataset.py::TestDataset::test_reduce
PASSED xarray/tests/test_dataset.py::TestDataset::test_reduce_coords
PASSED xarray/tests/test_dataset.py::TestDataset::test_mean_uint_dtype
PASSED xarray/tests/test_dataset.py::TestDataset::test_reduce_bad_dim
PASSED xarray/tests/test_dataset.py::TestDataset::test_reduce_cumsum
PASSED xarray/tests/test_dataset.py::TestDataset::test_reduce_cumsum_test_dims
PASSED xarray/tests/test_dataset.py::TestDataset::test_reduce_non_numeric
PASSED xarray/tests/test_dataset.py::TestDataset::test_reduce_strings
PASSED xarray/tests/test_dataset.py::TestDataset::test_reduce_dtypes
PASSED xarray/tests/test_dataset.py::TestDataset::test_reduce_keep_attrs
PASSED xarray/tests/test_dataset.py::TestDataset::test_reduce_argmin
PASSED xarray/tests/test_dataset.py::TestDataset::test_reduce_scalars
PASSED xarray/tests/test_dataset.py::TestDataset::test_reduce_only_one_axis
PASSED xarray/tests/test_dataset.py::TestDataset::test_reduce_no_axis
PASSED xarray/tests/test_dataset.py::TestDataset::test_reduce_keepdims
PASSED xarray/tests/test_dataset.py::TestDataset::test_quantile[0.25-True]
PASSED xarray/tests/test_dataset.py::TestDataset::test_quantile[0.25-False]
PASSED xarray/tests/test_dataset.py::TestDataset::test_quantile[q1-True]
PASSED xarray/tests/test_dataset.py::TestDataset::test_quantile[q1-False]
PASSED xarray/tests/test_dataset.py::TestDataset::test_quantile[q2-True]
PASSED xarray/tests/test_dataset.py::TestDataset::test_quantile[q2-False]
PASSED xarray/tests/test_dataset.py::TestDataset::test_quantile_skipna[True]
PASSED xarray/tests/test_dataset.py::TestDataset::test_quantile_skipna[False]
PASSED xarray/tests/test_dataset.py::TestDataset::test_rank
PASSED xarray/tests/test_dataset.py::TestDataset::test_count
PASSED xarray/tests/test_dataset.py::TestDataset::test_map
PASSED xarray/tests/test_dataset.py::TestDataset::test_apply_pending_deprecated_map
PASSED xarray/tests/test_dataset.py::TestDataset::test_dataset_number_math
PASSED xarray/tests/test_dataset.py::TestDataset::test_unary_ops
PASSED xarray/tests/test_dataset.py::TestDataset::test_dataset_array_math
PASSED xarray/tests/test_dataset.py::TestDataset::test_dataset_dataset_math
PASSED xarray/tests/test_dataset.py::TestDataset::test_dataset_math_auto_align
PASSED xarray/tests/test_dataset.py::TestDataset::test_dataset_math_errors
PASSED xarray/tests/test_dataset.py::TestDataset::test_dataset_transpose
PASSED xarray/tests/test_dataset.py::TestDataset::test_dataset_ellipsis_transpose_different_ordered_vars
PASSED xarray/tests/test_dataset.py::TestDataset::test_dataset_retains_period_index_on_transpose
PASSED xarray/tests/test_dataset.py::TestDataset::test_dataset_diff_n1_simple
PASSED xarray/tests/test_dataset.py::TestDataset::test_dataset_diff_n1_label
PASSED xarray/tests/test_dataset.py::TestDataset::test_dataset_diff_n1
PASSED xarray/tests/test_dataset.py::TestDataset::test_dataset_diff_n2
PASSED xarray/tests/test_dataset.py::TestDataset::test_dataset_diff_exception_n_neg
PASSED xarray/tests/test_dataset.py::TestDataset::test_dataset_diff_exception_label_str
PASSED xarray/tests/test_dataset.py::TestDataset::test_shift[fill_value0]
PASSED xarray/tests/test_dataset.py::TestDataset::test_shift[2]
PASSED xarray/tests/test_dataset.py::TestDataset::test_shift[2.0]
PASSED xarray/tests/test_dataset.py::TestDataset::test_shift[fill_value3]
PASSED xarray/tests/test_dataset.py::TestDataset::test_roll_coords
PASSED xarray/tests/test_dataset.py::TestDataset::test_roll_no_coords
PASSED xarray/tests/test_dataset.py::TestDataset::test_roll_coords_none
PASSED xarray/tests/test_dataset.py::TestDataset::test_roll_multidim
PASSED xarray/tests/test_dataset.py::TestDataset::test_real_and_imag
PASSED xarray/tests/test_dataset.py::TestDataset::test_setattr_raises
PASSED xarray/tests/test_dataset.py::TestDataset::test_filter_by_attrs
PASSED xarray/tests/test_dataset.py::TestDataset::test_binary_op_propagate_indexes
PASSED xarray/tests/test_dataset.py::TestDataset::test_binary_op_join_setting
PASSED xarray/tests/test_dataset.py::TestDataset::test_full_like
PASSED xarray/tests/test_dataset.py::TestDataset::test_combine_first
PASSED xarray/tests/test_dataset.py::TestDataset::test_sortby
PASSED xarray/tests/test_dataset.py::TestDataset::test_attribute_access
PASSED xarray/tests/test_dataset.py::TestDataset::test_ipython_key_completion
PASSED xarray/tests/test_dataset.py::TestDataset::test_polyfit_output
PASSED xarray/tests/test_dataset.py::TestDataset::test_pad
PASSED xarray/tests/test_dataset.py::TestDataset::test_astype_attrs
PASSED xarray/tests/test_dataset.py::test_isin[test_elements0]
PASSED xarray/tests/test_dataset.py::test_isin[test_elements1]
PASSED xarray/tests/test_dataset.py::test_isin[test_elements2]
PASSED xarray/tests/test_dataset.py::test_isin_dask[test_elements0]
PASSED xarray/tests/test_dataset.py::test_isin_dask[test_elements1]
PASSED xarray/tests/test_dataset.py::test_isin_dask[test_elements2]
PASSED xarray/tests/test_dataset.py::test_isin_dataset
PASSED xarray/tests/test_dataset.py::test_dataset_constructor_aligns_to_explicit_coords[coords0-unaligned_coords0]
PASSED xarray/tests/test_dataset.py::test_dataset_constructor_aligns_to_explicit_coords[coords0-unaligned_coords1]
PASSED xarray/tests/test_dataset.py::test_dataset_constructor_aligns_to_explicit_coords[coords0-unaligned_coords2]
PASSED xarray/tests/test_dataset.py::test_dataset_constructor_aligns_to_explicit_coords[coords0-unaligned_coords3]
PASSED xarray/tests/test_dataset.py::test_dataset_constructor_aligns_to_explicit_coords[coords0-unaligned_coords4]
PASSED xarray/tests/test_dataset.py::test_dataset_constructor_aligns_to_explicit_coords[coords0-unaligned_coords5]
PASSED xarray/tests/test_dataset.py::test_dataset_constructor_aligns_to_explicit_coords[coords0-unaligned_coords6]
PASSED xarray/tests/test_dataset.py::test_dataset_constructor_aligns_to_explicit_coords[coords0-unaligned_coords7]
PASSED xarray/tests/test_dataset.py::test_dataset_constructor_aligns_to_explicit_coords[coords0-unaligned_coords8]
PASSED xarray/tests/test_dataset.py::test_dataset_constructor_aligns_to_explicit_coords[coords0-unaligned_coords9]
PASSED xarray/tests/test_dataset.py::test_dataset_constructor_aligns_to_explicit_coords[coords1-unaligned_coords0]
PASSED xarray/tests/test_dataset.py::test_dataset_constructor_aligns_to_explicit_coords[coords1-unaligned_coords1]
PASSED xarray/tests/test_dataset.py::test_dataset_constructor_aligns_to_explicit_coords[coords1-unaligned_coords2]
PASSED xarray/tests/test_dataset.py::test_dataset_constructor_aligns_to_explicit_coords[coords1-unaligned_coords3]
PASSED xarray/tests/test_dataset.py::test_dataset_constructor_aligns_to_explicit_coords[coords1-unaligned_coords4]
PASSED xarray/tests/test_dataset.py::test_dataset_constructor_aligns_to_explicit_coords[coords1-unaligned_coords5]
PASSED xarray/tests/test_dataset.py::test_dataset_constructor_aligns_to_explicit_coords[coords1-unaligned_coords6]
PASSED xarray/tests/test_dataset.py::test_dataset_constructor_aligns_to_explicit_coords[coords1-unaligned_coords7]
PASSED xarray/tests/test_dataset.py::test_dataset_constructor_aligns_to_explicit_coords[coords1-unaligned_coords8]
PASSED xarray/tests/test_dataset.py::test_dataset_constructor_aligns_to_explicit_coords[coords1-unaligned_coords9]
PASSED xarray/tests/test_dataset.py::test_error_message_on_set_supplied
PASSED xarray/tests/test_dataset.py::test_constructor_raises_with_invalid_coords[unaligned_coords0]
PASSED xarray/tests/test_dataset.py::test_dir_expected_attrs[None]
PASSED xarray/tests/test_dataset.py::test_dir_non_string[None]
PASSED xarray/tests/test_dataset.py::test_dir_unicode[None]
PASSED xarray/tests/test_dataset.py::test_coarsen_absent_dims_error[1]
PASSED xarray/tests/test_dataset.py::test_coarsen[1-trim-left-True]
PASSED xarray/tests/test_dataset.py::test_coarsen[1-trim-left-False]
PASSED xarray/tests/test_dataset.py::test_coarsen[1-pad-right-True]
PASSED xarray/tests/test_dataset.py::test_coarsen[1-pad-right-False]
PASSED xarray/tests/test_dataset.py::test_coarsen_coords[1-True]
PASSED xarray/tests/test_dataset.py::test_coarsen_coords[1-False]
PASSED xarray/tests/test_dataset.py::test_coarsen_coords_cftime
PASSED xarray/tests/test_dataset.py::test_coarsen_keep_attrs
PASSED xarray/tests/test_dataset.py::test_rolling_keep_attrs[reduce-argument0]
PASSED xarray/tests/test_dataset.py::test_rolling_keep_attrs[mean-argument1]
PASSED xarray/tests/test_dataset.py::test_rolling_keep_attrs[construct-argument2]
PASSED xarray/tests/test_dataset.py::test_rolling_keep_attrs[count-argument3]
PASSED xarray/tests/test_dataset.py::test_rolling_keep_attrs_deprecated
PASSED xarray/tests/test_dataset.py::test_rolling_properties[1]
PASSED xarray/tests/test_dataset.py::test_rolling_wrapped_bottleneck[1-z1-1-True-sum]
PASSED xarray/tests/test_dataset.py::test_rolling_wrapped_bottleneck[1-z1-1-True-mean]
PASSED xarray/tests/test_dataset.py::test_rolling_wrapped_bottleneck[1-z1-1-True-std]
PASSED xarray/tests/test_dataset.py::test_rolling_wrapped_bottleneck[1-z1-1-True-var]
PASSED xarray/tests/test_dataset.py::test_rolling_wrapped_bottleneck[1-z1-1-True-min]
PASSED xarray/tests/test_dataset.py::test_rolling_wrapped_bottleneck[1-z1-1-True-max]
PASSED xarray/tests/test_dataset.py::test_rolling_wrapped_bottleneck[1-z1-1-True-median]
PASSED xarray/tests/test_dataset.py::test_rolling_wrapped_bottleneck[1-z1-1-False-sum]
PASSED xarray/tests/test_dataset.py::test_rolling_wrapped_bottleneck[1-z1-1-False-mean]
PASSED xarray/tests/test_dataset.py::test_rolling_wrapped_bottleneck[1-z1-1-False-std]
PASSED xarray/tests/test_dataset.py::test_rolling_wrapped_bottleneck[1-z1-1-False-var]
PASSED xarray/tests/test_dataset.py::test_rolling_wrapped_bottleneck[1-z1-1-False-min]
PASSED xarray/tests/test_dataset.py::test_rolling_wrapped_bottleneck[1-z1-1-False-max]
PASSED xarray/tests/test_dataset.py::test_rolling_wrapped_bottleneck[1-z1-1-False-median]
PASSED xarray/tests/test_dataset.py::test_rolling_wrapped_bottleneck[1-z1-1-None-sum]
PASSED xarray/tests/test_dataset.py::test_rolling_wrapped_bottleneck[1-z1-1-None-mean]
PASSED xarray/tests/test_dataset.py::test_rolling_wrapped_bottleneck[1-z1-1-None-std]
PASSED xarray/tests/test_dataset.py::test_rolling_wrapped_bottleneck[1-z1-1-None-var]
PASSED xarray/tests/test_dataset.py::test_rolling_wrapped_bottleneck[1-z1-1-None-min]
PASSED xarray/tests/test_dataset.py::test_rolling_wrapped_bottleneck[1-z1-1-None-max]
PASSED xarray/tests/test_dataset.py::test_rolling_wrapped_bottleneck[1-z1-1-None-median]
PASSED xarray/tests/test_dataset.py::test_rolling_wrapped_bottleneck[1-z1-None-True-sum]
PASSED xarray/tests/test_dataset.py::test_rolling_wrapped_bottleneck[1-z1-None-True-mean]
PASSED xarray/tests/test_dataset.py::test_rolling_wrapped_bottleneck[1-z1-None-True-std]
PASSED xarray/tests/test_dataset.py::test_rolling_wrapped_bottleneck[1-z1-None-True-var]
PASSED xarray/tests/test_dataset.py::test_rolling_wrapped_bottleneck[1-z1-None-True-min]
PASSED xarray/tests/test_dataset.py::test_rolling_wrapped_bottleneck[1-z1-None-True-max]
PASSED xarray/tests/test_dataset.py::test_rolling_wrapped_bottleneck[1-z1-None-True-median]
PASSED xarray/tests/test_dataset.py::test_rolling_wrapped_bottleneck[1-z1-None-False-sum]
PASSED xarray/tests/test_dataset.py::test_rolling_wrapped_bottleneck[1-z1-None-False-mean]
PASSED xarray/tests/test_dataset.py::test_rolling_wrapped_bottleneck[1-z1-None-False-std]
PASSED xarray/tests/test_dataset.py::test_rolling_wrapped_bottleneck[1-z1-None-False-var]
PASSED xarray/tests/test_dataset.py::test_rolling_wrapped_bottleneck[1-z1-None-False-min]
PASSED xarray/tests/test_dataset.py::test_rolling_wrapped_bottleneck[1-z1-None-False-max]
PASSED xarray/tests/test_dataset.py::test_rolling_wrapped_bottleneck[1-z1-None-False-median]
PASSED xarray/tests/test_dataset.py::test_rolling_wrapped_bottleneck[1-z1-None-None-sum]
PASSED xarray/tests/test_dataset.py::test_rolling_wrapped_bottleneck[1-z1-None-None-mean]
PASSED xarray/tests/test_dataset.py::test_rolling_wrapped_bottleneck[1-z1-None-None-std]
PASSED xarray/tests/test_dataset.py::test_rolling_wrapped_bottleneck[1-z1-None-None-var]
PASSED xarray/tests/test_dataset.py::test_rolling_wrapped_bottleneck[1-z1-None-None-min]
PASSED xarray/tests/test_dataset.py::test_rolling_wrapped_bottleneck[1-z1-None-None-max]
PASSED xarray/tests/test_dataset.py::test_rolling_wrapped_bottleneck[1-z1-None-None-median]
PASSED xarray/tests/test_dataset.py::test_rolling_wrapped_bottleneck[1-z2-1-True-sum]
PASSED xarray/tests/test_dataset.py::test_rolling_wrapped_bottleneck[1-z2-1-True-mean]
PASSED xarray/tests/test_dataset.py::test_rolling_wrapped_bottleneck[1-z2-1-True-std]
PASSED xarray/tests/test_dataset.py::test_rolling_wrapped_bottleneck[1-z2-1-True-var]
PASSED xarray/tests/test_dataset.py::test_rolling_wrapped_bottleneck[1-z2-1-True-min]
PASSED xarray/tests/test_dataset.py::test_rolling_wrapped_bottleneck[1-z2-1-True-max]
PASSED xarray/tests/test_dataset.py::test_rolling_wrapped_bottleneck[1-z2-1-True-median]
PASSED xarray/tests/test_dataset.py::test_rolling_wrapped_bottleneck[1-z2-1-False-sum]
PASSED xarray/tests/test_dataset.py::test_rolling_wrapped_bottleneck[1-z2-1-False-mean]
PASSED xarray/tests/test_dataset.py::test_rolling_wrapped_bottleneck[1-z2-1-False-std]
PASSED xarray/tests/test_dataset.py::test_rolling_wrapped_bottleneck[1-z2-1-False-var]
PASSED xarray/tests/test_dataset.py::test_rolling_wrapped_bottleneck[1-z2-1-False-min]
PASSED xarray/tests/test_dataset.py::test_rolling_wrapped_bottleneck[1-z2-1-False-max]
PASSED xarray/tests/test_dataset.py::test_rolling_wrapped_bottleneck[1-z2-1-False-median]
PASSED xarray/tests/test_dataset.py::test_rolling_wrapped_bottleneck[1-z2-1-None-sum]
PASSED xarray/tests/test_dataset.py::test_rolling_wrapped_bottleneck[1-z2-1-None-mean]
PASSED xarray/tests/test_dataset.py::test_rolling_wrapped_bottleneck[1-z2-1-None-std]
PASSED xarray/tests/test_dataset.py::test_rolling_wrapped_bottleneck[1-z2-1-None-var]
PASSED xarray/tests/test_dataset.py::test_rolling_wrapped_bottleneck[1-z2-1-None-min]
PASSED xarray/tests/test_dataset.py::test_rolling_wrapped_bottleneck[1-z2-1-None-max]
PASSED xarray/tests/test_dataset.py::test_rolling_wrapped_bottleneck[1-z2-1-None-median]
PASSED xarray/tests/test_dataset.py::test_rolling_wrapped_bottleneck[1-z2-None-True-sum]
PASSED xarray/tests/test_dataset.py::test_rolling_wrapped_bottleneck[1-z2-None-True-mean]
PASSED xarray/tests/test_dataset.py::test_rolling_wrapped_bottleneck[1-z2-None-True-std]
PASSED xarray/tests/test_dataset.py::test_rolling_wrapped_bottleneck[1-z2-None-True-var]
PASSED xarray/tests/test_dataset.py::test_rolling_wrapped_bottleneck[1-z2-None-True-min]
PASSED xarray/tests/test_dataset.py::test_rolling_wrapped_bottleneck[1-z2-None-True-max]
PASSED xarray/tests/test_dataset.py::test_rolling_wrapped_bottleneck[1-z2-None-True-median]
PASSED xarray/tests/test_dataset.py::test_rolling_wrapped_bottleneck[1-z2-None-False-sum]
PASSED xarray/tests/test_dataset.py::test_rolling_wrapped_bottleneck[1-z2-None-False-mean]
PASSED xarray/tests/test_dataset.py::test_rolling_wrapped_bottleneck[1-z2-None-False-std]
PASSED xarray/tests/test_dataset.py::test_rolling_wrapped_bottleneck[1-z2-None-False-var]
PASSED xarray/tests/test_dataset.py::test_rolling_wrapped_bottleneck[1-z2-None-False-min]
PASSED xarray/tests/test_dataset.py::test_rolling_wrapped_bottleneck[1-z2-None-False-max]
PASSED xarray/tests/test_dataset.py::test_rolling_wrapped_bottleneck[1-z2-None-False-median]
PASSED xarray/tests/test_dataset.py::test_rolling_wrapped_bottleneck[1-z2-None-None-sum]
PASSED xarray/tests/test_dataset.py::test_rolling_wrapped_bottleneck[1-z2-None-None-mean]
PASSED xarray/tests/test_dataset.py::test_rolling_wrapped_bottleneck[1-z2-None-None-std]
PASSED xarray/tests/test_dataset.py::test_rolling_wrapped_bottleneck[1-z2-None-None-var]
PASSED xarray/tests/test_dataset.py::test_rolling_wrapped_bottleneck[1-z2-None-None-min]
PASSED xarray/tests/test_dataset.py::test_rolling_wrapped_bottleneck[1-z2-None-None-max]
PASSED xarray/tests/test_dataset.py::test_rolling_wrapped_bottleneck[1-z2-None-None-median]
PASSED xarray/tests/test_dataset.py::test_rolling_exp[1]
PASSED xarray/tests/test_dataset.py::test_rolling_exp_keep_attrs[1]
PASSED xarray/tests/test_dataset.py::test_rolling_pandas_compat[1-None-True]
PASSED xarray/tests/test_dataset.py::test_rolling_pandas_compat[1-None-False]
PASSED xarray/tests/test_dataset.py::test_rolling_pandas_compat[1-1-True]
PASSED xarray/tests/test_dataset.py::test_rolling_pandas_compat[1-1-False]
PASSED xarray/tests/test_dataset.py::test_rolling_pandas_compat[1-2-True]
PASSED xarray/tests/test_dataset.py::test_rolling_pandas_compat[1-2-False]
PASSED xarray/tests/test_dataset.py::test_rolling_pandas_compat[1-3-True]
PASSED xarray/tests/test_dataset.py::test_rolling_pandas_compat[1-3-False]
PASSED xarray/tests/test_dataset.py::test_rolling_pandas_compat[2-None-True]
PASSED xarray/tests/test_dataset.py::test_rolling_pandas_compat[2-None-False]
PASSED xarray/tests/test_dataset.py::test_rolling_pandas_compat[2-1-True]
PASSED xarray/tests/test_dataset.py::test_rolling_pandas_compat[2-1-False]
PASSED xarray/tests/test_dataset.py::test_rolling_pandas_compat[2-2-True]
PASSED xarray/tests/test_dataset.py::test_rolling_pandas_compat[2-2-False]
PASSED xarray/tests/test_dataset.py::test_rolling_pandas_compat[2-3-True]
PASSED xarray/tests/test_dataset.py::test_rolling_pandas_compat[2-3-False]
PASSED xarray/tests/test_dataset.py::test_rolling_pandas_compat[3-None-True]
PASSED xarray/tests/test_dataset.py::test_rolling_pandas_compat[3-None-False]
PASSED xarray/tests/test_dataset.py::test_rolling_pandas_compat[3-1-True]
PASSED xarray/tests/test_dataset.py::test_rolling_pandas_compat[3-1-False]
PASSED xarray/tests/test_dataset.py::test_rolling_pandas_compat[3-2-True]
PASSED xarray/tests/test_dataset.py::test_rolling_pandas_compat[3-2-False]
PASSED xarray/tests/test_dataset.py::test_rolling_pandas_compat[3-3-True]
PASSED xarray/tests/test_dataset.py::test_rolling_pandas_compat[3-3-False]
PASSED xarray/tests/test_dataset.py::test_rolling_pandas_compat[4-None-True]
PASSED xarray/tests/test_dataset.py::test_rolling_pandas_compat[4-None-False]
PASSED xarray/tests/test_dataset.py::test_rolling_pandas_compat[4-1-True]
PASSED xarray/tests/test_dataset.py::test_rolling_pandas_compat[4-1-False]
PASSED xarray/tests/test_dataset.py::test_rolling_pandas_compat[4-2-True]
PASSED xarray/tests/test_dataset.py::test_rolling_pandas_compat[4-2-False]
PASSED xarray/tests/test_dataset.py::test_rolling_pandas_compat[4-3-True]
PASSED xarray/tests/test_dataset.py::test_rolling_pandas_compat[4-3-False]
PASSED xarray/tests/test_dataset.py::test_rolling_construct[1-True]
PASSED xarray/tests/test_dataset.py::test_rolling_construct[1-False]
PASSED xarray/tests/test_dataset.py::test_rolling_construct[2-True]
PASSED xarray/tests/test_dataset.py::test_rolling_construct[2-False]
PASSED xarray/tests/test_dataset.py::test_rolling_construct[3-True]
PASSED xarray/tests/test_dataset.py::test_rolling_construct[3-False]
PASSED xarray/tests/test_dataset.py::test_rolling_construct[4-True]
PASSED xarray/tests/test_dataset.py::test_rolling_construct[4-False]
PASSED xarray/tests/test_dataset.py::test_rolling_reduce[sum-1-None-True-1]
PASSED xarray/tests/test_dataset.py::test_rolling_reduce[sum-1-None-True-2]
PASSED xarray/tests/test_dataset.py::test_rolling_reduce[sum-1-None-False-1]
PASSED xarray/tests/test_dataset.py::test_rolling_reduce[sum-1-None-False-2]
PASSED xarray/tests/test_dataset.py::test_rolling_reduce[sum-1-1-True-1]
PASSED xarray/tests/test_dataset.py::test_rolling_reduce[sum-1-1-True-2]
PASSED xarray/tests/test_dataset.py::test_rolling_reduce[sum-1-1-False-1]
PASSED xarray/tests/test_dataset.py::test_rolling_reduce[sum-1-1-False-2]
PASSED xarray/tests/test_dataset.py::test_rolling_reduce[sum-1-2-True-1]
PASSED xarray/tests/test_dataset.py::test_rolling_reduce[sum-1-2-True-2]
PASSED xarray/tests/test_dataset.py::test_rolling_reduce[sum-1-2-False-1]
PASSED xarray/tests/test_dataset.py::test_rolling_reduce[sum-1-2-False-2]
PASSED xarray/tests/test_dataset.py::test_rolling_reduce[sum-1-3-True-1]
PASSED xarray/tests/test_dataset.py::test_rolling_reduce[sum-1-3-True-2]
PASSED xarray/tests/test_dataset.py::test_rolling_reduce[sum-1-3-False-1]
PASSED xarray/tests/test_dataset.py::test_rolling_reduce[sum-1-3-False-2]
PASSED xarray/tests/test_dataset.py::test_rolling_reduce[sum-2-None-True-1]
PASSED xarray/tests/test_dataset.py::test_rolling_reduce[sum-2-None-True-2]
PASSED xarray/tests/test_dataset.py::test_rolling_reduce[sum-2-None-False-1]
PASSED xarray/tests/test_dataset.py::test_rolling_reduce[sum-2-None-False-2]
PASSED xarray/tests/test_dataset.py::test_rolling_reduce[sum-2-1-True-1]
PASSED xarray/tests/test_dataset.py::test_rolling_reduce[sum-2-1-True-2]
PASSED xarray/tests/test_dataset.py::test_rolling_reduce[sum-2-1-False-1]
PASSED xarray/tests/test_dataset.py::test_rolling_reduce[sum-2-1-False-2]
PASSED xarray/tests/test_dataset.py::test_rolling_reduce[sum-2-2-True-1]
PASSED xarray/tests/test_dataset.py::test_rolling_reduce[sum-2-2-True-2]
PASSED xarray/tests/test_dataset.py::test_rolling_reduce[sum-2-2-False-1]
PASSED xarray/tests/test_dataset.py::test_rolling_reduce[sum-2-2-False-2]
PASSED xarray/tests/test_dataset.py::test_rolling_reduce[sum-2-3-True-1]
PASSED xarray/tests/test_dataset.py::test_rolling_reduce[sum-2-3-True-2]
PASSED xarray/tests/test_dataset.py::test_rolling_reduce[sum-2-3-False-1]
PASSED xarray/tests/test_dataset.py::test_rolling_reduce[sum-2-3-False-2]
PASSED xarray/tests/test_dataset.py::test_rolling_reduce[sum-3-None-True-1]
PASSED xarray/tests/test_dataset.py::test_rolling_reduce[sum-3-None-True-2]
PASSED xarray/tests/test_dataset.py::test_rolling_reduce[sum-3-None-False-1]
PASSED xarray/tests/test_dataset.py::test_rolling_reduce[sum-3-None-False-2]
PASSED xarray/tests/test_dataset.py::test_rolling_reduce[sum-3-1-True-1]
PASSED xarray/tests/test_dataset.py::test_rolling_reduce[sum-3-1-True-2]
PASSED xarray/tests/test_dataset.py::test_rolling_reduce[sum-3-1-False-1]
PASSED xarray/tests/test_dataset.py::test_rolling_reduce[sum-3-1-False-2]
PASSED xarray/tests/test_dataset.py::test_rolling_reduce[sum-3-2-True-1]
PASSED xarray/tests/test_dataset.py::test_rolling_reduce[sum-3-2-True-2]
PASSED xarray/tests/test_dataset.py::test_rolling_reduce[sum-3-2-False-1]
PASSED xarray/tests/test_dataset.py::test_rolling_reduce[sum-3-2-False-2]
PASSED xarray/tests/test_dataset.py::test_rolling_reduce[sum-3-3-True-1]
PASSED xarray/tests/test_dataset.py::test_rolling_reduce[sum-3-3-True-2]
PASSED xarray/tests/test_dataset.py::test_rolling_reduce[sum-3-3-False-1]
PASSED xarray/tests/test_dataset.py::test_rolling_reduce[sum-3-3-False-2]
PASSED xarray/tests/test_dataset.py::test_rolling_reduce[sum-4-None-True-1]
PASSED xarray/tests/test_dataset.py::test_rolling_reduce[sum-4-None-True-2]
PASSED xarray/tests/test_dataset.py::test_rolling_reduce[sum-4-None-False-1]
PASSED xarray/tests/test_dataset.py::test_rolling_reduce[sum-4-None-False-2]
PASSED xarray/tests/test_dataset.py::test_rolling_reduce[sum-4-1-True-1]
PASSED xarray/tests/test_dataset.py::test_rolling_reduce[sum-4-1-True-2]
PASSED xarray/tests/test_dataset.py::test_rolling_reduce[sum-4-1-False-1]
PASSED xarray/tests/test_dataset.py::test_rolling_reduce[sum-4-1-False-2]
PASSED xarray/tests/test_dataset.py::test_rolling_reduce[sum-4-2-True-1]
PASSED xarray/tests/test_dataset.py::test_rolling_reduce[sum-4-2-True-2]
PASSED xarray/tests/test_dataset.py::test_rolling_reduce[sum-4-2-False-1]
PASSED xarray/tests/test_dataset.py::test_rolling_reduce[sum-4-2-False-2]
PASSED xarray/tests/test_dataset.py::test_rolling_reduce[sum-4-3-True-1]
PASSED xarray/tests/test_dataset.py::test_rolling_reduce[sum-4-3-True-2]
PASSED xarray/tests/test_dataset.py::test_rolling_reduce[sum-4-3-False-1]
PASSED xarray/tests/test_dataset.py::test_rolling_reduce[sum-4-3-False-2]
PASSED xarray/tests/test_dataset.py::test_rolling_reduce[mean-1-None-True-1]
PASSED xarray/tests/test_dataset.py::test_rolling_reduce[mean-1-None-True-2]
PASSED xarray/tests/test_dataset.py::test_rolling_reduce[mean-1-None-False-1]
PASSED xarray/tests/test_dataset.py::test_rolling_reduce[mean-1-None-False-2]
PASSED xarray/tests/test_dataset.py::test_rolling_reduce[mean-1-1-True-1]
PASSED xarray/tests/test_dataset.py::test_rolling_reduce[mean-1-1-True-2]
PASSED xarray/tests/test_dataset.py::test_rolling_reduce[mean-1-1-False-1]
PASSED xarray/tests/test_dataset.py::test_rolling_reduce[mean-1-1-False-2]
PASSED xarray/tests/test_dataset.py::test_rolling_reduce[mean-1-2-True-1]
PASSED xarray/tests/test_dataset.py::test_rolling_reduce[mean-1-2-True-2]
PASSED xarray/tests/test_dataset.py::test_rolling_reduce[mean-1-2-False-1]
PASSED xarray/tests/test_dataset.py::test_rolling_reduce[mean-1-2-False-2]
PASSED xarray/tests/test_dataset.py::test_rolling_reduce[mean-1-3-True-1]
PASSED xarray/tests/test_dataset.py::test_rolling_reduce[mean-1-3-True-2]
PASSED xarray/tests/test_dataset.py::test_rolling_reduce[mean-1-3-False-1]
PASSED xarray/tests/test_dataset.py::test_rolling_reduce[mean-1-3-False-2]
PASSED xarray/tests/test_dataset.py::test_rolling_reduce[mean-2-None-True-1]
PASSED xarray/tests/test_dataset.py::test_rolling_reduce[mean-2-None-True-2]
PASSED xarray/tests/test_dataset.py::test_rolling_reduce[mean-2-None-False-1]
PASSED xarray/tests/test_dataset.py::test_rolling_reduce[mean-2-None-False-2]
PASSED xarray/tests/test_dataset.py::test_rolling_reduce[mean-2-1-True-1]
PASSED xarray/tests/test_dataset.py::test_rolling_reduce[mean-2-1-True-2]
PASSED xarray/tests/test_dataset.py::test_rolling_reduce[mean-2-1-False-1]
PASSED xarray/tests/test_dataset.py::test_rolling_reduce[mean-2-1-False-2]
PASSED xarray/tests/test_dataset.py::test_rolling_reduce[mean-2-2-True-1]
PASSED xarray/tests/test_dataset.py::test_rolling_reduce[mean-2-2-True-2]
PASSED xarray/tests/test_dataset.py::test_rolling_reduce[mean-2-2-False-1]
PASSED xarray/tests/test_dataset.py::test_rolling_reduce[mean-2-2-False-2]
PASSED xarray/tests/test_dataset.py::test_rolling_reduce[mean-2-3-True-1]
PASSED xarray/tests/test_dataset.py::test_rolling_reduce[mean-2-3-True-2]
PASSED xarray/tests/test_dataset.py::test_rolling_reduce[mean-2-3-False-1]
PASSED xarray/tests/test_dataset.py::test_rolling_reduce[mean-2-3-False-2]
PASSED xarray/tests/test_dataset.py::test_rolling_reduce[mean-3-None-True-1]
PASSED xarray/tests/test_dataset.py::test_rolling_reduce[mean-3-None-True-2]
PASSED xarray/tests/test_dataset.py::test_rolling_reduce[mean-3-None-False-1]
PASSED xarray/tests/test_dataset.py::test_rolling_reduce[mean-3-None-False-2]
PASSED xarray/tests/test_dataset.py::test_rolling_reduce[mean-3-1-True-1]
PASSED xarray/tests/test_dataset.py::test_rolling_reduce[mean-3-1-True-2]
PASSED xarray/tests/test_dataset.py::test_rolling_reduce[mean-3-1-False-1]
PASSED xarray/tests/test_dataset.py::test_rolling_reduce[mean-3-1-False-2]
PASSED xarray/tests/test_dataset.py::test_rolling_reduce[mean-3-2-True-1]
PASSED xarray/tests/test_dataset.py::test_rolling_reduce[mean-3-2-True-2]
PASSED xarray/tests/test_dataset.py::test_rolling_reduce[mean-3-2-False-1]
PASSED xarray/tests/test_dataset.py::test_rolling_reduce[mean-3-2-False-2]
PASSED xarray/tests/test_dataset.py::test_rolling_reduce[mean-3-3-True-1]
PASSED xarray/tests/test_dataset.py::test_rolling_reduce[mean-3-3-True-2]
PASSED xarray/tests/test_dataset.py::test_rolling_reduce[mean-3-3-False-1]
PASSED xarray/tests/test_dataset.py::test_rolling_reduce[mean-3-3-False-2]
PASSED xarray/tests/test_dataset.py::test_rolling_reduce[mean-4-None-True-1]
PASSED xarray/tests/test_dataset.py::test_rolling_reduce[mean-4-None-True-2]
PASSED xarray/tests/test_dataset.py::test_rolling_reduce[mean-4-None-False-1]
PASSED xarray/tests/test_dataset.py::test_rolling_reduce[mean-4-None-False-2]
PASSED xarray/tests/test_dataset.py::test_rolling_reduce[mean-4-1-True-1]
PASSED xarray/tests/test_dataset.py::test_rolling_reduce[mean-4-1-True-2]
PASSED xarray/tests/test_dataset.py::test_rolling_reduce[mean-4-1-False-1]
PASSED xarray/tests/test_dataset.py::test_rolling_reduce[mean-4-1-False-2]
PASSED xarray/tests/test_dataset.py::test_rolling_reduce[mean-4-2-True-1]
PASSED xarray/tests/test_dataset.py::test_rolling_reduce[mean-4-2-True-2]
PASSED xarray/tests/test_dataset.py::test_rolling_reduce[mean-4-2-False-1]
PASSED xarray/tests/test_dataset.py::test_rolling_reduce[mean-4-2-False-2]
PASSED xarray/tests/test_dataset.py::test_rolling_reduce[mean-4-3-True-1]
PASSED xarray/tests/test_dataset.py::test_rolling_reduce[mean-4-3-True-2]
PASSED xarray/tests/test_dataset.py::test_rolling_reduce[mean-4-3-False-1]
PASSED xarray/tests/test_dataset.py::test_rolling_reduce[mean-4-3-False-2]
PASSED xarray/tests/test_dataset.py::test_rolling_reduce[std-2-None-True-1]
PASSED xarray/tests/test_dataset.py::test_rolling_reduce[std-2-None-True-2]
PASSED xarray/tests/test_dataset.py::test_rolling_reduce[std-2-None-False-1]
PASSED xarray/tests/test_dataset.py::test_rolling_reduce[std-2-None-False-2]
PASSED xarray/tests/test_dataset.py::test_rolling_reduce[std-2-1-True-1]
PASSED xarray/tests/test_dataset.py::test_rolling_reduce[std-2-1-True-2]
PASSED xarray/tests/test_dataset.py::test_rolling_reduce[std-2-1-False-1]
PASSED xarray/tests/test_dataset.py::test_rolling_reduce[std-2-1-False-2]
PASSED xarray/tests/test_dataset.py::test_rolling_reduce[std-2-2-True-1]
PASSED xarray/tests/test_dataset.py::test_rolling_reduce[std-2-2-True-2]
PASSED xarray/tests/test_dataset.py::test_rolling_reduce[std-2-2-False-1]
PASSED xarray/tests/test_dataset.py::test_rolling_reduce[std-2-2-False-2]
PASSED xarray/tests/test_dataset.py::test_rolling_reduce[std-2-3-True-1]
PASSED xarray/tests/test_dataset.py::test_rolling_reduce[std-2-3-True-2]
PASSED xarray/tests/test_dataset.py::test_rolling_reduce[std-2-3-False-1]
PASSED xarray/tests/test_dataset.py::test_rolling_reduce[std-2-3-False-2]
PASSED xarray/tests/test_dataset.py::test_rolling_reduce[std-3-None-True-1]
PASSED xarray/tests/test_dataset.py::test_rolling_reduce[std-3-None-True-2]
PASSED xarray/tests/test_dataset.py::test_rolling_reduce[std-3-None-False-1]
PASSED xarray/tests/test_dataset.py::test_rolling_reduce[std-3-None-False-2]
PASSED xarray/tests/test_dataset.py::test_rolling_reduce[std-3-1-True-1]
PASSED xarray/tests/test_dataset.py::test_rolling_reduce[std-3-1-True-2]
PASSED xarray/tests/test_dataset.py::test_rolling_reduce[std-3-1-False-1]
PASSED xarray/tests/test_dataset.py::test_rolling_reduce[std-3-1-False-2]
PASSED xarray/tests/test_dataset.py::test_rolling_reduce[std-3-2-True-1]
PASSED xarray/tests/test_dataset.py::test_rolling_reduce[std-3-2-True-2]
PASSED xarray/tests/test_dataset.py::test_rolling_reduce[std-3-2-False-1]
PASSED xarray/tests/test_dataset.py::test_rolling_reduce[std-3-2-False-2]
PASSED xarray/tests/test_dataset.py::test_rolling_reduce[std-3-3-True-1]
PASSED xarray/tests/test_dataset.py::test_rolling_reduce[std-3-3-True-2]
PASSED xarray/tests/test_dataset.py::test_rolling_reduce[std-3-3-False-1]
PASSED xarray/tests/test_dataset.py::test_rolling_reduce[std-3-3-False-2]
PASSED xarray/tests/test_dataset.py::test_rolling_reduce[std-4-None-True-1]
PASSED xarray/tests/test_dataset.py::test_rolling_reduce[std-4-None-True-2]
PASSED xarray/tests/test_dataset.py::test_rolling_reduce[std-4-None-False-1]
PASSED xarray/tests/test_dataset.py::test_rolling_reduce[std-4-None-False-2]
PASSED xarray/tests/test_dataset.py::test_rolling_reduce[std-4-1-True-1]
PASSED xarray/tests/test_dataset.py::test_rolling_reduce[std-4-1-True-2]
PASSED xarray/tests/test_dataset.py::test_rolling_reduce[std-4-1-False-1]
PASSED xarray/tests/test_dataset.py::test_rolling_reduce[std-4-1-False-2]
PASSED xarray/tests/test_dataset.py::test_rolling_reduce[std-4-2-True-1]
PASSED xarray/tests/test_dataset.py::test_rolling_reduce[std-4-2-True-2]
PASSED xarray/tests/test_dataset.py::test_rolling_reduce[std-4-2-False-1]
PASSED xarray/tests/test_dataset.py::test_rolling_reduce[std-4-2-False-2]
PASSED xarray/tests/test_dataset.py::test_rolling_reduce[std-4-3-True-1]
PASSED xarray/tests/test_dataset.py::test_rolling_reduce[std-4-3-True-2]
PASSED xarray/tests/test_dataset.py::test_rolling_reduce[std-4-3-False-1]
PASSED xarray/tests/test_dataset.py::test_rolling_reduce[std-4-3-False-2]
PASSED xarray/tests/test_dataset.py::test_rolling_reduce[var-1-None-True-1]
PASSED xarray/tests/test_dataset.py::test_rolling_reduce[var-1-None-True-2]
PASSED xarray/tests/test_dataset.py::test_rolling_reduce[var-1-None-False-1]
PASSED xarray/tests/test_dataset.py::test_rolling_reduce[var-1-None-False-2]
PASSED xarray/tests/test_dataset.py::test_rolling_reduce[var-1-1-True-1]
PASSED xarray/tests/test_dataset.py::test_rolling_reduce[var-1-1-True-2]
PASSED xarray/tests/test_dataset.py::test_rolling_reduce[var-1-1-False-1]
PASSED xarray/tests/test_dataset.py::test_rolling_reduce[var-1-1-False-2]
PASSED xarray/tests/test_dataset.py::test_rolling_reduce[var-1-2-True-1]
PASSED xarray/tests/test_dataset.py::test_rolling_reduce[var-1-2-True-2]
PASSED xarray/tests/test_dataset.py::test_rolling_reduce[var-1-2-False-1]
PASSED xarray/tests/test_dataset.py::test_rolling_reduce[var-1-2-False-2]
PASSED xarray/tests/test_dataset.py::test_rolling_reduce[var-1-3-True-1]
PASSED xarray/tests/test_dataset.py::test_rolling_reduce[var-1-3-True-2]
PASSED xarray/tests/test_dataset.py::test_rolling_reduce[var-1-3-False-1]
PASSED xarray/tests/test_dataset.py::test_rolling_reduce[var-1-3-False-2]
PASSED xarray/tests/test_dataset.py::test_rolling_reduce[var-2-None-True-1]
PASSED xarray/tests/test_dataset.py::test_rolling_reduce[var-2-None-True-2]
PASSED xarray/tests/test_dataset.py::test_rolling_reduce[var-2-None-False-1]
PASSED xarray/tests/test_dataset.py::test_rolling_reduce[var-2-None-False-2]
PASSED xarray/tests/test_dataset.py::test_rolling_reduce[var-2-1-True-1]
PASSED xarray/tests/test_dataset.py::test_rolling_reduce[var-2-1-True-2]
PASSED xarray/tests/test_dataset.py::test_rolling_reduce[var-2-1-False-1]
PASSED xarray/tests/test_dataset.py::test_rolling_reduce[var-2-1-False-2]
PASSED xarray/tests/test_dataset.py::test_rolling_reduce[var-2-2-True-1]
PASSED xarray/tests/test_dataset.py::test_rolling_reduce[var-2-2-True-2]
PASSED xarray/tests/test_dataset.py::test_rolling_reduce[var-2-2-False-1]
PASSED xarray/tests/test_dataset.py::test_rolling_reduce[var-2-2-False-2]
PASSED xarray/tests/test_dataset.py::test_rolling_reduce[var-2-3-True-1]
PASSED xarray/tests/test_dataset.py::test_rolling_reduce[var-2-3-True-2]
PASSED xarray/tests/test_dataset.py::test_rolling_reduce[var-2-3-False-1]
PASSED xarray/tests/test_dataset.py::test_rolling_reduce[var-2-3-False-2]
PASSED xarray/tests/test_dataset.py::test_rolling_reduce[var-3-None-True-1]
PASSED xarray/tests/test_dataset.py::test_rolling_reduce[var-3-None-True-2]
PASSED xarray/tests/test_dataset.py::test_rolling_reduce[var-3-None-False-1]
PASSED xarray/tests/test_dataset.py::test_rolling_reduce[var-3-None-False-2]
PASSED xarray/tests/test_dataset.py::test_rolling_reduce[var-3-1-True-1]
PASSED xarray/tests/test_dataset.py::test_rolling_reduce[var-3-1-True-2]
PASSED xarray/tests/test_dataset.py::test_rolling_reduce[var-3-1-False-1]
PASSED xarray/tests/test_dataset.py::test_rolling_reduce[var-3-1-False-2]
PASSED xarray/tests/test_dataset.py::test_rolling_reduce[var-3-2-True-1]
PASSED xarray/tests/test_dataset.py::test_rolling_reduce[var-3-2-True-2]
PASSED xarray/tests/test_dataset.py::test_rolling_reduce[var-3-2-False-1]
PASSED xarray/tests/test_dataset.py::test_rolling_reduce[var-3-2-False-2]
PASSED xarray/tests/test_dataset.py::test_rolling_reduce[var-3-3-True-1]
PASSED xarray/tests/test_dataset.py::test_rolling_reduce[var-3-3-True-2]
PASSED xarray/tests/test_dataset.py::test_rolling_reduce[var-3-3-False-1]
PASSED xarray/tests/test_dataset.py::test_rolling_reduce[var-3-3-False-2]
PASSED xarray/tests/test_dataset.py::test_rolling_reduce[var-4-None-True-1]
PASSED xarray/tests/test_dataset.py::test_rolling_reduce[var-4-None-True-2]
PASSED xarray/tests/test_dataset.py::test_rolling_reduce[var-4-None-False-1]
PASSED xarray/tests/test_dataset.py::test_rolling_reduce[var-4-None-False-2]
PASSED xarray/tests/test_dataset.py::test_rolling_reduce[var-4-1-True-1]
PASSED xarray/tests/test_dataset.py::test_rolling_reduce[var-4-1-True-2]
PASSED xarray/tests/test_dataset.py::test_rolling_reduce[var-4-1-False-1]
PASSED xarray/tests/test_dataset.py::test_rolling_reduce[var-4-1-False-2]
PASSED xarray/tests/test_dataset.py::test_rolling_reduce[var-4-2-True-1]
PASSED xarray/tests/test_dataset.py::test_rolling_reduce[var-4-2-True-2]
PASSED xarray/tests/test_dataset.py::test_rolling_reduce[var-4-2-False-1]
PASSED xarray/tests/test_dataset.py::test_rolling_reduce[var-4-2-False-2]
PASSED xarray/tests/test_dataset.py::test_rolling_reduce[var-4-3-True-1]
PASSED xarray/tests/test_dataset.py::test_rolling_reduce[var-4-3-True-2]
PASSED xarray/tests/test_dataset.py::test_rolling_reduce[var-4-3-False-1]
PASSED xarray/tests/test_dataset.py::test_rolling_reduce[var-4-3-False-2]
PASSED xarray/tests/test_dataset.py::test_rolling_reduce[min-1-None-True-1]
PASSED xarray/tests/test_dataset.py::test_rolling_reduce[min-1-None-True-2]
PASSED xarray/tests/test_dataset.py::test_rolling_reduce[min-1-None-False-1]
PASSED xarray/tests/test_dataset.py::test_rolling_reduce[min-1-None-False-2]
PASSED xarray/tests/test_dataset.py::test_rolling_reduce[min-1-1-True-1]
PASSED xarray/tests/test_dataset.py::test_rolling_reduce[min-1-1-True-2]
PASSED xarray/tests/test_dataset.py::test_rolling_reduce[min-1-1-False-1]
PASSED xarray/tests/test_dataset.py::test_rolling_reduce[min-1-1-False-2]
PASSED xarray/tests/test_dataset.py::test_rolling_reduce[min-1-2-True-1]
PASSED xarray/tests/test_dataset.py::test_rolling_reduce[min-1-2-True-2]
PASSED xarray/tests/test_dataset.py::test_rolling_reduce[min-1-2-False-1]
PASSED xarray/tests/test_dataset.py::test_rolling_reduce[min-1-2-False-2]
PASSED xarray/tests/test_dataset.py::test_rolling_reduce[min-1-3-True-1]
PASSED xarray/tests/test_dataset.py::test_rolling_reduce[min-1-3-True-2]
PASSED xarray/tests/test_dataset.py::test_rolling_reduce[min-1-3-False-1]
PASSED xarray/tests/test_dataset.py::test_rolling_reduce[min-1-3-False-2]
PASSED xarray/tests/test_dataset.py::test_rolling_reduce[min-2-None-True-1]
PASSED xarray/tests/test_dataset.py::test_rolling_reduce[min-2-None-True-2]
PASSED xarray/tests/test_dataset.py::test_rolling_reduce[min-2-None-False-1]
PASSED xarray/tests/test_dataset.py::test_rolling_reduce[min-2-None-False-2]
PASSED xarray/tests/test_dataset.py::test_rolling_reduce[min-2-1-True-1]
PASSED xarray/tests/test_dataset.py::test_rolling_reduce[min-2-1-True-2]
PASSED xarray/tests/test_dataset.py::test_rolling_reduce[min-2-1-False-1]
PASSED xarray/tests/test_dataset.py::test_rolling_reduce[min-2-1-False-2]
PASSED xarray/tests/test_dataset.py::test_rolling_reduce[min-2-2-True-1]
PASSED xarray/tests/test_dataset.py::test_rolling_reduce[min-2-2-True-2]
PASSED xarray/tests/test_dataset.py::test_rolling_reduce[min-2-2-False-1]
PASSED xarray/tests/test_dataset.py::test_rolling_reduce[min-2-2-False-2]
PASSED xarray/tests/test_dataset.py::test_rolling_reduce[min-2-3-True-1]
PASSED xarray/tests/test_dataset.py::test_rolling_reduce[min-2-3-True-2]
PASSED xarray/tests/test_dataset.py::test_rolling_reduce[min-2-3-False-1]
PASSED xarray/tests/test_dataset.py::test_rolling_reduce[min-2-3-False-2]
PASSED xarray/tests/test_dataset.py::test_rolling_reduce[min-3-None-True-1]
PASSED xarray/tests/test_dataset.py::test_rolling_reduce[min-3-None-True-2]
PASSED xarray/tests/test_dataset.py::test_rolling_reduce[min-3-None-False-1]
PASSED xarray/tests/test_dataset.py::test_rolling_reduce[min-3-None-False-2]
PASSED xarray/tests/test_dataset.py::test_rolling_reduce[min-3-1-True-1]
PASSED xarray/tests/test_dataset.py::test_rolling_reduce[min-3-1-True-2]
PASSED xarray/tests/test_dataset.py::test_rolling_reduce[min-3-1-False-1]
PASSED xarray/tests/test_dataset.py::test_rolling_reduce[min-3-1-False-2]
PASSED xarray/tests/test_dataset.py::test_rolling_reduce[min-3-2-True-1]
PASSED xarray/tests/test_dataset.py::test_rolling_reduce[min-3-2-True-2]
PASSED xarray/tests/test_dataset.py::test_rolling_reduce[min-3-2-False-1]
PASSED xarray/tests/test_dataset.py::test_rolling_reduce[min-3-2-False-2]
PASSED xarray/tests/test_dataset.py::test_rolling_reduce[min-3-3-True-1]
PASSED xarray/tests/test_dataset.py::test_rolling_reduce[min-3-3-True-2]
PASSED xarray/tests/test_dataset.py::test_rolling_reduce[min-3-3-False-1]
PASSED xarray/tests/test_dataset.py::test_rolling_reduce[min-3-3-False-2]
PASSED xarray/tests/test_dataset.py::test_rolling_reduce[min-4-None-True-1]
PASSED xarray/tests/test_dataset.py::test_rolling_reduce[min-4-None-True-2]
PASSED xarray/tests/test_dataset.py::test_rolling_reduce[min-4-None-False-1]
PASSED xarray/tests/test_dataset.py::test_rolling_reduce[min-4-None-False-2]
PASSED xarray/tests/test_dataset.py::test_rolling_reduce[min-4-1-True-1]
PASSED xarray/tests/test_dataset.py::test_rolling_reduce[min-4-1-True-2]
PASSED xarray/tests/test_dataset.py::test_rolling_reduce[min-4-1-False-1]
PASSED xarray/tests/test_dataset.py::test_rolling_reduce[min-4-1-False-2]
PASSED xarray/tests/test_dataset.py::test_rolling_reduce[min-4-2-True-1]
PASSED xarray/tests/test_dataset.py::test_rolling_reduce[min-4-2-True-2]
PASSED xarray/tests/test_dataset.py::test_rolling_reduce[min-4-2-False-1]
PASSED xarray/tests/test_dataset.py::test_rolling_reduce[min-4-2-False-2]
PASSED xarray/tests/test_dataset.py::test_rolling_reduce[min-4-3-True-1]
PASSED xarray/tests/test_dataset.py::test_rolling_reduce[min-4-3-True-2]
PASSED xarray/tests/test_dataset.py::test_rolling_reduce[min-4-3-False-1]
PASSED xarray/tests/test_dataset.py::test_rolling_reduce[min-4-3-False-2]
PASSED xarray/tests/test_dataset.py::test_rolling_reduce[max-1-None-True-1]
PASSED xarray/tests/test_dataset.py::test_rolling_reduce[max-1-None-True-2]
PASSED xarray/tests/test_dataset.py::test_rolling_reduce[max-1-None-False-1]
PASSED xarray/tests/test_dataset.py::test_rolling_reduce[max-1-None-False-2]
PASSED xarray/tests/test_dataset.py::test_rolling_reduce[max-1-1-True-1]
PASSED xarray/tests/test_dataset.py::test_rolling_reduce[max-1-1-True-2]
PASSED xarray/tests/test_dataset.py::test_rolling_reduce[max-1-1-False-1]
PASSED xarray/tests/test_dataset.py::test_rolling_reduce[max-1-1-False-2]
PASSED xarray/tests/test_dataset.py::test_rolling_reduce[max-1-2-True-1]
PASSED xarray/tests/test_dataset.py::test_rolling_reduce[max-1-2-True-2]
PASSED xarray/tests/test_dataset.py::test_rolling_reduce[max-1-2-False-1]
PASSED xarray/tests/test_dataset.py::test_rolling_reduce[max-1-2-False-2]
PASSED xarray/tests/test_dataset.py::test_rolling_reduce[max-1-3-True-1]
PASSED xarray/tests/test_dataset.py::test_rolling_reduce[max-1-3-True-2]
PASSED xarray/tests/test_dataset.py::test_rolling_reduce[max-1-3-False-1]
PASSED xarray/tests/test_dataset.py::test_rolling_reduce[max-1-3-False-2]
PASSED xarray/tests/test_dataset.py::test_rolling_reduce[max-2-None-True-1]
PASSED xarray/tests/test_dataset.py::test_rolling_reduce[max-2-None-True-2]
PASSED xarray/tests/test_dataset.py::test_rolling_reduce[max-2-None-False-1]
PASSED xarray/tests/test_dataset.py::test_rolling_reduce[max-2-None-False-2]
PASSED xarray/tests/test_dataset.py::test_rolling_reduce[max-2-1-True-1]
PASSED xarray/tests/test_dataset.py::test_rolling_reduce[max-2-1-True-2]
PASSED xarray/tests/test_dataset.py::test_rolling_reduce[max-2-1-False-1]
PASSED xarray/tests/test_dataset.py::test_rolling_reduce[max-2-1-False-2]
PASSED xarray/tests/test_dataset.py::test_rolling_reduce[max-2-2-True-1]
PASSED xarray/tests/test_dataset.py::test_rolling_reduce[max-2-2-True-2]
PASSED xarray/tests/test_dataset.py::test_rolling_reduce[max-2-2-False-1]
PASSED xarray/tests/test_dataset.py::test_rolling_reduce[max-2-2-False-2]
PASSED xarray/tests/test_dataset.py::test_rolling_reduce[max-2-3-True-1]
PASSED xarray/tests/test_dataset.py::test_rolling_reduce[max-2-3-True-2]
PASSED xarray/tests/test_dataset.py::test_rolling_reduce[max-2-3-False-1]
PASSED xarray/tests/test_dataset.py::test_rolling_reduce[max-2-3-False-2]
PASSED xarray/tests/test_dataset.py::test_rolling_reduce[max-3-None-True-1]
PASSED xarray/tests/test_dataset.py::test_rolling_reduce[max-3-None-True-2]
PASSED xarray/tests/test_dataset.py::test_rolling_reduce[max-3-None-False-1]
PASSED xarray/tests/test_dataset.py::test_rolling_reduce[max-3-None-False-2]
PASSED xarray/tests/test_dataset.py::test_rolling_reduce[max-3-1-True-1]
PASSED xarray/tests/test_dataset.py::test_rolling_reduce[max-3-1-True-2]
PASSED xarray/tests/test_dataset.py::test_rolling_reduce[max-3-1-False-1]
PASSED xarray/tests/test_dataset.py::test_rolling_reduce[max-3-1-False-2]
PASSED xarray/tests/test_dataset.py::test_rolling_reduce[max-3-2-True-1]
PASSED xarray/tests/test_dataset.py::test_rolling_reduce[max-3-2-True-2]
PASSED xarray/tests/test_dataset.py::test_rolling_reduce[max-3-2-False-1]
PASSED xarray/tests/test_dataset.py::test_rolling_reduce[max-3-2-False-2]
PASSED xarray/tests/test_dataset.py::test_rolling_reduce[max-3-3-True-1]
PASSED xarray/tests/test_dataset.py::test_rolling_reduce[max-3-3-True-2]
PASSED xarray/tests/test_dataset.py::test_rolling_reduce[max-3-3-False-1]
PASSED xarray/tests/test_dataset.py::test_rolling_reduce[max-3-3-False-2]
PASSED xarray/tests/test_dataset.py::test_rolling_reduce[max-4-None-True-1]
PASSED xarray/tests/test_dataset.py::test_rolling_reduce[max-4-None-True-2]
PASSED xarray/tests/test_dataset.py::test_rolling_reduce[max-4-None-False-1]
PASSED xarray/tests/test_dataset.py::test_rolling_reduce[max-4-None-False-2]
PASSED xarray/tests/test_dataset.py::test_rolling_reduce[max-4-1-True-1]
PASSED xarray/tests/test_dataset.py::test_rolling_reduce[max-4-1-True-2]
PASSED xarray/tests/test_dataset.py::test_rolling_reduce[max-4-1-False-1]
PASSED xarray/tests/test_dataset.py::test_rolling_reduce[max-4-1-False-2]
PASSED xarray/tests/test_dataset.py::test_rolling_reduce[max-4-2-True-1]
PASSED xarray/tests/test_dataset.py::test_rolling_reduce[max-4-2-True-2]
PASSED xarray/tests/test_dataset.py::test_rolling_reduce[max-4-2-False-1]
PASSED xarray/tests/test_dataset.py::test_rolling_reduce[max-4-2-False-2]
PASSED xarray/tests/test_dataset.py::test_rolling_reduce[max-4-3-True-1]
PASSED xarray/tests/test_dataset.py::test_rolling_reduce[max-4-3-True-2]
PASSED xarray/tests/test_dataset.py::test_rolling_reduce[max-4-3-False-1]
PASSED xarray/tests/test_dataset.py::test_rolling_reduce[max-4-3-False-2]
PASSED xarray/tests/test_dataset.py::test_rolling_reduce[median-1-None-True-1]
PASSED xarray/tests/test_dataset.py::test_rolling_reduce[median-1-None-True-2]
PASSED xarray/tests/test_dataset.py::test_rolling_reduce[median-1-None-False-1]
PASSED xarray/tests/test_dataset.py::test_rolling_reduce[median-1-None-False-2]
PASSED xarray/tests/test_dataset.py::test_rolling_reduce[median-1-1-True-1]
PASSED xarray/tests/test_dataset.py::test_rolling_reduce[median-1-1-True-2]
PASSED xarray/tests/test_dataset.py::test_rolling_reduce[median-1-1-False-1]
PASSED xarray/tests/test_dataset.py::test_rolling_reduce[median-1-1-False-2]
PASSED xarray/tests/test_dataset.py::test_rolling_reduce[median-1-2-True-1]
PASSED xarray/tests/test_dataset.py::test_rolling_reduce[median-1-2-True-2]
PASSED xarray/tests/test_dataset.py::test_rolling_reduce[median-1-2-False-1]
PASSED xarray/tests/test_dataset.py::test_rolling_reduce[median-1-2-False-2]
PASSED xarray/tests/test_dataset.py::test_rolling_reduce[median-1-3-True-1]
PASSED xarray/tests/test_dataset.py::test_rolling_reduce[median-1-3-True-2]
PASSED xarray/tests/test_dataset.py::test_rolling_reduce[median-1-3-False-1]
PASSED xarray/tests/test_dataset.py::test_rolling_reduce[median-1-3-False-2]
PASSED xarray/tests/test_dataset.py::test_rolling_reduce[median-2-None-True-1]
PASSED xarray/tests/test_dataset.py::test_rolling_reduce[median-2-None-True-2]
PASSED xarray/tests/test_dataset.py::test_rolling_reduce[median-2-None-False-1]
PASSED xarray/tests/test_dataset.py::test_rolling_reduce[median-2-None-False-2]
PASSED xarray/tests/test_dataset.py::test_rolling_reduce[median-2-1-True-1]
PASSED xarray/tests/test_dataset.py::test_rolling_reduce[median-2-1-True-2]
PASSED xarray/tests/test_dataset.py::test_rolling_reduce[median-2-1-False-1]
PASSED xarray/tests/test_dataset.py::test_rolling_reduce[median-2-1-False-2]
PASSED xarray/tests/test_dataset.py::test_rolling_reduce[median-2-2-True-1]
PASSED xarray/tests/test_dataset.py::test_rolling_reduce[median-2-2-True-2]
PASSED xarray/tests/test_dataset.py::test_rolling_reduce[median-2-2-False-1]
PASSED xarray/tests/test_dataset.py::test_rolling_reduce[median-2-2-False-2]
PASSED xarray/tests/test_dataset.py::test_rolling_reduce[median-2-3-True-1]
PASSED xarray/tests/test_dataset.py::test_rolling_reduce[median-2-3-True-2]
PASSED xarray/tests/test_dataset.py::test_rolling_reduce[median-2-3-False-1]
PASSED xarray/tests/test_dataset.py::test_rolling_reduce[median-2-3-False-2]
PASSED xarray/tests/test_dataset.py::test_rolling_reduce[median-3-None-True-1]
PASSED xarray/tests/test_dataset.py::test_rolling_reduce[median-3-None-True-2]
PASSED xarray/tests/test_dataset.py::test_rolling_reduce[median-3-None-False-1]
PASSED xarray/tests/test_dataset.py::test_rolling_reduce[median-3-None-False-2]
PASSED xarray/tests/test_dataset.py::test_rolling_reduce[median-3-1-True-1]
PASSED xarray/tests/test_dataset.py::test_rolling_reduce[median-3-1-True-2]
PASSED xarray/tests/test_dataset.py::test_rolling_reduce[median-3-1-False-1]
PASSED xarray/tests/test_dataset.py::test_rolling_reduce[median-3-1-False-2]
PASSED xarray/tests/test_dataset.py::test_rolling_reduce[median-3-2-True-1]
PASSED xarray/tests/test_dataset.py::test_rolling_reduce[median-3-2-True-2]
PASSED xarray/tests/test_dataset.py::test_rolling_reduce[median-3-2-False-1]
PASSED xarray/tests/test_dataset.py::test_rolling_reduce[median-3-2-False-2]
PASSED xarray/tests/test_dataset.py::test_rolling_reduce[median-3-3-True-1]
PASSED xarray/tests/test_dataset.py::test_rolling_reduce[median-3-3-True-2]
PASSED xarray/tests/test_dataset.py::test_rolling_reduce[median-3-3-False-1]
PASSED xarray/tests/test_dataset.py::test_rolling_reduce[median-3-3-False-2]
PASSED xarray/tests/test_dataset.py::test_rolling_reduce[median-4-None-True-1]
PASSED xarray/tests/test_dataset.py::test_rolling_reduce[median-4-None-True-2]
PASSED xarray/tests/test_dataset.py::test_rolling_reduce[median-4-None-False-1]
PASSED xarray/tests/test_dataset.py::test_rolling_reduce[median-4-None-False-2]
PASSED xarray/tests/test_dataset.py::test_rolling_reduce[median-4-1-True-1]
PASSED xarray/tests/test_dataset.py::test_rolling_reduce[median-4-1-True-2]
PASSED xarray/tests/test_dataset.py::test_rolling_reduce[median-4-1-False-1]
PASSED xarray/tests/test_dataset.py::test_rolling_reduce[median-4-1-False-2]
PASSED xarray/tests/test_dataset.py::test_rolling_reduce[median-4-2-True-1]
PASSED xarray/tests/test_dataset.py::test_rolling_reduce[median-4-2-True-2]
PASSED xarray/tests/test_dataset.py::test_rolling_reduce[median-4-2-False-1]
PASSED xarray/tests/test_dataset.py::test_rolling_reduce[median-4-2-False-2]
PASSED xarray/tests/test_dataset.py::test_rolling_reduce[median-4-3-True-1]
PASSED xarray/tests/test_dataset.py::test_rolling_reduce[median-4-3-True-2]
PASSED xarray/tests/test_dataset.py::test_rolling_reduce[median-4-3-False-1]
PASSED xarray/tests/test_dataset.py::test_rolling_reduce[median-4-3-False-2]
PASSED xarray/tests/test_dataset.py::test_ndrolling_reduce[True-sum-None-True-2]
PASSED xarray/tests/test_dataset.py::test_ndrolling_reduce[True-sum-None-False-2]
PASSED xarray/tests/test_dataset.py::test_ndrolling_reduce[True-sum-1-True-2]
PASSED xarray/tests/test_dataset.py::test_ndrolling_reduce[True-sum-1-False-2]
PASSED xarray/tests/test_dataset.py::test_ndrolling_reduce[True-max-None-True-2]
PASSED xarray/tests/test_dataset.py::test_ndrolling_reduce[True-max-None-False-2]
PASSED xarray/tests/test_dataset.py::test_ndrolling_reduce[True-max-1-True-2]
PASSED xarray/tests/test_dataset.py::test_ndrolling_reduce[True-max-1-False-2]
PASSED xarray/tests/test_dataset.py::test_ndrolling_reduce[False-sum-None-True-2]
PASSED xarray/tests/test_dataset.py::test_ndrolling_reduce[False-sum-None-False-2]
PASSED xarray/tests/test_dataset.py::test_ndrolling_reduce[False-sum-1-True-2]
PASSED xarray/tests/test_dataset.py::test_ndrolling_reduce[False-sum-1-False-2]
PASSED xarray/tests/test_dataset.py::test_ndrolling_reduce[False-max-None-True-2]
PASSED xarray/tests/test_dataset.py::test_ndrolling_reduce[False-max-None-False-2]
PASSED xarray/tests/test_dataset.py::test_ndrolling_reduce[False-max-1-True-2]
PASSED xarray/tests/test_dataset.py::test_ndrolling_reduce[False-max-1-False-2]
PASSED xarray/tests/test_dataset.py::test_ndrolling_construct[True-nan-True]
PASSED xarray/tests/test_dataset.py::test_ndrolling_construct[True-nan-False]
PASSED xarray/tests/test_dataset.py::test_ndrolling_construct[True-nan-center2]
PASSED xarray/tests/test_dataset.py::test_ndrolling_construct[True-0.0-True]
PASSED xarray/tests/test_dataset.py::test_ndrolling_construct[True-0.0-False]
PASSED xarray/tests/test_dataset.py::test_ndrolling_construct[True-0.0-center2]
PASSED xarray/tests/test_dataset.py::test_ndrolling_construct[False-nan-True]
PASSED xarray/tests/test_dataset.py::test_ndrolling_construct[False-nan-False]
PASSED xarray/tests/test_dataset.py::test_ndrolling_construct[False-nan-center2]
PASSED xarray/tests/test_dataset.py::test_ndrolling_construct[False-0.0-True]
PASSED xarray/tests/test_dataset.py::test_ndrolling_construct[False-0.0-False]
PASSED xarray/tests/test_dataset.py::test_ndrolling_construct[False-0.0-center2]
PASSED xarray/tests/test_dataset.py::test_raise_no_warning_assert_close[2]
PASSED xarray/tests/test_dataset.py::test_differentiate[1-True]
PASSED xarray/tests/test_dataset.py::test_differentiate[1-False]
PASSED xarray/tests/test_dataset.py::test_differentiate[2-True]
PASSED xarray/tests/test_dataset.py::test_differentiate[2-False]
PASSED xarray/tests/test_dataset.py::test_differentiate_datetime[True]
PASSED xarray/tests/test_dataset.py::test_differentiate_datetime[False]
PASSED xarray/tests/test_dataset.py::test_differentiate_cftime[True]
PASSED xarray/tests/test_dataset.py::test_differentiate_cftime[False]
PASSED xarray/tests/test_dataset.py::test_integrate[True]
PASSED xarray/tests/test_dataset.py::test_integrate[False]
PASSED xarray/tests/test_dataset.py::test_trapz_datetime[np-True]
PASSED xarray/tests/test_dataset.py::test_trapz_datetime[np-False]
PASSED xarray/tests/test_dataset.py::test_trapz_datetime[cftime-True]
PASSED xarray/tests/test_dataset.py::test_trapz_datetime[cftime-False]
PASSED xarray/tests/test_dataset.py::test_no_dict
PASSED xarray/tests/test_dataset.py::test_subclass_slots
PASSED xarray/tests/test_dataset.py::test_weakref
PASSED xarray/tests/test_dataset.py::test_deepcopy_obj_array
PASSED xarray/tests/test_interp.py::test_keywargs
PASSED xarray/tests/test_interp.py::test_interpolate_1d[0-x-linear]
PASSED xarray/tests/test_interp.py::test_interpolate_1d[0-x-cubic]
PASSED xarray/tests/test_interp.py::test_interpolate_1d[0-y-linear]
PASSED xarray/tests/test_interp.py::test_interpolate_1d[0-y-cubic]
PASSED xarray/tests/test_interp.py::test_interpolate_1d[1-x-linear]
PASSED xarray/tests/test_interp.py::test_interpolate_1d[1-x-cubic]
PASSED xarray/tests/test_interp.py::test_interpolate_1d[1-y-linear]
PASSED xarray/tests/test_interp.py::test_interpolate_1d[1-y-cubic]
PASSED xarray/tests/test_interp.py::test_interpolate_1d_methods[cubic]
PASSED xarray/tests/test_interp.py::test_interpolate_1d_methods[zero]
PASSED xarray/tests/test_interp.py::test_interpolate_vectorize[False]
PASSED xarray/tests/test_interp.py::test_interpolate_vectorize[True]
PASSED xarray/tests/test_interp.py::test_interpolate_nd[3]
PASSED xarray/tests/test_interp.py::test_interpolate_nd[4]
PASSED xarray/tests/test_interp.py::test_interpolate_nd_nd
PASSED xarray/tests/test_interp.py::test_interpolate_nd_with_nan
PASSED xarray/tests/test_interp.py::test_interpolate_scalar[0-linear]
PASSED xarray/tests/test_interp.py::test_interpolate_scalar[1-linear]
PASSED xarray/tests/test_interp.py::test_interpolate_nd_scalar[3-linear]
PASSED xarray/tests/test_interp.py::test_interpolate_nd_scalar[4-linear]
PASSED xarray/tests/test_interp.py::test_nans[True]
PASSED xarray/tests/test_interp.py::test_nans[False]
PASSED xarray/tests/test_interp.py::test_errors[True]
PASSED xarray/tests/test_interp.py::test_errors[False]
PASSED xarray/tests/test_interp.py::test_dtype
PASSED xarray/tests/test_interp.py::test_sorted
PASSED xarray/tests/test_interp.py::test_dimension_wo_coords
PASSED xarray/tests/test_interp.py::test_dataset
PASSED xarray/tests/test_interp.py::test_interpolate_dimorder[0]
PASSED xarray/tests/test_interp.py::test_interpolate_dimorder[3]
PASSED xarray/tests/test_interp.py::test_interp_like
PASSED xarray/tests/test_interp.py::test_datetime[x_new0-expected0]
PASSED xarray/tests/test_interp.py::test_datetime[x_new1-expected1]
PASSED xarray/tests/test_interp.py::test_datetime[x_new2-expected2]
PASSED xarray/tests/test_interp.py::test_datetime[x_new3-expected3]
PASSED xarray/tests/test_interp.py::test_datetime[x_new4-0.5]
PASSED xarray/tests/test_interp.py::test_datetime_single_string
PASSED xarray/tests/test_interp.py::test_cftime
PASSED xarray/tests/test_interp.py::test_cftime_type_error
PASSED xarray/tests/test_interp.py::test_cftime_list_of_strings
PASSED xarray/tests/test_interp.py::test_cftime_single_string
PASSED xarray/tests/test_interp.py::test_datetime_to_non_datetime_error
PASSED xarray/tests/test_interp.py::test_cftime_to_non_cftime_error
PASSED xarray/tests/test_interp.py::test_datetime_interp_noerror
PASSED xarray/tests/test_interp.py::test_3641
PASSED xarray/tests/test_interp.py::test_decompose[nearest]
PASSED xarray/tests/test_interp.py::test_decompose[linear]
PASSED xarray/tests/test_interp.py::test_interpolate_chunk_1d[1-1-0-True-linear]
PASSED xarray/tests/test_interp.py::test_interpolate_chunk_1d[1-1-0-True-nearest]
PASSED xarray/tests/test_interp.py::test_interpolate_chunk_1d[1-1-0-True-zero]
PASSED xarray/tests/test_interp.py::test_interpolate_chunk_1d[1-1-0-True-slinear]
PASSED xarray/tests/test_interp.py::test_interpolate_chunk_1d[1-1-0-True-quadratic]
PASSED xarray/tests/test_interp.py::test_interpolate_chunk_1d[1-1-0-True-cubic]
PASSED xarray/tests/test_interp.py::test_interpolate_chunk_1d[1-1-0-False-linear]
PASSED xarray/tests/test_interp.py::test_interpolate_chunk_1d[1-1-0-False-nearest]
PASSED xarray/tests/test_interp.py::test_interpolate_chunk_1d[1-1-0-False-zero]
PASSED xarray/tests/test_interp.py::test_interpolate_chunk_1d[1-1-0-False-slinear]
PASSED xarray/tests/test_interp.py::test_interpolate_chunk_1d[1-1-0-False-quadratic]
PASSED xarray/tests/test_interp.py::test_interpolate_chunk_1d[1-1-0-False-cubic]
PASSED xarray/tests/test_interp.py::test_interpolate_chunk_1d[1-1-1-True-linear]
PASSED xarray/tests/test_interp.py::test_interpolate_chunk_1d[1-1-1-True-nearest]
PASSED xarray/tests/test_interp.py::test_interpolate_chunk_1d[1-1-1-True-zero]
PASSED xarray/tests/test_interp.py::test_interpolate_chunk_1d[1-1-1-True-slinear]
PASSED xarray/tests/test_interp.py::test_interpolate_chunk_1d[1-1-1-True-quadratic]
PASSED xarray/tests/test_interp.py::test_interpolate_chunk_1d[1-1-1-True-cubic]
PASSED xarray/tests/test_interp.py::test_interpolate_chunk_1d[1-1-1-False-linear]
PASSED xarray/tests/test_interp.py::test_interpolate_chunk_1d[1-1-1-False-nearest]
PASSED xarray/tests/test_interp.py::test_interpolate_chunk_1d[1-1-1-False-zero]
PASSED xarray/tests/test_interp.py::test_interpolate_chunk_1d[1-1-1-False-slinear]
PASSED xarray/tests/test_interp.py::test_interpolate_chunk_1d[1-1-1-False-quadratic]
PASSED xarray/tests/test_interp.py::test_interpolate_chunk_1d[1-1-1-False-cubic]
PASSED xarray/tests/test_interp.py::test_interpolate_chunk_1d[2-1-0-True-linear]
PASSED xarray/tests/test_interp.py::test_interpolate_chunk_1d[2-1-0-True-nearest]
PASSED xarray/tests/test_interp.py::test_interpolate_chunk_1d[2-1-0-True-zero]
PASSED xarray/tests/test_interp.py::test_interpolate_chunk_1d[2-1-0-True-slinear]
PASSED xarray/tests/test_interp.py::test_interpolate_chunk_1d[2-1-0-True-quadratic]
PASSED xarray/tests/test_interp.py::test_interpolate_chunk_1d[2-1-0-True-cubic]
PASSED xarray/tests/test_interp.py::test_interpolate_chunk_1d[2-1-0-False-linear]
PASSED xarray/tests/test_interp.py::test_interpolate_chunk_1d[2-1-0-False-nearest]
PASSED xarray/tests/test_interp.py::test_interpolate_chunk_1d[2-1-0-False-zero]
PASSED xarray/tests/test_interp.py::test_interpolate_chunk_1d[2-1-0-False-slinear]
PASSED xarray/tests/test_interp.py::test_interpolate_chunk_1d[2-1-0-False-quadratic]
PASSED xarray/tests/test_interp.py::test_interpolate_chunk_1d[2-1-0-False-cubic]
PASSED xarray/tests/test_interp.py::test_interpolate_chunk_1d[2-1-1-True-linear]
PASSED xarray/tests/test_interp.py::test_interpolate_chunk_1d[2-1-1-True-nearest]
PASSED xarray/tests/test_interp.py::test_interpolate_chunk_1d[2-1-1-True-zero]
PASSED xarray/tests/test_interp.py::test_interpolate_chunk_1d[2-1-1-True-slinear]
PASSED xarray/tests/test_interp.py::test_interpolate_chunk_1d[2-1-1-True-quadratic]
PASSED xarray/tests/test_interp.py::test_interpolate_chunk_1d[2-1-1-True-cubic]
PASSED xarray/tests/test_interp.py::test_interpolate_chunk_1d[2-1-1-False-linear]
PASSED xarray/tests/test_interp.py::test_interpolate_chunk_1d[2-1-1-False-nearest]
PASSED xarray/tests/test_interp.py::test_interpolate_chunk_1d[2-1-1-False-zero]
PASSED xarray/tests/test_interp.py::test_interpolate_chunk_1d[2-1-1-False-slinear]
PASSED xarray/tests/test_interp.py::test_interpolate_chunk_1d[2-1-1-False-quadratic]
PASSED xarray/tests/test_interp.py::test_interpolate_chunk_1d[2-1-1-False-cubic]
PASSED xarray/tests/test_interp.py::test_interpolate_chunk_1d[2-2-0-True-linear]
PASSED xarray/tests/test_interp.py::test_interpolate_chunk_1d[2-2-0-True-nearest]
PASSED xarray/tests/test_interp.py::test_interpolate_chunk_1d[2-2-0-True-zero]
PASSED xarray/tests/test_interp.py::test_interpolate_chunk_1d[2-2-0-True-slinear]
PASSED xarray/tests/test_interp.py::test_interpolate_chunk_1d[2-2-0-True-quadratic]
PASSED xarray/tests/test_interp.py::test_interpolate_chunk_1d[2-2-0-True-cubic]
PASSED xarray/tests/test_interp.py::test_interpolate_chunk_1d[2-2-0-False-linear]
PASSED xarray/tests/test_interp.py::test_interpolate_chunk_1d[2-2-0-False-nearest]
PASSED xarray/tests/test_interp.py::test_interpolate_chunk_1d[2-2-0-False-zero]
PASSED xarray/tests/test_interp.py::test_interpolate_chunk_1d[2-2-0-False-slinear]
PASSED xarray/tests/test_interp.py::test_interpolate_chunk_1d[2-2-0-False-quadratic]
PASSED xarray/tests/test_interp.py::test_interpolate_chunk_1d[2-2-0-False-cubic]
PASSED xarray/tests/test_interp.py::test_interpolate_chunk_1d[2-2-1-True-linear]
PASSED xarray/tests/test_interp.py::test_interpolate_chunk_1d[2-2-1-True-nearest]
PASSED xarray/tests/test_interp.py::test_interpolate_chunk_1d[2-2-1-True-zero]
PASSED xarray/tests/test_interp.py::test_interpolate_chunk_1d[2-2-1-True-slinear]
PASSED xarray/tests/test_interp.py::test_interpolate_chunk_1d[2-2-1-True-quadratic]
PASSED xarray/tests/test_interp.py::test_interpolate_chunk_1d[2-2-1-True-cubic]
PASSED xarray/tests/test_interp.py::test_interpolate_chunk_1d[2-2-1-False-linear]
PASSED xarray/tests/test_interp.py::test_interpolate_chunk_1d[2-2-1-False-nearest]
PASSED xarray/tests/test_interp.py::test_interpolate_chunk_1d[2-2-1-False-zero]
PASSED xarray/tests/test_interp.py::test_interpolate_chunk_1d[2-2-1-False-slinear]
PASSED xarray/tests/test_interp.py::test_interpolate_chunk_1d[2-2-1-False-quadratic]
PASSED xarray/tests/test_interp.py::test_interpolate_chunk_1d[2-2-1-False-cubic]
PASSED xarray/tests/test_interp.py::test_interpolate_chunk_1d[2-2-2-True-linear]
PASSED xarray/tests/test_interp.py::test_interpolate_chunk_1d[2-2-2-True-nearest]
PASSED xarray/tests/test_interp.py::test_interpolate_chunk_1d[2-2-2-True-zero]
PASSED xarray/tests/test_interp.py::test_interpolate_chunk_1d[2-2-2-True-slinear]
PASSED xarray/tests/test_interp.py::test_interpolate_chunk_1d[2-2-2-True-quadratic]
PASSED xarray/tests/test_interp.py::test_interpolate_chunk_1d[2-2-2-True-cubic]
PASSED xarray/tests/test_interp.py::test_interpolate_chunk_1d[2-2-2-False-linear]
PASSED xarray/tests/test_interp.py::test_interpolate_chunk_1d[2-2-2-False-nearest]
PASSED xarray/tests/test_interp.py::test_interpolate_chunk_1d[2-2-2-False-zero]
PASSED xarray/tests/test_interp.py::test_interpolate_chunk_1d[2-2-2-False-slinear]
PASSED xarray/tests/test_interp.py::test_interpolate_chunk_1d[2-2-2-False-quadratic]
PASSED xarray/tests/test_interp.py::test_interpolate_chunk_1d[2-2-2-False-cubic]
PASSED xarray/tests/test_interp.py::test_interpolate_chunk_1d[3-1-0-True-linear]
PASSED xarray/tests/test_interp.py::test_interpolate_chunk_1d[3-1-0-True-nearest]
PASSED xarray/tests/test_interp.py::test_interpolate_chunk_1d[3-1-0-True-zero]
PASSED xarray/tests/test_interp.py::test_interpolate_chunk_1d[3-1-0-True-slinear]
PASSED xarray/tests/test_interp.py::test_interpolate_chunk_1d[3-1-0-True-quadratic]
PASSED xarray/tests/test_interp.py::test_interpolate_chunk_1d[3-1-0-True-cubic]
PASSED xarray/tests/test_interp.py::test_interpolate_chunk_1d[3-1-0-False-linear]
PASSED xarray/tests/test_interp.py::test_interpolate_chunk_1d[3-1-0-False-nearest]
PASSED xarray/tests/test_interp.py::test_interpolate_chunk_1d[3-1-0-False-zero]
PASSED xarray/tests/test_interp.py::test_interpolate_chunk_1d[3-1-0-False-slinear]
PASSED xarray/tests/test_interp.py::test_interpolate_chunk_1d[3-1-0-False-quadratic]
PASSED xarray/tests/test_interp.py::test_interpolate_chunk_1d[3-1-0-False-cubic]
PASSED xarray/tests/test_interp.py::test_interpolate_chunk_1d[3-1-1-True-linear]
PASSED xarray/tests/test_interp.py::test_interpolate_chunk_1d[3-1-1-True-nearest]
PASSED xarray/tests/test_interp.py::test_interpolate_chunk_1d[3-1-1-True-zero]
PASSED xarray/tests/test_interp.py::test_interpolate_chunk_1d[3-1-1-True-slinear]
PASSED xarray/tests/test_interp.py::test_interpolate_chunk_1d[3-1-1-True-quadratic]
PASSED xarray/tests/test_interp.py::test_interpolate_chunk_1d[3-1-1-True-cubic]
PASSED xarray/tests/test_interp.py::test_interpolate_chunk_1d[3-1-1-False-linear]
PASSED xarray/tests/test_interp.py::test_interpolate_chunk_1d[3-1-1-False-nearest]
PASSED xarray/tests/test_interp.py::test_interpolate_chunk_1d[3-1-1-False-zero]
PASSED xarray/tests/test_interp.py::test_interpolate_chunk_1d[3-1-1-False-slinear]
PASSED xarray/tests/test_interp.py::test_interpolate_chunk_1d[3-1-1-False-quadratic]
PASSED xarray/tests/test_interp.py::test_interpolate_chunk_1d[3-1-1-False-cubic]
PASSED xarray/tests/test_interp.py::test_interpolate_chunk_1d[3-2-0-True-linear]
PASSED xarray/tests/test_interp.py::test_interpolate_chunk_1d[3-2-0-True-nearest]
PASSED xarray/tests/test_interp.py::test_interpolate_chunk_1d[3-2-0-True-zero]
PASSED xarray/tests/test_interp.py::test_interpolate_chunk_1d[3-2-0-True-slinear]
PASSED xarray/tests/test_interp.py::test_interpolate_chunk_1d[3-2-0-True-quadratic]
PASSED xarray/tests/test_interp.py::test_interpolate_chunk_1d[3-2-0-True-cubic]
PASSED xarray/tests/test_interp.py::test_interpolate_chunk_1d[3-2-0-False-linear]
PASSED xarray/tests/test_interp.py::test_interpolate_chunk_1d[3-2-0-False-nearest]
PASSED xarray/tests/test_interp.py::test_interpolate_chunk_1d[3-2-0-False-zero]
PASSED xarray/tests/test_interp.py::test_interpolate_chunk_1d[3-2-0-False-slinear]
PASSED xarray/tests/test_interp.py::test_interpolate_chunk_1d[3-2-0-False-quadratic]
PASSED xarray/tests/test_interp.py::test_interpolate_chunk_1d[3-2-0-False-cubic]
PASSED xarray/tests/test_interp.py::test_interpolate_chunk_1d[3-2-1-True-linear]
PASSED xarray/tests/test_interp.py::test_interpolate_chunk_1d[3-2-1-True-nearest]
PASSED xarray/tests/test_interp.py::test_interpolate_chunk_1d[3-2-1-True-zero]
PASSED xarray/tests/test_interp.py::test_interpolate_chunk_1d[3-2-1-True-slinear]
PASSED xarray/tests/test_interp.py::test_interpolate_chunk_1d[3-2-1-True-quadratic]
PASSED xarray/tests/test_interp.py::test_interpolate_chunk_1d[3-2-1-True-cubic]
PASSED xarray/tests/test_interp.py::test_interpolate_chunk_1d[3-2-1-False-linear]
PASSED xarray/tests/test_interp.py::test_interpolate_chunk_1d[3-2-1-False-nearest]
PASSED xarray/tests/test_interp.py::test_interpolate_chunk_1d[3-2-1-False-zero]
PASSED xarray/tests/test_interp.py::test_interpolate_chunk_1d[3-2-1-False-slinear]
PASSED xarray/tests/test_interp.py::test_interpolate_chunk_1d[3-2-1-False-quadratic]
PASSED xarray/tests/test_interp.py::test_interpolate_chunk_1d[3-2-1-False-cubic]
PASSED xarray/tests/test_interp.py::test_interpolate_chunk_1d[3-2-2-True-linear]
PASSED xarray/tests/test_interp.py::test_interpolate_chunk_1d[3-2-2-True-nearest]
PASSED xarray/tests/test_interp.py::test_interpolate_chunk_1d[3-2-2-True-zero]
PASSED xarray/tests/test_interp.py::test_interpolate_chunk_1d[3-2-2-True-slinear]
PASSED xarray/tests/test_interp.py::test_interpolate_chunk_1d[3-2-2-True-quadratic]
PASSED xarray/tests/test_interp.py::test_interpolate_chunk_1d[3-2-2-True-cubic]
PASSED xarray/tests/test_interp.py::test_interpolate_chunk_1d[3-2-2-False-linear]
PASSED xarray/tests/test_interp.py::test_interpolate_chunk_1d[3-2-2-False-nearest]
PASSED xarray/tests/test_interp.py::test_interpolate_chunk_1d[3-2-2-False-zero]
PASSED xarray/tests/test_interp.py::test_interpolate_chunk_1d[3-2-2-False-slinear]
PASSED xarray/tests/test_interp.py::test_interpolate_chunk_1d[3-2-2-False-quadratic]
PASSED xarray/tests/test_interp.py::test_interpolate_chunk_1d[3-2-2-False-cubic]
PASSED xarray/tests/test_interp.py::test_interpolate_chunk_1d[3-3-0-True-linear]
PASSED xarray/tests/test_interp.py::test_interpolate_chunk_1d[3-3-0-True-nearest]
PASSED xarray/tests/test_interp.py::test_interpolate_chunk_1d[3-3-0-True-zero]
PASSED xarray/tests/test_interp.py::test_interpolate_chunk_1d[3-3-0-True-slinear]
PASSED xarray/tests/test_interp.py::test_interpolate_chunk_1d[3-3-0-True-quadratic]
PASSED xarray/tests/test_interp.py::test_interpolate_chunk_1d[3-3-0-True-cubic]
PASSED xarray/tests/test_interp.py::test_interpolate_chunk_1d[3-3-0-False-linear]
PASSED xarray/tests/test_interp.py::test_interpolate_chunk_1d[3-3-0-False-nearest]
PASSED xarray/tests/test_interp.py::test_interpolate_chunk_1d[3-3-0-False-zero]
PASSED xarray/tests/test_interp.py::test_interpolate_chunk_1d[3-3-0-False-slinear]
PASSED xarray/tests/test_interp.py::test_interpolate_chunk_1d[3-3-0-False-quadratic]
PASSED xarray/tests/test_interp.py::test_interpolate_chunk_1d[3-3-0-False-cubic]
PASSED xarray/tests/test_interp.py::test_interpolate_chunk_1d[3-3-1-True-linear]
PASSED xarray/tests/test_interp.py::test_interpolate_chunk_1d[3-3-1-True-nearest]
PASSED xarray/tests/test_interp.py::test_interpolate_chunk_1d[3-3-1-True-zero]
PASSED xarray/tests/test_interp.py::test_interpolate_chunk_1d[3-3-1-True-slinear]
PASSED xarray/tests/test_interp.py::test_interpolate_chunk_1d[3-3-1-True-quadratic]
PASSED xarray/tests/test_interp.py::test_interpolate_chunk_1d[3-3-1-True-cubic]
PASSED xarray/tests/test_interp.py::test_interpolate_chunk_1d[3-3-1-False-linear]
PASSED xarray/tests/test_interp.py::test_interpolate_chunk_1d[3-3-1-False-nearest]
PASSED xarray/tests/test_interp.py::test_interpolate_chunk_1d[3-3-1-False-zero]
PASSED xarray/tests/test_interp.py::test_interpolate_chunk_1d[3-3-1-False-slinear]
PASSED xarray/tests/test_interp.py::test_interpolate_chunk_1d[3-3-1-False-quadratic]
PASSED xarray/tests/test_interp.py::test_interpolate_chunk_1d[3-3-1-False-cubic]
PASSED xarray/tests/test_interp.py::test_interpolate_chunk_1d[3-3-2-True-linear]
PASSED xarray/tests/test_interp.py::test_interpolate_chunk_1d[3-3-2-True-nearest]
PASSED xarray/tests/test_interp.py::test_interpolate_chunk_1d[3-3-2-True-zero]
PASSED xarray/tests/test_interp.py::test_interpolate_chunk_1d[3-3-2-True-slinear]
PASSED xarray/tests/test_interp.py::test_interpolate_chunk_1d[3-3-2-True-quadratic]
PASSED xarray/tests/test_interp.py::test_interpolate_chunk_1d[3-3-2-True-cubic]
PASSED xarray/tests/test_interp.py::test_interpolate_chunk_1d[3-3-2-False-linear]
PASSED xarray/tests/test_interp.py::test_interpolate_chunk_1d[3-3-2-False-nearest]
PASSED xarray/tests/test_interp.py::test_interpolate_chunk_1d[3-3-2-False-zero]
PASSED xarray/tests/test_interp.py::test_interpolate_chunk_1d[3-3-2-False-slinear]
PASSED xarray/tests/test_interp.py::test_interpolate_chunk_1d[3-3-2-False-quadratic]
PASSED xarray/tests/test_interp.py::test_interpolate_chunk_1d[3-3-2-False-cubic]
PASSED xarray/tests/test_interp.py::test_interpolate_chunk_1d[3-3-3-True-linear]
PASSED xarray/tests/test_interp.py::test_interpolate_chunk_1d[3-3-3-True-nearest]
PASSED xarray/tests/test_interp.py::test_interpolate_chunk_1d[3-3-3-True-zero]
PASSED xarray/tests/test_interp.py::test_interpolate_chunk_1d[3-3-3-True-slinear]
PASSED xarray/tests/test_interp.py::test_interpolate_chunk_1d[3-3-3-True-quadratic]
PASSED xarray/tests/test_interp.py::test_interpolate_chunk_1d[3-3-3-True-cubic]
PASSED xarray/tests/test_interp.py::test_interpolate_chunk_1d[3-3-3-False-linear]
PASSED xarray/tests/test_interp.py::test_interpolate_chunk_1d[3-3-3-False-nearest]
PASSED xarray/tests/test_interp.py::test_interpolate_chunk_1d[3-3-3-False-zero]
PASSED xarray/tests/test_interp.py::test_interpolate_chunk_1d[3-3-3-False-slinear]
PASSED xarray/tests/test_interp.py::test_interpolate_chunk_1d[3-3-3-False-quadratic]
PASSED xarray/tests/test_interp.py::test_interpolate_chunk_1d[3-3-3-False-cubic]
PASSED xarray/tests/test_interp.py::test_interpolate_chunk_advanced[linear]
PASSED xarray/tests/test_interp.py::test_interpolate_chunk_advanced[nearest]
PASSED xarray/tests/test_variable.py::TestVariable::test_properties
PASSED xarray/tests/test_variable.py::TestVariable::test_attrs
PASSED xarray/tests/test_variable.py::TestVariable::test_getitem_dict
PASSED xarray/tests/test_variable.py::TestVariable::test_getitem_1d
PASSED xarray/tests/test_variable.py::TestVariable::test_getitem_1d_fancy
PASSED xarray/tests/test_variable.py::TestVariable::test_getitem_with_mask
PASSED xarray/tests/test_variable.py::TestVariable::test_getitem_with_mask_size_zero
PASSED xarray/tests/test_variable.py::TestVariable::test_getitem_with_mask_nd_indexer
PASSED xarray/tests/test_variable.py::TestVariable::test_index_0d_int
PASSED xarray/tests/test_variable.py::TestVariable::test_index_0d_float
PASSED xarray/tests/test_variable.py::TestVariable::test_index_0d_string
PASSED xarray/tests/test_variable.py::TestVariable::test_index_0d_datetime
PASSED xarray/tests/test_variable.py::TestVariable::test_index_0d_timedelta64
PASSED xarray/tests/test_variable.py::TestVariable::test_index_0d_not_a_time
PASSED xarray/tests/test_variable.py::TestVariable::test_index_0d_object
PASSED xarray/tests/test_variable.py::TestVariable::test_0d_object_array_with_list
PASSED xarray/tests/test_variable.py::TestVariable::test_index_and_concat_datetime
PASSED xarray/tests/test_variable.py::TestVariable::test_0d_time_data
PASSED xarray/tests/test_variable.py::TestVariable::test_datetime64_conversion
PASSED xarray/tests/test_variable.py::TestVariable::test_timedelta64_conversion
PASSED xarray/tests/test_variable.py::TestVariable::test_object_conversion
PASSED xarray/tests/test_variable.py::TestVariable::test_datetime64_valid_range
PASSED xarray/tests/test_variable.py::TestVariable::test_pandas_data
PASSED xarray/tests/test_variable.py::TestVariable::test_pandas_period_index
PASSED xarray/tests/test_variable.py::TestVariable::test_1d_math
PASSED xarray/tests/test_variable.py::TestVariable::test_1d_reduce
PASSED xarray/tests/test_variable.py::TestVariable::test_array_interface
PASSED xarray/tests/test_variable.py::TestVariable::test___array__
PASSED xarray/tests/test_variable.py::TestVariable::test_equals_all_dtypes
PASSED xarray/tests/test_variable.py::TestVariable::test_eq_all_dtypes
PASSED xarray/tests/test_variable.py::TestVariable::test_encoding_preserved
PASSED xarray/tests/test_variable.py::TestVariable::test_concat
PASSED xarray/tests/test_variable.py::TestVariable::test_concat_attrs
PASSED xarray/tests/test_variable.py::TestVariable::test_concat_fixed_len_str
PASSED xarray/tests/test_variable.py::TestVariable::test_concat_number_strings
PASSED xarray/tests/test_variable.py::TestVariable::test_concat_mixed_dtypes
PASSED xarray/tests/test_variable.py::TestVariable::test_copy[float-True]
PASSED xarray/tests/test_variable.py::TestVariable::test_copy[float-False]
PASSED xarray/tests/test_variable.py::TestVariable::test_copy[int-True]
PASSED xarray/tests/test_variable.py::TestVariable::test_copy[int-False]
PASSED xarray/tests/test_variable.py::TestVariable::test_copy[str-True]
PASSED xarray/tests/test_variable.py::TestVariable::test_copy[str-False]
PASSED xarray/tests/test_variable.py::TestVariable::test_copy_index
PASSED xarray/tests/test_variable.py::TestVariable::test_copy_with_data
PASSED xarray/tests/test_variable.py::TestVariable::test_copy_with_data_errors
PASSED xarray/tests/test_variable.py::TestVariable::test_copy_index_with_data
PASSED xarray/tests/test_variable.py::TestVariable::test_copy_index_with_data_errors
PASSED xarray/tests/test_variable.py::TestVariable::test_replace
PASSED xarray/tests/test_variable.py::TestVariable::test_real_and_imag
PASSED xarray/tests/test_variable.py::TestVariable::test_aggregate_complex
PASSED xarray/tests/test_variable.py::TestVariable::test_pandas_cateogrical_dtype
PASSED xarray/tests/test_variable.py::TestVariable::test_pandas_datetime64_with_tz
PASSED xarray/tests/test_variable.py::TestVariable::test_multiindex
PASSED xarray/tests/test_variable.py::TestVariable::test_load
PASSED xarray/tests/test_variable.py::TestVariable::test_getitem_advanced
PASSED xarray/tests/test_variable.py::TestVariable::test_getitem_uint_1d
PASSED xarray/tests/test_variable.py::TestVariable::test_getitem_uint
PASSED xarray/tests/test_variable.py::TestVariable::test_getitem_0d_array
PASSED xarray/tests/test_variable.py::TestVariable::test_getitem_fancy
PASSED xarray/tests/test_variable.py::TestVariable::test_getitem_error
PASSED xarray/tests/test_variable.py::TestVariable::test_pad[xr_arg0-np_arg0-mean]
PASSED xarray/tests/test_variable.py::TestVariable::test_pad[xr_arg0-np_arg0-edge]
PASSED xarray/tests/test_variable.py::TestVariable::test_pad[xr_arg0-np_arg0-maximum]
PASSED xarray/tests/test_variable.py::TestVariable::test_pad[xr_arg0-np_arg0-minimum]
PASSED xarray/tests/test_variable.py::TestVariable::test_pad[xr_arg0-np_arg0-symmetric]
PASSED xarray/tests/test_variable.py::TestVariable::test_pad[xr_arg0-np_arg0-wrap]
PASSED xarray/tests/test_variable.py::TestVariable::test_pad[xr_arg1-np_arg1-mean]
PASSED xarray/tests/test_variable.py::TestVariable::test_pad[xr_arg1-np_arg1-edge]
PASSED xarray/tests/test_variable.py::TestVariable::test_pad[xr_arg1-np_arg1-maximum]
PASSED xarray/tests/test_variable.py::TestVariable::test_pad[xr_arg1-np_arg1-minimum]
PASSED xarray/tests/test_variable.py::TestVariable::test_pad[xr_arg1-np_arg1-symmetric]
PASSED xarray/tests/test_variable.py::TestVariable::test_pad[xr_arg1-np_arg1-wrap]
PASSED xarray/tests/test_variable.py::TestVariable::test_pad[xr_arg2-np_arg2-mean]
PASSED xarray/tests/test_variable.py::TestVariable::test_pad[xr_arg2-np_arg2-edge]
PASSED xarray/tests/test_variable.py::TestVariable::test_pad[xr_arg2-np_arg2-maximum]
PASSED xarray/tests/test_variable.py::TestVariable::test_pad[xr_arg2-np_arg2-minimum]
PASSED xarray/tests/test_variable.py::TestVariable::test_pad[xr_arg2-np_arg2-symmetric]
PASSED xarray/tests/test_variable.py::TestVariable::test_pad[xr_arg2-np_arg2-wrap]
PASSED xarray/tests/test_variable.py::TestVariable::test_pad[xr_arg3-np_arg3-mean]
PASSED xarray/tests/test_variable.py::TestVariable::test_pad[xr_arg3-np_arg3-edge]
PASSED xarray/tests/test_variable.py::TestVariable::test_pad[xr_arg3-np_arg3-maximum]
PASSED xarray/tests/test_variable.py::TestVariable::test_pad[xr_arg3-np_arg3-minimum]
PASSED xarray/tests/test_variable.py::TestVariable::test_pad[xr_arg3-np_arg3-symmetric]
PASSED xarray/tests/test_variable.py::TestVariable::test_pad[xr_arg3-np_arg3-wrap]
PASSED xarray/tests/test_variable.py::TestVariable::test_pad[xr_arg4-np_arg4-mean]
PASSED xarray/tests/test_variable.py::TestVariable::test_pad[xr_arg4-np_arg4-edge]
PASSED xarray/tests/test_variable.py::TestVariable::test_pad[xr_arg4-np_arg4-maximum]
PASSED xarray/tests/test_variable.py::TestVariable::test_pad[xr_arg4-np_arg4-minimum]
PASSED xarray/tests/test_variable.py::TestVariable::test_pad[xr_arg4-np_arg4-symmetric]
PASSED xarray/tests/test_variable.py::TestVariable::test_pad[xr_arg4-np_arg4-wrap]
PASSED xarray/tests/test_variable.py::TestVariable::test_pad_constant_values[xr_arg0-np_arg0]
PASSED xarray/tests/test_variable.py::TestVariable::test_pad_constant_values[xr_arg1-np_arg1]
PASSED xarray/tests/test_variable.py::TestVariable::test_pad_constant_values[xr_arg2-np_arg2]
PASSED xarray/tests/test_variable.py::TestVariable::test_pad_constant_values[xr_arg3-np_arg3]
PASSED xarray/tests/test_variable.py::TestVariable::test_pad_constant_values[xr_arg4-np_arg4]
PASSED xarray/tests/test_variable.py::TestVariable::test_rolling_window
PASSED xarray/tests/test_variable.py::TestVariable::test_data_and_values
PASSED xarray/tests/test_variable.py::TestVariable::test_numpy_same_methods
PASSED xarray/tests/test_variable.py::TestVariable::test_datetime64_conversion_scalar
PASSED xarray/tests/test_variable.py::TestVariable::test_timedelta64_conversion_scalar
PASSED xarray/tests/test_variable.py::TestVariable::test_0d_str
PASSED xarray/tests/test_variable.py::TestVariable::test_0d_datetime
PASSED xarray/tests/test_variable.py::TestVariable::test_0d_timedelta
PASSED xarray/tests/test_variable.py::TestVariable::test_equals_and_identical
PASSED xarray/tests/test_variable.py::TestVariable::test_broadcast_equals
PASSED xarray/tests/test_variable.py::TestVariable::test_no_conflicts
PASSED xarray/tests/test_variable.py::TestVariable::test_as_variable
PASSED xarray/tests/test_variable.py::TestVariable::test_repr
PASSED xarray/tests/test_variable.py::TestVariable::test_repr_lazy_data
PASSED xarray/tests/test_variable.py::TestVariable::test_detect_indexer_type
PASSED xarray/tests/test_variable.py::TestVariable::test_indexer_type
PASSED xarray/tests/test_variable.py::TestVariable::test_items
PASSED xarray/tests/test_variable.py::TestVariable::test_getitem_basic
PASSED xarray/tests/test_variable.py::TestVariable::test_getitem_with_mask_2d_input
PASSED xarray/tests/test_variable.py::TestVariable::test_isel
PASSED xarray/tests/test_variable.py::TestVariable::test_index_0d_numpy_string
PASSED xarray/tests/test_variable.py::TestVariable::test_indexing_0d_unicode
PASSED xarray/tests/test_variable.py::TestVariable::test_shift[fill_value0]
PASSED xarray/tests/test_variable.py::TestVariable::test_shift[2]
PASSED xarray/tests/test_variable.py::TestVariable::test_shift[2.0]
PASSED xarray/tests/test_variable.py::TestVariable::test_shift2d
PASSED xarray/tests/test_variable.py::TestVariable::test_roll
PASSED xarray/tests/test_variable.py::TestVariable::test_roll_consistency
PASSED xarray/tests/test_variable.py::TestVariable::test_transpose
PASSED xarray/tests/test_variable.py::TestVariable::test_transpose_0d
PASSED xarray/tests/test_variable.py::TestVariable::test_squeeze
PASSED xarray/tests/test_variable.py::TestVariable::test_get_axis_num
PASSED xarray/tests/test_variable.py::TestVariable::test_set_dims
PASSED xarray/tests/test_variable.py::TestVariable::test_set_dims_object_dtype
PASSED xarray/tests/test_variable.py::TestVariable::test_stack
PASSED xarray/tests/test_variable.py::TestVariable::test_stack_errors
PASSED xarray/tests/test_variable.py::TestVariable::test_unstack
PASSED xarray/tests/test_variable.py::TestVariable::test_unstack_errors
PASSED xarray/tests/test_variable.py::TestVariable::test_unstack_2d
PASSED xarray/tests/test_variable.py::TestVariable::test_stack_unstack_consistency
PASSED xarray/tests/test_variable.py::TestVariable::test_broadcasting_math
PASSED xarray/tests/test_variable.py::TestVariable::test_broadcasting_failures
PASSED xarray/tests/test_variable.py::TestVariable::test_inplace_math
PASSED xarray/tests/test_variable.py::TestVariable::test_reduce
PASSED xarray/tests/test_variable.py::TestVariable::test_quantile[None-None-0.25-True]
PASSED xarray/tests/test_variable.py::TestVariable::test_quantile[None-None-0.25-False]
PASSED xarray/tests/test_variable.py::TestVariable::test_quantile[None-None-q1-True]
PASSED xarray/tests/test_variable.py::TestVariable::test_quantile[None-None-q1-False]
PASSED xarray/tests/test_variable.py::TestVariable::test_quantile[None-None-q2-True]
PASSED xarray/tests/test_variable.py::TestVariable::test_quantile[None-None-q2-False]
PASSED xarray/tests/test_variable.py::TestVariable::test_quantile[0-x-0.25-True]
PASSED xarray/tests/test_variable.py::TestVariable::test_quantile[0-x-0.25-False]
PASSED xarray/tests/test_variable.py::TestVariable::test_quantile[0-x-q1-True]
PASSED xarray/tests/test_variable.py::TestVariable::test_quantile[0-x-q1-False]
PASSED xarray/tests/test_variable.py::TestVariable::test_quantile[0-x-q2-True]
PASSED xarray/tests/test_variable.py::TestVariable::test_quantile[0-x-q2-False]
PASSED xarray/tests/test_variable.py::TestVariable::test_quantile[axis2-dim2-0.25-True]
PASSED xarray/tests/test_variable.py::TestVariable::test_quantile[axis2-dim2-0.25-False]
PASSED xarray/tests/test_variable.py::TestVariable::test_quantile[axis2-dim2-q1-True]
PASSED xarray/tests/test_variable.py::TestVariable::test_quantile[axis2-dim2-q1-False]
PASSED xarray/tests/test_variable.py::TestVariable::test_quantile[axis2-dim2-q2-True]
PASSED xarray/tests/test_variable.py::TestVariable::test_quantile[axis2-dim2-q2-False]
PASSED xarray/tests/test_variable.py::TestVariable::test_quantile[axis3-dim3-0.25-True]
PASSED xarray/tests/test_variable.py::TestVariable::test_quantile[axis3-dim3-0.25-False]
PASSED xarray/tests/test_variable.py::TestVariable::test_quantile[axis3-dim3-q1-True]
PASSED xarray/tests/test_variable.py::TestVariable::test_quantile[axis3-dim3-q1-False]
PASSED xarray/tests/test_variable.py::TestVariable::test_quantile[axis3-dim3-q2-True]
PASSED xarray/tests/test_variable.py::TestVariable::test_quantile[axis3-dim3-q2-False]
PASSED xarray/tests/test_variable.py::TestVariable::test_quantile_dask[1-y-0.25]
PASSED xarray/tests/test_variable.py::TestVariable::test_quantile_dask[1-y-q1]
PASSED xarray/tests/test_variable.py::TestVariable::test_quantile_dask[1-y-q2]
PASSED xarray/tests/test_variable.py::TestVariable::test_quantile_dask[axis1-dim1-0.25]
PASSED xarray/tests/test_variable.py::TestVariable::test_quantile_dask[axis1-dim1-q1]
PASSED xarray/tests/test_variable.py::TestVariable::test_quantile_dask[axis1-dim1-q2]
PASSED xarray/tests/test_variable.py::TestVariable::test_quantile_chunked_dim_error
PASSED xarray/tests/test_variable.py::TestVariable::test_quantile_out_of_bounds[-0.1]
PASSED xarray/tests/test_variable.py::TestVariable::test_quantile_out_of_bounds[1.1]
PASSED xarray/tests/test_variable.py::TestVariable::test_quantile_out_of_bounds[q2]
PASSED xarray/tests/test_variable.py::TestVariable::test_quantile_out_of_bounds[q3]
PASSED xarray/tests/test_variable.py::TestVariable::test_rank_dask_raises
PASSED xarray/tests/test_variable.py::TestVariable::test_rank
PASSED xarray/tests/test_variable.py::TestVariable::test_big_endian_reduce
PASSED xarray/tests/test_variable.py::TestVariable::test_reduce_funcs
PASSED xarray/tests/test_variable.py::TestVariable::test_reduce_keepdims
PASSED xarray/tests/test_variable.py::TestVariable::test_reduce_keepdims_dask
PASSED xarray/tests/test_variable.py::TestVariable::test_reduce_keep_attrs
PASSED xarray/tests/test_variable.py::TestVariable::test_binary_ops_keep_attrs
PASSED xarray/tests/test_variable.py::TestVariable::test_count
PASSED xarray/tests/test_variable.py::TestVariable::test_setitem
PASSED xarray/tests/test_variable.py::TestVariable::test_setitem_fancy
PASSED xarray/tests/test_variable.py::TestVariable::test_coarsen
PASSED xarray/tests/test_variable.py::TestVariable::test_coarsen_2d
PASSED xarray/tests/test_variable.py::TestVariable::test_coarsen_keep_attrs
PASSED xarray/tests/test_variable.py::TestVariableWithDask::test_properties
PASSED xarray/tests/test_variable.py::TestVariableWithDask::test_attrs
PASSED xarray/tests/test_variable.py::TestVariableWithDask::test_getitem_dict
PASSED xarray/tests/test_variable.py::TestVariableWithDask::test_getitem_1d
PASSED xarray/tests/test_variable.py::TestVariableWithDask::test_getitem_with_mask
PASSED xarray/tests/test_variable.py::TestVariableWithDask::test_getitem_with_mask_size_zero
PASSED xarray/tests/test_variable.py::TestVariableWithDask::test_index_0d_int
PASSED xarray/tests/test_variable.py::TestVariableWithDask::test_index_0d_float
PASSED xarray/tests/test_variable.py::TestVariableWithDask::test_index_0d_string
PASSED xarray/tests/test_variable.py::TestVariableWithDask::test_index_0d_datetime
PASSED xarray/tests/test_variable.py::TestVariableWithDask::test_index_0d_timedelta64
PASSED xarray/tests/test_variable.py::TestVariableWithDask::test_index_0d_not_a_time
PASSED xarray/tests/test_variable.py::TestVariableWithDask::test_index_0d_object
PASSED xarray/tests/test_variable.py::TestVariableWithDask::test_index_and_concat_datetime
PASSED xarray/tests/test_variable.py::TestVariableWithDask::test_0d_time_data
PASSED xarray/tests/test_variable.py::TestVariableWithDask::test_datetime64_conversion
PASSED xarray/tests/test_variable.py::TestVariableWithDask::test_timedelta64_conversion
PASSED xarray/tests/test_variable.py::TestVariableWithDask::test_object_conversion
PASSED xarray/tests/test_variable.py::TestVariableWithDask::test_datetime64_valid_range
PASSED xarray/tests/test_variable.py::TestVariableWithDask::test_pandas_data
PASSED xarray/tests/test_variable.py::TestVariableWithDask::test_pandas_period_index
PASSED xarray/tests/test_variable.py::TestVariableWithDask::test_1d_math
PASSED xarray/tests/test_variable.py::TestVariableWithDask::test_1d_reduce
PASSED xarray/tests/test_variable.py::TestVariableWithDask::test___array__
PASSED xarray/tests/test_variable.py::TestVariableWithDask::test_equals_all_dtypes
PASSED xarray/tests/test_variable.py::TestVariableWithDask::test_encoding_preserved
PASSED xarray/tests/test_variable.py::TestVariableWithDask::test_concat
PASSED xarray/tests/test_variable.py::TestVariableWithDask::test_concat_attrs
PASSED xarray/tests/test_variable.py::TestVariableWithDask::test_concat_fixed_len_str
PASSED xarray/tests/test_variable.py::TestVariableWithDask::test_concat_number_strings
PASSED xarray/tests/test_variable.py::TestVariableWithDask::test_concat_mixed_dtypes
PASSED xarray/tests/test_variable.py::TestVariableWithDask::test_copy[float-True]
PASSED xarray/tests/test_variable.py::TestVariableWithDask::test_copy[float-False]
PASSED xarray/tests/test_variable.py::TestVariableWithDask::test_copy[int-True]
PASSED xarray/tests/test_variable.py::TestVariableWithDask::test_copy[int-False]
PASSED xarray/tests/test_variable.py::TestVariableWithDask::test_copy[str-True]
PASSED xarray/tests/test_variable.py::TestVariableWithDask::test_copy[str-False]
PASSED xarray/tests/test_variable.py::TestVariableWithDask::test_copy_with_data
PASSED xarray/tests/test_variable.py::TestVariableWithDask::test_copy_with_data_errors
PASSED xarray/tests/test_variable.py::TestVariableWithDask::test_copy_index_with_data
PASSED xarray/tests/test_variable.py::TestVariableWithDask::test_copy_index_with_data_errors
PASSED xarray/tests/test_variable.py::TestVariableWithDask::test_replace
PASSED xarray/tests/test_variable.py::TestVariableWithDask::test_real_and_imag
PASSED xarray/tests/test_variable.py::TestVariableWithDask::test_aggregate_complex
PASSED xarray/tests/test_variable.py::TestVariableWithDask::test_pandas_cateogrical_dtype
PASSED xarray/tests/test_variable.py::TestVariableWithDask::test_pandas_datetime64_with_tz
PASSED xarray/tests/test_variable.py::TestVariableWithDask::test_multiindex
PASSED xarray/tests/test_variable.py::TestVariableWithDask::test_load
PASSED xarray/tests/test_variable.py::TestVariableWithDask::test_getitem_advanced
PASSED xarray/tests/test_variable.py::TestVariableWithDask::test_getitem_uint_1d
PASSED xarray/tests/test_variable.py::TestVariableWithDask::test_getitem_uint
PASSED xarray/tests/test_variable.py::TestVariableWithDask::test_getitem_0d_array
PASSED xarray/tests/test_variable.py::TestVariableWithDask::test_getitem_error
PASSED xarray/tests/test_variable.py::TestVariableWithDask::test_pad[xr_arg0-np_arg0-mean]
PASSED xarray/tests/test_variable.py::TestVariableWithDask::test_pad[xr_arg0-np_arg0-edge]
PASSED xarray/tests/test_variable.py::TestVariableWithDask::test_pad[xr_arg0-np_arg0-maximum]
PASSED xarray/tests/test_variable.py::TestVariableWithDask::test_pad[xr_arg0-np_arg0-minimum]
PASSED xarray/tests/test_variable.py::TestVariableWithDask::test_pad[xr_arg0-np_arg0-symmetric]
PASSED xarray/tests/test_variable.py::TestVariableWithDask::test_pad[xr_arg0-np_arg0-wrap]
PASSED xarray/tests/test_variable.py::TestVariableWithDask::test_pad[xr_arg1-np_arg1-mean]
PASSED xarray/tests/test_variable.py::TestVariableWithDask::test_pad[xr_arg1-np_arg1-edge]
PASSED xarray/tests/test_variable.py::TestVariableWithDask::test_pad[xr_arg1-np_arg1-maximum]
PASSED xarray/tests/test_variable.py::TestVariableWithDask::test_pad[xr_arg1-np_arg1-minimum]
PASSED xarray/tests/test_variable.py::TestVariableWithDask::test_pad[xr_arg1-np_arg1-symmetric]
PASSED xarray/tests/test_variable.py::TestVariableWithDask::test_pad[xr_arg1-np_arg1-wrap]
PASSED xarray/tests/test_variable.py::TestVariableWithDask::test_pad[xr_arg2-np_arg2-mean]
PASSED xarray/tests/test_variable.py::TestVariableWithDask::test_pad[xr_arg2-np_arg2-edge]
PASSED xarray/tests/test_variable.py::TestVariableWithDask::test_pad[xr_arg2-np_arg2-maximum]
PASSED xarray/tests/test_variable.py::TestVariableWithDask::test_pad[xr_arg2-np_arg2-minimum]
PASSED xarray/tests/test_variable.py::TestVariableWithDask::test_pad[xr_arg2-np_arg2-symmetric]
PASSED xarray/tests/test_variable.py::TestVariableWithDask::test_pad[xr_arg2-np_arg2-wrap]
PASSED xarray/tests/test_variable.py::TestVariableWithDask::test_pad[xr_arg3-np_arg3-mean]
PASSED xarray/tests/test_variable.py::TestVariableWithDask::test_pad[xr_arg3-np_arg3-edge]
PASSED xarray/tests/test_variable.py::TestVariableWithDask::test_pad[xr_arg3-np_arg3-maximum]
PASSED xarray/tests/test_variable.py::TestVariableWithDask::test_pad[xr_arg3-np_arg3-minimum]
PASSED xarray/tests/test_variable.py::TestVariableWithDask::test_pad[xr_arg3-np_arg3-symmetric]
PASSED xarray/tests/test_variable.py::TestVariableWithDask::test_pad[xr_arg3-np_arg3-wrap]
PASSED xarray/tests/test_variable.py::TestVariableWithDask::test_pad[xr_arg4-np_arg4-mean]
PASSED xarray/tests/test_variable.py::TestVariableWithDask::test_pad[xr_arg4-np_arg4-edge]
PASSED xarray/tests/test_variable.py::TestVariableWithDask::test_pad[xr_arg4-np_arg4-maximum]
PASSED xarray/tests/test_variable.py::TestVariableWithDask::test_pad[xr_arg4-np_arg4-minimum]
PASSED xarray/tests/test_variable.py::TestVariableWithDask::test_pad[xr_arg4-np_arg4-symmetric]
PASSED xarray/tests/test_variable.py::TestVariableWithDask::test_pad[xr_arg4-np_arg4-wrap]
PASSED xarray/tests/test_variable.py::TestVariableWithDask::test_pad_constant_values[xr_arg0-np_arg0]
PASSED xarray/tests/test_variable.py::TestVariableWithDask::test_pad_constant_values[xr_arg1-np_arg1]
PASSED xarray/tests/test_variable.py::TestVariableWithDask::test_pad_constant_values[xr_arg2-np_arg2]
PASSED xarray/tests/test_variable.py::TestVariableWithDask::test_pad_constant_values[xr_arg3-np_arg3]
PASSED xarray/tests/test_variable.py::TestVariableWithDask::test_pad_constant_values[xr_arg4-np_arg4]
PASSED xarray/tests/test_variable.py::TestVariableWithDask::test_rolling_window
PASSED xarray/tests/test_variable.py::TestVariableWithDask::test_getitem_fancy
PASSED xarray/tests/test_variable.py::TestVariableWithDask::test_getitem_1d_fancy
PASSED xarray/tests/test_variable.py::TestVariableWithDask::test_getitem_with_mask_nd_indexer
PASSED xarray/tests/test_variable.py::TestVariableWithSparse::test_as_sparse
PASSED xarray/tests/test_variable.py::TestIndexVariable::test_properties
PASSED xarray/tests/test_variable.py::TestIndexVariable::test_attrs
PASSED xarray/tests/test_variable.py::TestIndexVariable::test_getitem_dict
PASSED xarray/tests/test_variable.py::TestIndexVariable::test_getitem_1d
PASSED xarray/tests/test_variable.py::TestIndexVariable::test_getitem_1d_fancy
PASSED xarray/tests/test_variable.py::TestIndexVariable::test_getitem_with_mask
PASSED xarray/tests/test_variable.py::TestIndexVariable::test_getitem_with_mask_size_zero
PASSED xarray/tests/test_variable.py::TestIndexVariable::test_getitem_with_mask_nd_indexer
PASSED xarray/tests/test_variable.py::TestIndexVariable::test_index_0d_int
PASSED xarray/tests/test_variable.py::TestIndexVariable::test_index_0d_float
PASSED xarray/tests/test_variable.py::TestIndexVariable::test_index_0d_string
PASSED xarray/tests/test_variable.py::TestIndexVariable::test_index_0d_datetime
PASSED xarray/tests/test_variable.py::TestIndexVariable::test_index_0d_timedelta64
PASSED xarray/tests/test_variable.py::TestIndexVariable::test_index_0d_not_a_time
PASSED xarray/tests/test_variable.py::TestIndexVariable::test_index_0d_object
PASSED xarray/tests/test_variable.py::TestIndexVariable::test_0d_object_array_with_list
PASSED xarray/tests/test_variable.py::TestIndexVariable::test_index_and_concat_datetime
PASSED xarray/tests/test_variable.py::TestIndexVariable::test_0d_time_data
PASSED xarray/tests/test_variable.py::TestIndexVariable::test_datetime64_conversion
PASSED xarray/tests/test_variable.py::TestIndexVariable::test_timedelta64_conversion
PASSED xarray/tests/test_variable.py::TestIndexVariable::test_object_conversion
PASSED xarray/tests/test_variable.py::TestIndexVariable::test_datetime64_valid_range
PASSED xarray/tests/test_variable.py::TestIndexVariable::test_pandas_data
PASSED xarray/tests/test_variable.py::TestIndexVariable::test_pandas_period_index
PASSED xarray/tests/test_variable.py::TestIndexVariable::test_1d_math
PASSED xarray/tests/test_variable.py::TestIndexVariable::test_1d_reduce
PASSED xarray/tests/test_variable.py::TestIndexVariable::test_array_interface
PASSED xarray/tests/test_variable.py::TestIndexVariable::test___array__
PASSED xarray/tests/test_variable.py::TestIndexVariable::test_equals_all_dtypes
PASSED xarray/tests/test_variable.py::TestIndexVariable::test_eq_all_dtypes
PASSED xarray/tests/test_variable.py::TestIndexVariable::test_encoding_preserved
PASSED xarray/tests/test_variable.py::TestIndexVariable::test_concat
PASSED xarray/tests/test_variable.py::TestIndexVariable::test_concat_attrs
PASSED xarray/tests/test_variable.py::TestIndexVariable::test_concat_fixed_len_str
PASSED xarray/tests/test_variable.py::TestIndexVariable::test_concat_number_strings
PASSED xarray/tests/test_variable.py::TestIndexVariable::test_concat_mixed_dtypes
PASSED xarray/tests/test_variable.py::TestIndexVariable::test_copy[float-True]
PASSED xarray/tests/test_variable.py::TestIndexVariable::test_copy[float-False]
PASSED xarray/tests/test_variable.py::TestIndexVariable::test_copy[int-True]
PASSED xarray/tests/test_variable.py::TestIndexVariable::test_copy[int-False]
PASSED xarray/tests/test_variable.py::TestIndexVariable::test_copy[str-True]
PASSED xarray/tests/test_variable.py::TestIndexVariable::test_copy[str-False]
PASSED xarray/tests/test_variable.py::TestIndexVariable::test_copy_index
PASSED xarray/tests/test_variable.py::TestIndexVariable::test_copy_with_data
PASSED xarray/tests/test_variable.py::TestIndexVariable::test_copy_with_data_errors
PASSED xarray/tests/test_variable.py::TestIndexVariable::test_copy_index_with_data
PASSED xarray/tests/test_variable.py::TestIndexVariable::test_copy_index_with_data_errors
PASSED xarray/tests/test_variable.py::TestIndexVariable::test_replace
PASSED xarray/tests/test_variable.py::TestIndexVariable::test_real_and_imag
PASSED xarray/tests/test_variable.py::TestIndexVariable::test_aggregate_complex
PASSED xarray/tests/test_variable.py::TestIndexVariable::test_pandas_cateogrical_dtype
PASSED xarray/tests/test_variable.py::TestIndexVariable::test_pandas_datetime64_with_tz
PASSED xarray/tests/test_variable.py::TestIndexVariable::test_multiindex
PASSED xarray/tests/test_variable.py::TestIndexVariable::test_load
PASSED xarray/tests/test_variable.py::TestIndexVariable::test_getitem_uint_1d
PASSED xarray/tests/test_variable.py::TestIndexVariable::test_getitem_0d_array
PASSED xarray/tests/test_variable.py::TestIndexVariable::test_init
PASSED xarray/tests/test_variable.py::TestIndexVariable::test_to_index
PASSED xarray/tests/test_variable.py::TestIndexVariable::test_multiindex_default_level_names
PASSED xarray/tests/test_variable.py::TestIndexVariable::test_data
PASSED xarray/tests/test_variable.py::TestIndexVariable::test_name
PASSED xarray/tests/test_variable.py::TestIndexVariable::test_level_names
PASSED xarray/tests/test_variable.py::TestIndexVariable::test_get_level_variable
PASSED xarray/tests/test_variable.py::TestIndexVariable::test_concat_periods
PASSED xarray/tests/test_variable.py::TestIndexVariable::test_concat_multiindex
PASSED xarray/tests/test_variable.py::TestIndexVariable::test_concat_str_dtype[str]
PASSED xarray/tests/test_variable.py::TestIndexVariable::test_concat_str_dtype[bytes]
PASSED xarray/tests/test_variable.py::TestIndexVariable::test_coordinate_alias
PASSED xarray/tests/test_variable.py::TestIndexVariable::test_datetime64
PASSED xarray/tests/test_variable.py::TestAsCompatibleData::test_unchanged_types
PASSED xarray/tests/test_variable.py::TestAsCompatibleData::test_converted_types
PASSED xarray/tests/test_variable.py::TestAsCompatibleData::test_masked_array
PASSED xarray/tests/test_variable.py::TestAsCompatibleData::test_datetime
PASSED xarray/tests/test_variable.py::TestAsCompatibleData::test_full_like
PASSED xarray/tests/test_variable.py::TestAsCompatibleData::test_full_like_dask
PASSED xarray/tests/test_variable.py::TestAsCompatibleData::test_zeros_like
PASSED xarray/tests/test_variable.py::TestAsCompatibleData::test_ones_like
PASSED xarray/tests/test_variable.py::TestAsCompatibleData::test_unsupported_type
PASSED xarray/tests/test_variable.py::TestBackendIndexing::test_NumpyIndexingAdapter
PASSED xarray/tests/test_variable.py::TestBackendIndexing::test_LazilyOuterIndexedArray
PASSED xarray/tests/test_variable.py::TestBackendIndexing::test_CopyOnWriteArray
PASSED xarray/tests/test_variable.py::TestBackendIndexing::test_MemoryCachedArray
PASSED xarray/tests/test_variable.py::TestBackendIndexing::test_DaskIndexingAdapter
SKIPPED [1] xarray/tests/test_dask.py:587: no meta
SKIPPED [16] xarray/tests/test_dataset.py:6317: std with window == 1 is unstable in bottleneck
XFAIL xarray/tests/test_dask.py::TestToDaskDataFrame::test_to_dask_dataframe_2D_set_index
XFAIL xarray/tests/test_dataset.py::TestDataset::test_copy_coords[True-expected_orig0]
XFAIL xarray/tests/test_interp.py::test_datetime[2000-01-01T12:00-0.5]
XFAIL xarray/tests/test_variable.py::TestVariable::test_timedelta64_valid_range - pandas issue 36615
XFAIL xarray/tests/test_variable.py::TestVariableWithDask::test_timedelta64_valid_range - pandas issue 36615
XFAIL xarray/tests/test_variable.py::TestVariableWithDask::test_pad[xr_arg0-np_arg0-median] - median is not implemented by Dask
XFAIL xarray/tests/test_variable.py::TestVariableWithDask::test_pad[xr_arg1-np_arg1-median] - median is not implemented by Dask
XFAIL xarray/tests/test_variable.py::TestVariableWithDask::test_pad[xr_arg2-np_arg2-median] - median is not implemented by Dask
XFAIL xarray/tests/test_variable.py::TestVariableWithDask::test_pad[xr_arg2-np_arg2-reflect] - dask.array.pad bug
XFAIL xarray/tests/test_variable.py::TestVariableWithDask::test_pad[xr_arg3-np_arg3-median] - median is not implemented by Dask
XFAIL xarray/tests/test_variable.py::TestVariableWithDask::test_pad[xr_arg3-np_arg3-reflect] - dask.array.pad bug
XFAIL xarray/tests/test_variable.py::TestVariableWithDask::test_pad[xr_arg4-np_arg4-median] - median is not implemented by Dask
XFAIL xarray/tests/test_variable.py::TestVariableWithDask::test_pad[xr_arg4-np_arg4-reflect] - dask.array.pad bug
XFAIL xarray/tests/test_variable.py::TestVariableWithDask::test_0d_object_array_with_list
XFAIL xarray/tests/test_variable.py::TestVariableWithDask::test_array_interface
XFAIL xarray/tests/test_variable.py::TestVariableWithDask::test_copy_index
XFAIL xarray/tests/test_variable.py::TestIndexVariable::test_timedelta64_valid_range - pandas issue 36615
XFAIL xarray/tests/test_variable.py::TestIndexVariable::test_getitem_error
XFAIL xarray/tests/test_variable.py::TestIndexVariable::test_getitem_advanced
XFAIL xarray/tests/test_variable.py::TestIndexVariable::test_getitem_fancy
XFAIL xarray/tests/test_variable.py::TestIndexVariable::test_getitem_uint
XFAIL xarray/tests/test_variable.py::TestIndexVariable::test_pad[xr_arg0-np_arg0-mean]
XFAIL xarray/tests/test_variable.py::TestIndexVariable::test_pad[xr_arg0-np_arg0-median]
XFAIL xarray/tests/test_variable.py::TestIndexVariable::test_pad[xr_arg0-np_arg0-reflect]
XFAIL xarray/tests/test_variable.py::TestIndexVariable::test_pad[xr_arg0-np_arg0-edge]
XFAIL xarray/tests/test_variable.py::TestIndexVariable::test_pad[xr_arg0-np_arg0-linear_ramp]
XFAIL xarray/tests/test_variable.py::TestIndexVariable::test_pad[xr_arg0-np_arg0-maximum]
XFAIL xarray/tests/test_variable.py::TestIndexVariable::test_pad[xr_arg0-np_arg0-minimum]
XFAIL xarray/tests/test_variable.py::TestIndexVariable::test_pad[xr_arg0-np_arg0-symmetric]
XFAIL xarray/tests/test_variable.py::TestIndexVariable::test_pad[xr_arg0-np_arg0-wrap]
XFAIL xarray/tests/test_variable.py::TestIndexVariable::test_pad[xr_arg1-np_arg1-mean]
XFAIL xarray/tests/test_variable.py::TestIndexVariable::test_pad[xr_arg1-np_arg1-median]
XFAIL xarray/tests/test_variable.py::TestIndexVariable::test_pad[xr_arg1-np_arg1-reflect]
XFAIL xarray/tests/test_variable.py::TestIndexVariable::test_pad[xr_arg1-np_arg1-edge]
XFAIL xarray/tests/test_variable.py::TestIndexVariable::test_pad[xr_arg1-np_arg1-linear_ramp]
XFAIL xarray/tests/test_variable.py::TestIndexVariable::test_pad[xr_arg1-np_arg1-maximum]
XFAIL xarray/tests/test_variable.py::TestIndexVariable::test_pad[xr_arg1-np_arg1-minimum]
XFAIL xarray/tests/test_variable.py::TestIndexVariable::test_pad[xr_arg1-np_arg1-symmetric]
XFAIL xarray/tests/test_variable.py::TestIndexVariable::test_pad[xr_arg1-np_arg1-wrap]
XFAIL xarray/tests/test_variable.py::TestIndexVariable::test_pad[xr_arg2-np_arg2-mean]
XFAIL xarray/tests/test_variable.py::TestIndexVariable::test_pad[xr_arg2-np_arg2-median]
XFAIL xarray/tests/test_variable.py::TestIndexVariable::test_pad[xr_arg2-np_arg2-reflect]
XFAIL xarray/tests/test_variable.py::TestIndexVariable::test_pad[xr_arg2-np_arg2-edge]
XFAIL xarray/tests/test_variable.py::TestIndexVariable::test_pad[xr_arg2-np_arg2-linear_ramp]
XFAIL xarray/tests/test_variable.py::TestIndexVariable::test_pad[xr_arg2-np_arg2-maximum]
XFAIL xarray/tests/test_variable.py::TestIndexVariable::test_pad[xr_arg2-np_arg2-minimum]
XFAIL xarray/tests/test_variable.py::TestIndexVariable::test_pad[xr_arg2-np_arg2-symmetric]
XFAIL xarray/tests/test_variable.py::TestIndexVariable::test_pad[xr_arg2-np_arg2-wrap]
XFAIL xarray/tests/test_variable.py::TestIndexVariable::test_pad[xr_arg3-np_arg3-mean]
XFAIL xarray/tests/test_variable.py::TestIndexVariable::test_pad[xr_arg3-np_arg3-median]
XFAIL xarray/tests/test_variable.py::TestIndexVariable::test_pad[xr_arg3-np_arg3-reflect]
XFAIL xarray/tests/test_variable.py::TestIndexVariable::test_pad[xr_arg3-np_arg3-edge]
XFAIL xarray/tests/test_variable.py::TestIndexVariable::test_pad[xr_arg3-np_arg3-linear_ramp]
XFAIL xarray/tests/test_variable.py::TestIndexVariable::test_pad[xr_arg3-np_arg3-maximum]
XFAIL xarray/tests/test_variable.py::TestIndexVariable::test_pad[xr_arg3-np_arg3-minimum]
XFAIL xarray/tests/test_variable.py::TestIndexVariable::test_pad[xr_arg3-np_arg3-symmetric]
XFAIL xarray/tests/test_variable.py::TestIndexVariable::test_pad[xr_arg3-np_arg3-wrap]
XFAIL xarray/tests/test_variable.py::TestIndexVariable::test_pad[xr_arg4-np_arg4-mean]
XFAIL xarray/tests/test_variable.py::TestIndexVariable::test_pad[xr_arg4-np_arg4-median]
XFAIL xarray/tests/test_variable.py::TestIndexVariable::test_pad[xr_arg4-np_arg4-reflect]
XFAIL xarray/tests/test_variable.py::TestIndexVariable::test_pad[xr_arg4-np_arg4-edge]
XFAIL xarray/tests/test_variable.py::TestIndexVariable::test_pad[xr_arg4-np_arg4-linear_ramp]
XFAIL xarray/tests/test_variable.py::TestIndexVariable::test_pad[xr_arg4-np_arg4-maximum]
XFAIL xarray/tests/test_variable.py::TestIndexVariable::test_pad[xr_arg4-np_arg4-minimum]
XFAIL xarray/tests/test_variable.py::TestIndexVariable::test_pad[xr_arg4-np_arg4-symmetric]
XFAIL xarray/tests/test_variable.py::TestIndexVariable::test_pad[xr_arg4-np_arg4-wrap]
XFAIL xarray/tests/test_variable.py::TestIndexVariable::test_pad_constant_values[xr_arg0-np_arg0]
XFAIL xarray/tests/test_variable.py::TestIndexVariable::test_pad_constant_values[xr_arg1-np_arg1]
XFAIL xarray/tests/test_variable.py::TestIndexVariable::test_pad_constant_values[xr_arg2-np_arg2]
XFAIL xarray/tests/test_variable.py::TestIndexVariable::test_pad_constant_values[xr_arg3-np_arg3]
XFAIL xarray/tests/test_variable.py::TestIndexVariable::test_pad_constant_values[xr_arg4-np_arg4]
XFAIL xarray/tests/test_variable.py::TestIndexVariable::test_rolling_window
XFAIL xarray/tests/test_variable.py::TestIndexVariable::test_coarsen_2d
XPASS xarray/tests/test_dataset.py::TestDataset::test_copy_coords[False-expected_orig1]
XPASS xarray/tests/test_dataset.py::test_raise_no_warning_dask_rolling_assert_close[mean-2] - See https://github.com/pydata/xarray/pull/4369 or docstring
XPASS xarray/tests/test_dataset.py::test_raise_no_warning_dask_rolling_assert_close[max-2] - See https://github.com/pydata/xarray/pull/4369 or docstring
XPASS xarray/tests/test_variable.py::TestVariable::test_pad[xr_arg0-np_arg0-median] - median is not implemented by Dask
XPASS xarray/tests/test_variable.py::TestVariable::test_pad[xr_arg0-np_arg0-reflect] - dask.array.pad bug
XPASS xarray/tests/test_variable.py::TestVariable::test_pad[xr_arg0-np_arg0-linear_ramp] - pint bug: https://github.com/hgrecco/pint/issues/1026
XPASS xarray/tests/test_variable.py::TestVariable::test_pad[xr_arg1-np_arg1-median] - median is not implemented by Dask
XPASS xarray/tests/test_variable.py::TestVariable::test_pad[xr_arg1-np_arg1-reflect] - dask.array.pad bug
XPASS xarray/tests/test_variable.py::TestVariable::test_pad[xr_arg1-np_arg1-linear_ramp] - pint bug: https://github.com/hgrecco/pint/issues/1026
XPASS xarray/tests/test_variable.py::TestVariable::test_pad[xr_arg2-np_arg2-median] - median is not implemented by Dask
XPASS xarray/tests/test_variable.py::TestVariable::test_pad[xr_arg2-np_arg2-reflect] - dask.array.pad bug
XPASS xarray/tests/test_variable.py::TestVariable::test_pad[xr_arg2-np_arg2-linear_ramp] - pint bug: https://github.com/hgrecco/pint/issues/1026
XPASS xarray/tests/test_variable.py::TestVariable::test_pad[xr_arg3-np_arg3-median] - median is not implemented by Dask
XPASS xarray/tests/test_variable.py::TestVariable::test_pad[xr_arg3-np_arg3-reflect] - dask.array.pad bug
XPASS xarray/tests/test_variable.py::TestVariable::test_pad[xr_arg3-np_arg3-linear_ramp] - pint bug: https://github.com/hgrecco/pint/issues/1026
XPASS xarray/tests/test_variable.py::TestVariable::test_pad[xr_arg4-np_arg4-median] - median is not implemented by Dask
XPASS xarray/tests/test_variable.py::TestVariable::test_pad[xr_arg4-np_arg4-reflect] - dask.array.pad bug
XPASS xarray/tests/test_variable.py::TestVariable::test_pad[xr_arg4-np_arg4-linear_ramp] - pint bug: https://github.com/hgrecco/pint/issues/1026
XPASS xarray/tests/test_variable.py::TestVariableWithDask::test_pad[xr_arg0-np_arg0-reflect] - dask.array.pad bug
XPASS xarray/tests/test_variable.py::TestVariableWithDask::test_pad[xr_arg0-np_arg0-linear_ramp] - pint bug: https://github.com/hgrecco/pint/issues/1026
XPASS xarray/tests/test_variable.py::TestVariableWithDask::test_pad[xr_arg1-np_arg1-reflect] - dask.array.pad bug
XPASS xarray/tests/test_variable.py::TestVariableWithDask::test_pad[xr_arg1-np_arg1-linear_ramp] - pint bug: https://github.com/hgrecco/pint/issues/1026
XPASS xarray/tests/test_variable.py::TestVariableWithDask::test_pad[xr_arg2-np_arg2-linear_ramp] - pint bug: https://github.com/hgrecco/pint/issues/1026
XPASS xarray/tests/test_variable.py::TestVariableWithDask::test_pad[xr_arg3-np_arg3-linear_ramp] - pint bug: https://github.com/hgrecco/pint/issues/1026
XPASS xarray/tests/test_variable.py::TestVariableWithDask::test_pad[xr_arg4-np_arg4-linear_ramp] - pint bug: https://github.com/hgrecco/pint/issues/1026
XPASS xarray/tests/test_variable.py::TestVariableWithDask::test_eq_all_dtypes
FAILED xarray/tests/test_dask.py::test_persist_Dataset[<lambda>1] - IndexErro...
FAILED xarray/tests/test_dask.py::test_map_blocks_error - AttributeError: 'di...
FAILED xarray/tests/test_dask.py::test_map_blocks[obj0] - AttributeError: 'di...
FAILED xarray/tests/test_dask.py::test_map_blocks[obj1] - AttributeError: 'di...
FAILED xarray/tests/test_dask.py::test_map_blocks_convert_args_to_list[obj0]
FAILED xarray/tests/test_dask.py::test_map_blocks_convert_args_to_list[obj1]
FAILED xarray/tests/test_dask.py::test_map_blocks_dask_args - AttributeError:...
FAILED xarray/tests/test_dask.py::test_map_blocks_add_attrs[obj0] - Attribute...
FAILED xarray/tests/test_dask.py::test_map_blocks_add_attrs[obj1] - Attribute...
FAILED xarray/tests/test_dask.py::test_map_blocks_change_name - AttributeErro...
FAILED xarray/tests/test_dask.py::test_map_blocks_kwargs[obj0] - AttributeErr...
FAILED xarray/tests/test_dask.py::test_map_blocks_kwargs[obj1] - AttributeErr...
FAILED xarray/tests/test_dask.py::test_map_blocks_to_array - AttributeError: ...
FAILED xarray/tests/test_dask.py::test_map_blocks_da_transformations[<lambda>0]
FAILED xarray/tests/test_dask.py::test_map_blocks_da_transformations[<lambda>1]
FAILED xarray/tests/test_dask.py::test_map_blocks_da_transformations[<lambda>2]
FAILED xarray/tests/test_dask.py::test_map_blocks_da_transformations[<lambda>3]
FAILED xarray/tests/test_dask.py::test_map_blocks_da_transformations[<lambda>4]
FAILED xarray/tests/test_dask.py::test_map_blocks_da_transformations[<lambda>5]
FAILED xarray/tests/test_dask.py::test_map_blocks_da_transformations[<lambda>6]
FAILED xarray/tests/test_dask.py::test_map_blocks_da_transformations[<lambda>7]
FAILED xarray/tests/test_dask.py::test_map_blocks_ds_transformations[<lambda>0]
FAILED xarray/tests/test_dask.py::test_map_blocks_ds_transformations[<lambda>1]
FAILED xarray/tests/test_dask.py::test_map_blocks_ds_transformations[<lambda>2]
FAILED xarray/tests/test_dask.py::test_map_blocks_ds_transformations[<lambda>3]
FAILED xarray/tests/test_dask.py::test_map_blocks_ds_transformations[<lambda>4]
FAILED xarray/tests/test_dask.py::test_map_blocks_ds_transformations[<lambda>5]
FAILED xarray/tests/test_dask.py::test_map_blocks_ds_transformations[<lambda>6]
FAILED xarray/tests/test_dask.py::test_map_blocks_ds_transformations[<lambda>7]
FAILED xarray/tests/test_dask.py::test_map_blocks_da_ds_with_template[obj0]
FAILED xarray/tests/test_dask.py::test_map_blocks_da_ds_with_template[obj1]
FAILED xarray/tests/test_dask.py::test_map_blocks_template_convert_object - A...
FAILED xarray/tests/test_dask.py::test_map_blocks_errors_bad_template[obj0]
FAILED xarray/tests/test_dask.py::test_map_blocks_errors_bad_template[obj1]
FAILED xarray/tests/test_dask.py::test_map_blocks_errors_bad_template_2 - Att...
FAILED xarray/tests/test_dask.py::test_map_blocks_object_method[obj0] - Attri...
FAILED xarray/tests/test_dask.py::test_map_blocks_object_method[obj1] - Attri...
FAILED xarray/tests/test_dask.py::test_map_blocks_hlg_layers - AttributeError...
FAILED xarray/tests/test_dataset.py::TestDataset::test_sel_categorical - Impo...
FAILED xarray/tests/test_dataset.py::TestDataset::test_sel_categorical_error
FAILED xarray/tests/test_dataset.py::TestDataset::test_categorical_multiindex
FAILED xarray/tests/test_dataset.py::TestDataset::test_reindex_warning - Type...
FAILED xarray/tests/test_dataset.py::TestDataset::test_drop_index_labels - Fa...
FAILED xarray/tests/test_dataset.py::TestDataset::test_from_dataframe_categorical
FAILED xarray/tests/test_dataset.py::TestDataset::test_polyfit_warnings - ass...
FAILED xarray/tests/test_dataset.py::test_raise_no_warning_for_nan_in_binary_ops
FAILED xarray/tests/test_variable.py::test_raise_no_warning_for_nan_in_binary_ops
= 47 failed, 1690 passed, 17 skipped, 73 xfailed, 26 xpassed, 8282 warnings in 65.54s (0:01:05) =
ERROR conda.cli.main_run:execute(124): `conda run pytest --no-header -rA -p no:cacheprovider xarray/tests/test_dask.py xarray/tests/test_dataset.py xarray/tests/test_interp.py xarray/tests/test_variable.py` failed. (See above for error)

 
[pydata__xarray__0.12] [pydata__xarray-4493] Return Code: 1 

>>>>> Some Tests Failed
[pydata__xarray__0.12] [pydata__xarray-4493] Test script run successful 
