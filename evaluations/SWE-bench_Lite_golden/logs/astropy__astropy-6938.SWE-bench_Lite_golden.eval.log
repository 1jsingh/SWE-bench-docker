[astropy__astropy__1.3] [astropy__astropy-6938] Task Metadata:
	- Instance ID: astropy__astropy-6938
	- Testbed: astropy__astropy__1.3
	- 
	- Evaluation Model: SWE-bench_Lite_golden 
[astropy__astropy__1.3] [astropy__astropy-6938] Command: git status --porcelain 
[astropy__astropy__1.3] [astropy__astropy-6938] Subprocess args: {"cwd": "/home/swe-bench/astropy__astropy", "check": true, "shell": false, "capture_output": false, "text": true, "stdout": -1, "stderr": -2} 
[astropy__astropy__1.3] [astropy__astropy-6938] Std. Output:
 
[astropy__astropy__1.3] [astropy__astropy-6938] Return Code: 0 
[astropy__astropy__1.3] [astropy__astropy-6938] Command: git -c advice.detachedHead=false checkout c76af9ed6bb89bfba45b9f5bc1e635188278e2fa 
[astropy__astropy__1.3] [astropy__astropy-6938] Subprocess args: {"cwd": "/home/swe-bench/astropy__astropy", "check": true, "shell": false, "capture_output": false, "text": true, "stdout": -1, "stderr": -2} 
[astropy__astropy__1.3] [astropy__astropy-6938] Std. Output:
Previous HEAD position was 848c8fa21 Merge pull request #6868 from eteq/coc_wording
HEAD is now at c76af9ed6 Merge pull request #6981 from mhvk/iers-b-for-3.0
M	astropy_helpers
 
[astropy__astropy__1.3] [astropy__astropy-6938] Return Code: 0 
[astropy__astropy__1.3] [astropy__astropy-6938] Command: git apply -v /home/swe-bench/temp_astropy__astropy-6938_pred_try.patch 
[astropy__astropy__1.3] [astropy__astropy-6938] Subprocess args: {"cwd": "/home/swe-bench/astropy__astropy", "check": false, "shell": false, "capture_output": false, "text": true, "stdout": -1, "stderr": -2} 
[astropy__astropy__1.3] [astropy__astropy-6938] Std. Output:
Checking patch astropy/io/fits/fitsrec.py...
Applied patch astropy/io/fits/fitsrec.py cleanly.
 
[astropy__astropy__1.3] [astropy__astropy-6938] Return Code: 0 
[astropy__astropy__1.3] [astropy__astropy-6938] Apply patch successful (pred_try) 
>>>>> Applied Patch (pred_try)
[astropy__astropy__1.3] [astropy__astropy-6938] Command: git apply -v -R /home/swe-bench/temp_astropy__astropy-6938_pred_try.patch 
[astropy__astropy__1.3] [astropy__astropy-6938] Subprocess args: {"cwd": "/home/swe-bench/astropy__astropy", "check": false, "shell": false, "capture_output": false, "text": true, "stdout": -1, "stderr": -2} 
[astropy__astropy__1.3] [astropy__astropy-6938] Std. Output:
Checking patch astropy/io/fits/fitsrec.py...
Applied patch astropy/io/fits/fitsrec.py cleanly.
 
[astropy__astropy__1.3] [astropy__astropy-6938] Return Code: 0 
[astropy__astropy__1.3] [astropy__astropy-6938] Revert patch successful (pred_try) 
>>>>> Applied Patch (pred_try)
[astropy__astropy__1.3] [astropy__astropy-6938] Command: git apply -v /home/swe-bench/temp_astropy__astropy-6938_pred.patch 
[astropy__astropy__1.3] [astropy__astropy-6938] Subprocess args: {"cwd": "/home/swe-bench/astropy__astropy", "check": false, "shell": false, "capture_output": false, "text": true, "stdout": -1, "stderr": -2} 
[astropy__astropy__1.3] [astropy__astropy-6938] Std. Output:
Checking patch astropy/io/fits/fitsrec.py...
Applied patch astropy/io/fits/fitsrec.py cleanly.
 
[astropy__astropy__1.3] [astropy__astropy-6938] Return Code: 0 
[astropy__astropy__1.3] [astropy__astropy-6938] Apply patch successful (pred) 
>>>>> Applied Patch (pred)
[astropy__astropy__1.3] [astropy__astropy-6938] Command: git restore astropy/io/fits/tests/test_checksum.py 
[astropy__astropy__1.3] [astropy__astropy-6938] Subprocess args: {"cwd": "/home/swe-bench/astropy__astropy", "check": true, "shell": false, "capture_output": false, "text": true, "stdout": -1, "stderr": -2} 
[astropy__astropy__1.3] [astropy__astropy-6938] Std. Output:
 
[astropy__astropy__1.3] [astropy__astropy-6938] Return Code: 0 
[astropy__astropy__1.3] [astropy__astropy-6938] Command: git restore astropy/io/fits/tests/test_table.py 
[astropy__astropy__1.3] [astropy__astropy-6938] Subprocess args: {"cwd": "/home/swe-bench/astropy__astropy", "check": true, "shell": false, "capture_output": false, "text": true, "stdout": -1, "stderr": -2} 
[astropy__astropy__1.3] [astropy__astropy-6938] Std. Output:
 
[astropy__astropy__1.3] [astropy__astropy-6938] Return Code: 0 
[astropy__astropy__1.3] [astropy__astropy-6938] Command: git apply -v /home/swe-bench/temp_astropy__astropy-6938_test.patch 
[astropy__astropy__1.3] [astropy__astropy-6938] Subprocess args: {"cwd": "/home/swe-bench/astropy__astropy", "check": false, "shell": false, "capture_output": false, "text": true, "stdout": -1, "stderr": -2} 
[astropy__astropy__1.3] [astropy__astropy-6938] Std. Output:
Checking patch astropy/io/fits/tests/test_checksum.py...
Checking patch astropy/io/fits/tests/test_table.py...
Applied patch astropy/io/fits/tests/test_checksum.py cleanly.
Applied patch astropy/io/fits/tests/test_table.py cleanly.
 
[astropy__astropy__1.3] [astropy__astropy-6938] Return Code: 0 
[astropy__astropy__1.3] [astropy__astropy-6938] Apply patch successful (test) 
>>>>> Applied Patch (test)
Test Script: conda run -n astropy__astropy__1.3 pytest --no-header -rA -p no:cacheprovider astropy/io/fits/tests/test_checksum.py astropy/io/fits/tests/test_table.py;
[astropy__astropy__1.3] [astropy__astropy-6938] Command: conda run -n astropy__astropy__1.3 pytest --no-header -rA -p no:cacheprovider astropy/io/fits/tests/test_checksum.py astropy/io/fits/tests/test_table.py 
[astropy__astropy__1.3] [astropy__astropy-6938] Subprocess args: {"cwd": "/home/swe-bench/astropy__astropy", "check": false, "shell": false, "capture_output": false, "text": true, "stdout": -1, "stderr": -2, "timeout": 900} 
[astropy__astropy__1.3] [astropy__astropy-6938] Std. Output:
============================= test session starts ==============================
collected 107 items

astropy/io/fits/tests/test_checksum.py ......FF.FFF.F..F.FFF             [ 19%]
astropy/io/fits/tests/test_table.py FFF.FFFFFFEEEEEEEEEEEEEEEEEEEEEEEEEE [ 52%]
EEEEEEEEEEEEEEEEEEEEEEEEEEssEEEEEEEEEEEEEEEEEEEEFF.                      [100%]

==================================== ERRORS ====================================
_____ ERROR at teardown of TestTableFunctions.test_new_table_from_recarray _____

cls = <class '_pytest.runner.CallInfo'>
func = <function call_runtest_hook.<locals>.<lambda> at 0x7d2b56299550>
when = 'teardown'
reraise = (<class '_pytest.outcomes.Exit'>, <class 'KeyboardInterrupt'>)

    @classmethod
    def from_call(
        cls,
        func: "Callable[[], TResult]",
        when: "Literal['collect', 'setup', 'call', 'teardown']",
        reraise: Optional[
            Union[Type[BaseException], Tuple[Type[BaseException], ...]]
        ] = None,
    ) -> "CallInfo[TResult]":
        """Call func, wrapping the result in a CallInfo.
    
        :param func:
            The function to call. Called without arguments.
        :param when:
            The phase in which the function is called.
        :param reraise:
            Exception or exceptions that shall propagate if raised by the
            function, instead of being wrapped in the CallInfo.
        """
        excinfo = None
        start = timing.time()
        precise_start = timing.perf_counter()
        try:
>           result: Optional[TResult] = func()

../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/runner.py:341: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/runner.py:262: in <lambda>
    lambda: ihook(item=item, **kwds), when=when, reraise=reraise
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/pluggy/_hooks.py:493: in __call__
    return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/pluggy/_manager.py:115: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/runner.py:182: in pytest_runtest_teardown
    item.session._setupstate.teardown_exact(nextitem)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/runner.py:537: in teardown_exact
    raise exceptions[0]
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/runner.py:526: in teardown_exact
    fin()
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/fixtures.py:701: in <lambda>
    subrequest.node.addfinalizer(lambda: fixturedef.finish(request=subrequest))
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/fixtures.py:1031: in finish
    raise exc
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/fixtures.py:1024: in finish
    func()
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/fixtures.py:911: in _teardown_yield_fixture
    next(it)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <astropy.io.fits.tests.test_table.TestTableFunctions object at 0x7d2b56d60760>
request = <SubRequest '_xunit_setup_method_fixture_TestTableFunctions' for <Function test_new_table_from_recarray>>

    @fixtures.fixture(
        autouse=True,
        scope="function",
        # Use a unique name to speed up lookup.
        name=f"_xunit_setup_method_fixture_{self.obj.__qualname__}",
    )
    def xunit_setup_method_fixture(self, request) -> Generator[None, None, None]:
        method = request.function
        if setup_method is not None:
            func = getattr(self, setup_name)
            _call_with_optional_argument(func, method)
            if emit_nose_setup_warning:
                warnings.warn(
                    NOSE_SUPPORT_METHOD.format(
                        nodeid=request.node.nodeid, method="setup"
                    ),
                    stacklevel=2,
                )
        yield
        if teardown_method is not None:
            func = getattr(self, teardown_name)
            _call_with_optional_argument(func, method)
            if emit_nose_teardown_warning:
>               warnings.warn(
                    NOSE_SUPPORT_METHOD.format(
                        nodeid=request.node.nodeid, method="teardown"
                    ),
                    stacklevel=2,
                )
E               pytest.PytestRemovedIn8Warning: Support for nose tests is deprecated and will be removed in a future release.
E               astropy/io/fits/tests/test_table.py::TestTableFunctions::test_new_table_from_recarray is using nose-specific method: `teardown(self)`
E               To remove this warning, rename it to `teardown_method(self)`
E               See docs: https://docs.pytest.org/en/stable/deprecations.html#support-for-tests-written-for-nose

../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/python.py:909: PytestRemovedIn8Warning
____________ ERROR at setup of TestTableFunctions.test_new_fitsrec _____________

cls = <class '_pytest.runner.CallInfo'>
func = <function call_runtest_hook.<locals>.<lambda> at 0x7d2b567b4e50>
when = 'setup'
reraise = (<class '_pytest.outcomes.Exit'>, <class 'KeyboardInterrupt'>)

    @classmethod
    def from_call(
        cls,
        func: "Callable[[], TResult]",
        when: "Literal['collect', 'setup', 'call', 'teardown']",
        reraise: Optional[
            Union[Type[BaseException], Tuple[Type[BaseException], ...]]
        ] = None,
    ) -> "CallInfo[TResult]":
        """Call func, wrapping the result in a CallInfo.
    
        :param func:
            The function to call. Called without arguments.
        :param when:
            The phase in which the function is called.
        :param reraise:
            Exception or exceptions that shall propagate if raised by the
            function, instead of being wrapped in the CallInfo.
        """
        excinfo = None
        start = timing.time()
        precise_start = timing.perf_counter()
        try:
>           result: Optional[TResult] = func()

../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/runner.py:341: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/runner.py:262: in <lambda>
    lambda: ihook(item=item, **kwds), when=when, reraise=reraise
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/pluggy/_hooks.py:493: in __call__
    return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/pluggy/_manager.py:115: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/runner.py:157: in pytest_runtest_setup
    item.session._setupstate.setup(item)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/runner.py:497: in setup
    raise exc
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/runner.py:494: in setup
    col.setup()
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/python.py:1791: in setup
    self._request._fillfixtures()
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/fixtures.py:566: in _fillfixtures
    item.funcargs[argname] = self.getfixturevalue(argname)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/fixtures.py:585: in getfixturevalue
    fixturedef = self._get_active_fixturedef(argname)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/fixtures.py:607: in _get_active_fixturedef
    self._compute_fixture_value(fixturedef)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/fixtures.py:693: in _compute_fixture_value
    fixturedef.execute(request=subrequest)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/fixtures.py:1069: in execute
    result = ihook.pytest_fixture_setup(fixturedef=self, request=request)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/pluggy/_hooks.py:493: in __call__
    return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/pluggy/_manager.py:115: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/fixtures.py:1123: in pytest_fixture_setup
    result = call_fixture_func(fixturefunc, request, kwargs)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/fixtures.py:895: in call_fixture_func
    fixture_result = next(generator)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <astropy.io.fits.tests.test_table.TestTableFunctions object at 0x7d2b56d56910>
request = <SubRequest '_xunit_setup_method_fixture_TestTableFunctions' for <Function test_new_fitsrec>>

    @fixtures.fixture(
        autouse=True,
        scope="function",
        # Use a unique name to speed up lookup.
        name=f"_xunit_setup_method_fixture_{self.obj.__qualname__}",
    )
    def xunit_setup_method_fixture(self, request) -> Generator[None, None, None]:
        method = request.function
        if setup_method is not None:
            func = getattr(self, setup_name)
            _call_with_optional_argument(func, method)
            if emit_nose_setup_warning:
>               warnings.warn(
                    NOSE_SUPPORT_METHOD.format(
                        nodeid=request.node.nodeid, method="setup"
                    ),
                    stacklevel=2,
                )
E               pytest.PytestRemovedIn8Warning: Support for nose tests is deprecated and will be removed in a future release.
E               astropy/io/fits/tests/test_table.py::TestTableFunctions::test_new_fitsrec is using nose-specific method: `setup(self)`
E               To remove this warning, rename it to `setup_method(self)`
E               See docs: https://docs.pytest.org/en/stable/deprecations.html#support-for-tests-written-for-nose

../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/python.py:898: PytestRemovedIn8Warning
_________ ERROR at setup of TestTableFunctions.test_appending_a_column _________

cls = <class '_pytest.runner.CallInfo'>
func = <function call_runtest_hook.<locals>.<lambda> at 0x7d2b56d99a60>
when = 'setup'
reraise = (<class '_pytest.outcomes.Exit'>, <class 'KeyboardInterrupt'>)

    @classmethod
    def from_call(
        cls,
        func: "Callable[[], TResult]",
        when: "Literal['collect', 'setup', 'call', 'teardown']",
        reraise: Optional[
            Union[Type[BaseException], Tuple[Type[BaseException], ...]]
        ] = None,
    ) -> "CallInfo[TResult]":
        """Call func, wrapping the result in a CallInfo.
    
        :param func:
            The function to call. Called without arguments.
        :param when:
            The phase in which the function is called.
        :param reraise:
            Exception or exceptions that shall propagate if raised by the
            function, instead of being wrapped in the CallInfo.
        """
        excinfo = None
        start = timing.time()
        precise_start = timing.perf_counter()
        try:
>           result: Optional[TResult] = func()

../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/runner.py:341: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/runner.py:262: in <lambda>
    lambda: ihook(item=item, **kwds), when=when, reraise=reraise
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/pluggy/_hooks.py:493: in __call__
    return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/pluggy/_manager.py:115: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/runner.py:157: in pytest_runtest_setup
    item.session._setupstate.setup(item)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/runner.py:497: in setup
    raise exc
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/runner.py:494: in setup
    col.setup()
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/python.py:1791: in setup
    self._request._fillfixtures()
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/fixtures.py:566: in _fillfixtures
    item.funcargs[argname] = self.getfixturevalue(argname)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/fixtures.py:585: in getfixturevalue
    fixturedef = self._get_active_fixturedef(argname)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/fixtures.py:607: in _get_active_fixturedef
    self._compute_fixture_value(fixturedef)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/fixtures.py:693: in _compute_fixture_value
    fixturedef.execute(request=subrequest)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/fixtures.py:1069: in execute
    result = ihook.pytest_fixture_setup(fixturedef=self, request=request)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/pluggy/_hooks.py:493: in __call__
    return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/pluggy/_manager.py:115: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/fixtures.py:1123: in pytest_fixture_setup
    result = call_fixture_func(fixturefunc, request, kwargs)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/fixtures.py:895: in call_fixture_func
    fixture_result = next(generator)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <astropy.io.fits.tests.test_table.TestTableFunctions object at 0x7d2b571aceb0>
request = <SubRequest '_xunit_setup_method_fixture_TestTableFunctions' for <Function test_appending_a_column>>

    @fixtures.fixture(
        autouse=True,
        scope="function",
        # Use a unique name to speed up lookup.
        name=f"_xunit_setup_method_fixture_{self.obj.__qualname__}",
    )
    def xunit_setup_method_fixture(self, request) -> Generator[None, None, None]:
        method = request.function
        if setup_method is not None:
            func = getattr(self, setup_name)
            _call_with_optional_argument(func, method)
            if emit_nose_setup_warning:
>               warnings.warn(
                    NOSE_SUPPORT_METHOD.format(
                        nodeid=request.node.nodeid, method="setup"
                    ),
                    stacklevel=2,
                )
E               pytest.PytestRemovedIn8Warning: Support for nose tests is deprecated and will be removed in a future release.
E               astropy/io/fits/tests/test_table.py::TestTableFunctions::test_appending_a_column is using nose-specific method: `setup(self)`
E               To remove this warning, rename it to `setup_method(self)`
E               See docs: https://docs.pytest.org/en/stable/deprecations.html#support-for-tests-written-for-nose

../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/python.py:898: PytestRemovedIn8Warning
__________ ERROR at setup of TestTableFunctions.test_adding_a_column ___________

cls = <class '_pytest.runner.CallInfo'>
func = <function call_runtest_hook.<locals>.<lambda> at 0x7d2b567b4f70>
when = 'setup'
reraise = (<class '_pytest.outcomes.Exit'>, <class 'KeyboardInterrupt'>)

    @classmethod
    def from_call(
        cls,
        func: "Callable[[], TResult]",
        when: "Literal['collect', 'setup', 'call', 'teardown']",
        reraise: Optional[
            Union[Type[BaseException], Tuple[Type[BaseException], ...]]
        ] = None,
    ) -> "CallInfo[TResult]":
        """Call func, wrapping the result in a CallInfo.
    
        :param func:
            The function to call. Called without arguments.
        :param when:
            The phase in which the function is called.
        :param reraise:
            Exception or exceptions that shall propagate if raised by the
            function, instead of being wrapped in the CallInfo.
        """
        excinfo = None
        start = timing.time()
        precise_start = timing.perf_counter()
        try:
>           result: Optional[TResult] = func()

../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/runner.py:341: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/runner.py:262: in <lambda>
    lambda: ihook(item=item, **kwds), when=when, reraise=reraise
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/pluggy/_hooks.py:493: in __call__
    return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/pluggy/_manager.py:115: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/runner.py:157: in pytest_runtest_setup
    item.session._setupstate.setup(item)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/runner.py:497: in setup
    raise exc
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/runner.py:494: in setup
    col.setup()
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/python.py:1791: in setup
    self._request._fillfixtures()
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/fixtures.py:566: in _fillfixtures
    item.funcargs[argname] = self.getfixturevalue(argname)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/fixtures.py:585: in getfixturevalue
    fixturedef = self._get_active_fixturedef(argname)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/fixtures.py:607: in _get_active_fixturedef
    self._compute_fixture_value(fixturedef)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/fixtures.py:693: in _compute_fixture_value
    fixturedef.execute(request=subrequest)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/fixtures.py:1069: in execute
    result = ihook.pytest_fixture_setup(fixturedef=self, request=request)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/pluggy/_hooks.py:493: in __call__
    return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/pluggy/_manager.py:115: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/fixtures.py:1123: in pytest_fixture_setup
    result = call_fixture_func(fixturefunc, request, kwargs)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/fixtures.py:895: in call_fixture_func
    fixture_result = next(generator)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <astropy.io.fits.tests.test_table.TestTableFunctions object at 0x7d2b5713fb80>
request = <SubRequest '_xunit_setup_method_fixture_TestTableFunctions' for <Function test_adding_a_column>>

    @fixtures.fixture(
        autouse=True,
        scope="function",
        # Use a unique name to speed up lookup.
        name=f"_xunit_setup_method_fixture_{self.obj.__qualname__}",
    )
    def xunit_setup_method_fixture(self, request) -> Generator[None, None, None]:
        method = request.function
        if setup_method is not None:
            func = getattr(self, setup_name)
            _call_with_optional_argument(func, method)
            if emit_nose_setup_warning:
>               warnings.warn(
                    NOSE_SUPPORT_METHOD.format(
                        nodeid=request.node.nodeid, method="setup"
                    ),
                    stacklevel=2,
                )
E               pytest.PytestRemovedIn8Warning: Support for nose tests is deprecated and will be removed in a future release.
E               astropy/io/fits/tests/test_table.py::TestTableFunctions::test_adding_a_column is using nose-specific method: `setup(self)`
E               To remove this warning, rename it to `setup_method(self)`
E               See docs: https://docs.pytest.org/en/stable/deprecations.html#support-for-tests-written-for-nose

../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/python.py:898: PytestRemovedIn8Warning
____________ ERROR at setup of TestTableFunctions.test_merge_tables ____________

cls = <class '_pytest.runner.CallInfo'>
func = <function call_runtest_hook.<locals>.<lambda> at 0x7d2b5590a1f0>
when = 'setup'
reraise = (<class '_pytest.outcomes.Exit'>, <class 'KeyboardInterrupt'>)

    @classmethod
    def from_call(
        cls,
        func: "Callable[[], TResult]",
        when: "Literal['collect', 'setup', 'call', 'teardown']",
        reraise: Optional[
            Union[Type[BaseException], Tuple[Type[BaseException], ...]]
        ] = None,
    ) -> "CallInfo[TResult]":
        """Call func, wrapping the result in a CallInfo.
    
        :param func:
            The function to call. Called without arguments.
        :param when:
            The phase in which the function is called.
        :param reraise:
            Exception or exceptions that shall propagate if raised by the
            function, instead of being wrapped in the CallInfo.
        """
        excinfo = None
        start = timing.time()
        precise_start = timing.perf_counter()
        try:
>           result: Optional[TResult] = func()

../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/runner.py:341: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/runner.py:262: in <lambda>
    lambda: ihook(item=item, **kwds), when=when, reraise=reraise
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/pluggy/_hooks.py:493: in __call__
    return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/pluggy/_manager.py:115: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/runner.py:157: in pytest_runtest_setup
    item.session._setupstate.setup(item)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/runner.py:497: in setup
    raise exc
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/runner.py:494: in setup
    col.setup()
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/python.py:1791: in setup
    self._request._fillfixtures()
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/fixtures.py:566: in _fillfixtures
    item.funcargs[argname] = self.getfixturevalue(argname)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/fixtures.py:585: in getfixturevalue
    fixturedef = self._get_active_fixturedef(argname)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/fixtures.py:607: in _get_active_fixturedef
    self._compute_fixture_value(fixturedef)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/fixtures.py:693: in _compute_fixture_value
    fixturedef.execute(request=subrequest)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/fixtures.py:1069: in execute
    result = ihook.pytest_fixture_setup(fixturedef=self, request=request)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/pluggy/_hooks.py:493: in __call__
    return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/pluggy/_manager.py:115: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/fixtures.py:1123: in pytest_fixture_setup
    result = call_fixture_func(fixturefunc, request, kwargs)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/fixtures.py:895: in call_fixture_func
    fixture_result = next(generator)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <astropy.io.fits.tests.test_table.TestTableFunctions object at 0x7d2b57147c40>
request = <SubRequest '_xunit_setup_method_fixture_TestTableFunctions' for <Function test_merge_tables>>

    @fixtures.fixture(
        autouse=True,
        scope="function",
        # Use a unique name to speed up lookup.
        name=f"_xunit_setup_method_fixture_{self.obj.__qualname__}",
    )
    def xunit_setup_method_fixture(self, request) -> Generator[None, None, None]:
        method = request.function
        if setup_method is not None:
            func = getattr(self, setup_name)
            _call_with_optional_argument(func, method)
            if emit_nose_setup_warning:
>               warnings.warn(
                    NOSE_SUPPORT_METHOD.format(
                        nodeid=request.node.nodeid, method="setup"
                    ),
                    stacklevel=2,
                )
E               pytest.PytestRemovedIn8Warning: Support for nose tests is deprecated and will be removed in a future release.
E               astropy/io/fits/tests/test_table.py::TestTableFunctions::test_merge_tables is using nose-specific method: `setup(self)`
E               To remove this warning, rename it to `setup_method(self)`
E               See docs: https://docs.pytest.org/en/stable/deprecations.html#support-for-tests-written-for-nose

../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/python.py:898: PytestRemovedIn8Warning
______ ERROR at setup of TestTableFunctions.test_modify_column_attributes ______

cls = <class '_pytest.runner.CallInfo'>
func = <function call_runtest_hook.<locals>.<lambda> at 0x7d2b56d99a60>
when = 'setup'
reraise = (<class '_pytest.outcomes.Exit'>, <class 'KeyboardInterrupt'>)

    @classmethod
    def from_call(
        cls,
        func: "Callable[[], TResult]",
        when: "Literal['collect', 'setup', 'call', 'teardown']",
        reraise: Optional[
            Union[Type[BaseException], Tuple[Type[BaseException], ...]]
        ] = None,
    ) -> "CallInfo[TResult]":
        """Call func, wrapping the result in a CallInfo.
    
        :param func:
            The function to call. Called without arguments.
        :param when:
            The phase in which the function is called.
        :param reraise:
            Exception or exceptions that shall propagate if raised by the
            function, instead of being wrapped in the CallInfo.
        """
        excinfo = None
        start = timing.time()
        precise_start = timing.perf_counter()
        try:
>           result: Optional[TResult] = func()

../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/runner.py:341: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/runner.py:262: in <lambda>
    lambda: ihook(item=item, **kwds), when=when, reraise=reraise
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/pluggy/_hooks.py:493: in __call__
    return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/pluggy/_manager.py:115: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/runner.py:157: in pytest_runtest_setup
    item.session._setupstate.setup(item)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/runner.py:497: in setup
    raise exc
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/runner.py:494: in setup
    col.setup()
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/python.py:1791: in setup
    self._request._fillfixtures()
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/fixtures.py:566: in _fillfixtures
    item.funcargs[argname] = self.getfixturevalue(argname)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/fixtures.py:585: in getfixturevalue
    fixturedef = self._get_active_fixturedef(argname)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/fixtures.py:607: in _get_active_fixturedef
    self._compute_fixture_value(fixturedef)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/fixtures.py:693: in _compute_fixture_value
    fixturedef.execute(request=subrequest)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/fixtures.py:1069: in execute
    result = ihook.pytest_fixture_setup(fixturedef=self, request=request)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/pluggy/_hooks.py:493: in __call__
    return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/pluggy/_manager.py:115: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/fixtures.py:1123: in pytest_fixture_setup
    result = call_fixture_func(fixturefunc, request, kwargs)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/fixtures.py:895: in call_fixture_func
    fixture_result = next(generator)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <astropy.io.fits.tests.test_table.TestTableFunctions object at 0x7d2b570be370>
request = <SubRequest '_xunit_setup_method_fixture_TestTableFunctions' for <Function test_modify_column_attributes>>

    @fixtures.fixture(
        autouse=True,
        scope="function",
        # Use a unique name to speed up lookup.
        name=f"_xunit_setup_method_fixture_{self.obj.__qualname__}",
    )
    def xunit_setup_method_fixture(self, request) -> Generator[None, None, None]:
        method = request.function
        if setup_method is not None:
            func = getattr(self, setup_name)
            _call_with_optional_argument(func, method)
            if emit_nose_setup_warning:
>               warnings.warn(
                    NOSE_SUPPORT_METHOD.format(
                        nodeid=request.node.nodeid, method="setup"
                    ),
                    stacklevel=2,
                )
E               pytest.PytestRemovedIn8Warning: Support for nose tests is deprecated and will be removed in a future release.
E               astropy/io/fits/tests/test_table.py::TestTableFunctions::test_modify_column_attributes is using nose-specific method: `setup(self)`
E               To remove this warning, rename it to `setup_method(self)`
E               See docs: https://docs.pytest.org/en/stable/deprecations.html#support-for-tests-written-for-nose

../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/python.py:898: PytestRemovedIn8Warning
_____________ ERROR at setup of TestTableFunctions.test_mask_array _____________

cls = <class '_pytest.runner.CallInfo'>
func = <function call_runtest_hook.<locals>.<lambda> at 0x7d2b55b6a700>
when = 'setup'
reraise = (<class '_pytest.outcomes.Exit'>, <class 'KeyboardInterrupt'>)

    @classmethod
    def from_call(
        cls,
        func: "Callable[[], TResult]",
        when: "Literal['collect', 'setup', 'call', 'teardown']",
        reraise: Optional[
            Union[Type[BaseException], Tuple[Type[BaseException], ...]]
        ] = None,
    ) -> "CallInfo[TResult]":
        """Call func, wrapping the result in a CallInfo.
    
        :param func:
            The function to call. Called without arguments.
        :param when:
            The phase in which the function is called.
        :param reraise:
            Exception or exceptions that shall propagate if raised by the
            function, instead of being wrapped in the CallInfo.
        """
        excinfo = None
        start = timing.time()
        precise_start = timing.perf_counter()
        try:
>           result: Optional[TResult] = func()

../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/runner.py:341: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/runner.py:262: in <lambda>
    lambda: ihook(item=item, **kwds), when=when, reraise=reraise
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/pluggy/_hooks.py:493: in __call__
    return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/pluggy/_manager.py:115: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/runner.py:157: in pytest_runtest_setup
    item.session._setupstate.setup(item)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/runner.py:497: in setup
    raise exc
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/runner.py:494: in setup
    col.setup()
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/python.py:1791: in setup
    self._request._fillfixtures()
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/fixtures.py:566: in _fillfixtures
    item.funcargs[argname] = self.getfixturevalue(argname)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/fixtures.py:585: in getfixturevalue
    fixturedef = self._get_active_fixturedef(argname)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/fixtures.py:607: in _get_active_fixturedef
    self._compute_fixture_value(fixturedef)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/fixtures.py:693: in _compute_fixture_value
    fixturedef.execute(request=subrequest)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/fixtures.py:1069: in execute
    result = ihook.pytest_fixture_setup(fixturedef=self, request=request)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/pluggy/_hooks.py:493: in __call__
    return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/pluggy/_manager.py:115: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/fixtures.py:1123: in pytest_fixture_setup
    result = call_fixture_func(fixturefunc, request, kwargs)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/fixtures.py:895: in call_fixture_func
    fixture_result = next(generator)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <astropy.io.fits.tests.test_table.TestTableFunctions object at 0x7d2b570be8e0>
request = <SubRequest '_xunit_setup_method_fixture_TestTableFunctions' for <Function test_mask_array>>

    @fixtures.fixture(
        autouse=True,
        scope="function",
        # Use a unique name to speed up lookup.
        name=f"_xunit_setup_method_fixture_{self.obj.__qualname__}",
    )
    def xunit_setup_method_fixture(self, request) -> Generator[None, None, None]:
        method = request.function
        if setup_method is not None:
            func = getattr(self, setup_name)
            _call_with_optional_argument(func, method)
            if emit_nose_setup_warning:
>               warnings.warn(
                    NOSE_SUPPORT_METHOD.format(
                        nodeid=request.node.nodeid, method="setup"
                    ),
                    stacklevel=2,
                )
E               pytest.PytestRemovedIn8Warning: Support for nose tests is deprecated and will be removed in a future release.
E               astropy/io/fits/tests/test_table.py::TestTableFunctions::test_mask_array is using nose-specific method: `setup(self)`
E               To remove this warning, rename it to `setup_method(self)`
E               See docs: https://docs.pytest.org/en/stable/deprecations.html#support-for-tests-written-for-nose

../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/python.py:898: PytestRemovedIn8Warning
____________ ERROR at setup of TestTableFunctions.test_slice_a_row _____________

cls = <class '_pytest.runner.CallInfo'>
func = <function call_runtest_hook.<locals>.<lambda> at 0x7d2b55b93040>
when = 'setup'
reraise = (<class '_pytest.outcomes.Exit'>, <class 'KeyboardInterrupt'>)

    @classmethod
    def from_call(
        cls,
        func: "Callable[[], TResult]",
        when: "Literal['collect', 'setup', 'call', 'teardown']",
        reraise: Optional[
            Union[Type[BaseException], Tuple[Type[BaseException], ...]]
        ] = None,
    ) -> "CallInfo[TResult]":
        """Call func, wrapping the result in a CallInfo.
    
        :param func:
            The function to call. Called without arguments.
        :param when:
            The phase in which the function is called.
        :param reraise:
            Exception or exceptions that shall propagate if raised by the
            function, instead of being wrapped in the CallInfo.
        """
        excinfo = None
        start = timing.time()
        precise_start = timing.perf_counter()
        try:
>           result: Optional[TResult] = func()

../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/runner.py:341: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/runner.py:262: in <lambda>
    lambda: ihook(item=item, **kwds), when=when, reraise=reraise
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/pluggy/_hooks.py:493: in __call__
    return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/pluggy/_manager.py:115: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/runner.py:157: in pytest_runtest_setup
    item.session._setupstate.setup(item)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/runner.py:497: in setup
    raise exc
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/runner.py:494: in setup
    col.setup()
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/python.py:1791: in setup
    self._request._fillfixtures()
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/fixtures.py:566: in _fillfixtures
    item.funcargs[argname] = self.getfixturevalue(argname)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/fixtures.py:585: in getfixturevalue
    fixturedef = self._get_active_fixturedef(argname)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/fixtures.py:607: in _get_active_fixturedef
    self._compute_fixture_value(fixturedef)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/fixtures.py:693: in _compute_fixture_value
    fixturedef.execute(request=subrequest)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/fixtures.py:1069: in execute
    result = ihook.pytest_fixture_setup(fixturedef=self, request=request)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/pluggy/_hooks.py:493: in __call__
    return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/pluggy/_manager.py:115: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/fixtures.py:1123: in pytest_fixture_setup
    result = call_fixture_func(fixturefunc, request, kwargs)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/fixtures.py:895: in call_fixture_func
    fixture_result = next(generator)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <astropy.io.fits.tests.test_table.TestTableFunctions object at 0x7d2b570bedc0>
request = <SubRequest '_xunit_setup_method_fixture_TestTableFunctions' for <Function test_slice_a_row>>

    @fixtures.fixture(
        autouse=True,
        scope="function",
        # Use a unique name to speed up lookup.
        name=f"_xunit_setup_method_fixture_{self.obj.__qualname__}",
    )
    def xunit_setup_method_fixture(self, request) -> Generator[None, None, None]:
        method = request.function
        if setup_method is not None:
            func = getattr(self, setup_name)
            _call_with_optional_argument(func, method)
            if emit_nose_setup_warning:
>               warnings.warn(
                    NOSE_SUPPORT_METHOD.format(
                        nodeid=request.node.nodeid, method="setup"
                    ),
                    stacklevel=2,
                )
E               pytest.PytestRemovedIn8Warning: Support for nose tests is deprecated and will be removed in a future release.
E               astropy/io/fits/tests/test_table.py::TestTableFunctions::test_slice_a_row is using nose-specific method: `setup(self)`
E               To remove this warning, rename it to `setup_method(self)`
E               See docs: https://docs.pytest.org/en/stable/deprecations.html#support-for-tests-written-for-nose

../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/python.py:898: PytestRemovedIn8Warning
__________ ERROR at setup of TestTableFunctions.test_fits_record_len ___________

cls = <class '_pytest.runner.CallInfo'>
func = <function call_runtest_hook.<locals>.<lambda> at 0x7d2b56d99e50>
when = 'setup'
reraise = (<class '_pytest.outcomes.Exit'>, <class 'KeyboardInterrupt'>)

    @classmethod
    def from_call(
        cls,
        func: "Callable[[], TResult]",
        when: "Literal['collect', 'setup', 'call', 'teardown']",
        reraise: Optional[
            Union[Type[BaseException], Tuple[Type[BaseException], ...]]
        ] = None,
    ) -> "CallInfo[TResult]":
        """Call func, wrapping the result in a CallInfo.
    
        :param func:
            The function to call. Called without arguments.
        :param when:
            The phase in which the function is called.
        :param reraise:
            Exception or exceptions that shall propagate if raised by the
            function, instead of being wrapped in the CallInfo.
        """
        excinfo = None
        start = timing.time()
        precise_start = timing.perf_counter()
        try:
>           result: Optional[TResult] = func()

../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/runner.py:341: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/runner.py:262: in <lambda>
    lambda: ihook(item=item, **kwds), when=when, reraise=reraise
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/pluggy/_hooks.py:493: in __call__
    return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/pluggy/_manager.py:115: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/runner.py:157: in pytest_runtest_setup
    item.session._setupstate.setup(item)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/runner.py:497: in setup
    raise exc
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/runner.py:494: in setup
    col.setup()
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/python.py:1791: in setup
    self._request._fillfixtures()
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/fixtures.py:566: in _fillfixtures
    item.funcargs[argname] = self.getfixturevalue(argname)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/fixtures.py:585: in getfixturevalue
    fixturedef = self._get_active_fixturedef(argname)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/fixtures.py:607: in _get_active_fixturedef
    self._compute_fixture_value(fixturedef)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/fixtures.py:693: in _compute_fixture_value
    fixturedef.execute(request=subrequest)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/fixtures.py:1069: in execute
    result = ihook.pytest_fixture_setup(fixturedef=self, request=request)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/pluggy/_hooks.py:493: in __call__
    return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/pluggy/_manager.py:115: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/fixtures.py:1123: in pytest_fixture_setup
    result = call_fixture_func(fixturefunc, request, kwargs)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/fixtures.py:895: in call_fixture_func
    fixture_result = next(generator)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <astropy.io.fits.tests.test_table.TestTableFunctions object at 0x7d2b570bed60>
request = <SubRequest '_xunit_setup_method_fixture_TestTableFunctions' for <Function test_fits_record_len>>

    @fixtures.fixture(
        autouse=True,
        scope="function",
        # Use a unique name to speed up lookup.
        name=f"_xunit_setup_method_fixture_{self.obj.__qualname__}",
    )
    def xunit_setup_method_fixture(self, request) -> Generator[None, None, None]:
        method = request.function
        if setup_method is not None:
            func = getattr(self, setup_name)
            _call_with_optional_argument(func, method)
            if emit_nose_setup_warning:
>               warnings.warn(
                    NOSE_SUPPORT_METHOD.format(
                        nodeid=request.node.nodeid, method="setup"
                    ),
                    stacklevel=2,
                )
E               pytest.PytestRemovedIn8Warning: Support for nose tests is deprecated and will be removed in a future release.
E               astropy/io/fits/tests/test_table.py::TestTableFunctions::test_fits_record_len is using nose-specific method: `setup(self)`
E               To remove this warning, rename it to `setup_method(self)`
E               See docs: https://docs.pytest.org/en/stable/deprecations.html#support-for-tests-written-for-nose

../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/python.py:898: PytestRemovedIn8Warning
__________ ERROR at setup of TestTableFunctions.test_add_data_by_rows __________

cls = <class '_pytest.runner.CallInfo'>
func = <function call_runtest_hook.<locals>.<lambda> at 0x7d2b56445f70>
when = 'setup'
reraise = (<class '_pytest.outcomes.Exit'>, <class 'KeyboardInterrupt'>)

    @classmethod
    def from_call(
        cls,
        func: "Callable[[], TResult]",
        when: "Literal['collect', 'setup', 'call', 'teardown']",
        reraise: Optional[
            Union[Type[BaseException], Tuple[Type[BaseException], ...]]
        ] = None,
    ) -> "CallInfo[TResult]":
        """Call func, wrapping the result in a CallInfo.
    
        :param func:
            The function to call. Called without arguments.
        :param when:
            The phase in which the function is called.
        :param reraise:
            Exception or exceptions that shall propagate if raised by the
            function, instead of being wrapped in the CallInfo.
        """
        excinfo = None
        start = timing.time()
        precise_start = timing.perf_counter()
        try:
>           result: Optional[TResult] = func()

../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/runner.py:341: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/runner.py:262: in <lambda>
    lambda: ihook(item=item, **kwds), when=when, reraise=reraise
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/pluggy/_hooks.py:493: in __call__
    return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/pluggy/_manager.py:115: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/runner.py:157: in pytest_runtest_setup
    item.session._setupstate.setup(item)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/runner.py:497: in setup
    raise exc
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/runner.py:494: in setup
    col.setup()
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/python.py:1791: in setup
    self._request._fillfixtures()
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/fixtures.py:566: in _fillfixtures
    item.funcargs[argname] = self.getfixturevalue(argname)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/fixtures.py:585: in getfixturevalue
    fixturedef = self._get_active_fixturedef(argname)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/fixtures.py:607: in _get_active_fixturedef
    self._compute_fixture_value(fixturedef)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/fixtures.py:693: in _compute_fixture_value
    fixturedef.execute(request=subrequest)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/fixtures.py:1069: in execute
    result = ihook.pytest_fixture_setup(fixturedef=self, request=request)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/pluggy/_hooks.py:493: in __call__
    return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/pluggy/_manager.py:115: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/fixtures.py:1123: in pytest_fixture_setup
    result = call_fixture_func(fixturefunc, request, kwargs)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/fixtures.py:895: in call_fixture_func
    fixture_result = next(generator)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <astropy.io.fits.tests.test_table.TestTableFunctions object at 0x7d2b570c1b80>
request = <SubRequest '_xunit_setup_method_fixture_TestTableFunctions' for <Function test_add_data_by_rows>>

    @fixtures.fixture(
        autouse=True,
        scope="function",
        # Use a unique name to speed up lookup.
        name=f"_xunit_setup_method_fixture_{self.obj.__qualname__}",
    )
    def xunit_setup_method_fixture(self, request) -> Generator[None, None, None]:
        method = request.function
        if setup_method is not None:
            func = getattr(self, setup_name)
            _call_with_optional_argument(func, method)
            if emit_nose_setup_warning:
>               warnings.warn(
                    NOSE_SUPPORT_METHOD.format(
                        nodeid=request.node.nodeid, method="setup"
                    ),
                    stacklevel=2,
                )
E               pytest.PytestRemovedIn8Warning: Support for nose tests is deprecated and will be removed in a future release.
E               astropy/io/fits/tests/test_table.py::TestTableFunctions::test_add_data_by_rows is using nose-specific method: `setup(self)`
E               To remove this warning, rename it to `setup_method(self)`
E               See docs: https://docs.pytest.org/en/stable/deprecations.html#support-for-tests-written-for-nose

../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/python.py:898: PytestRemovedIn8Warning
___ ERROR at setup of TestTableFunctions.test_assign_multiple_rows_to_table ____

cls = <class '_pytest.runner.CallInfo'>
func = <function call_runtest_hook.<locals>.<lambda> at 0x7d2b56452820>
when = 'setup'
reraise = (<class '_pytest.outcomes.Exit'>, <class 'KeyboardInterrupt'>)

    @classmethod
    def from_call(
        cls,
        func: "Callable[[], TResult]",
        when: "Literal['collect', 'setup', 'call', 'teardown']",
        reraise: Optional[
            Union[Type[BaseException], Tuple[Type[BaseException], ...]]
        ] = None,
    ) -> "CallInfo[TResult]":
        """Call func, wrapping the result in a CallInfo.
    
        :param func:
            The function to call. Called without arguments.
        :param when:
            The phase in which the function is called.
        :param reraise:
            Exception or exceptions that shall propagate if raised by the
            function, instead of being wrapped in the CallInfo.
        """
        excinfo = None
        start = timing.time()
        precise_start = timing.perf_counter()
        try:
>           result: Optional[TResult] = func()

../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/runner.py:341: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/runner.py:262: in <lambda>
    lambda: ihook(item=item, **kwds), when=when, reraise=reraise
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/pluggy/_hooks.py:493: in __call__
    return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/pluggy/_manager.py:115: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/runner.py:157: in pytest_runtest_setup
    item.session._setupstate.setup(item)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/runner.py:497: in setup
    raise exc
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/runner.py:494: in setup
    col.setup()
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/python.py:1791: in setup
    self._request._fillfixtures()
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/fixtures.py:566: in _fillfixtures
    item.funcargs[argname] = self.getfixturevalue(argname)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/fixtures.py:585: in getfixturevalue
    fixturedef = self._get_active_fixturedef(argname)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/fixtures.py:607: in _get_active_fixturedef
    self._compute_fixture_value(fixturedef)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/fixtures.py:693: in _compute_fixture_value
    fixturedef.execute(request=subrequest)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/fixtures.py:1069: in execute
    result = ihook.pytest_fixture_setup(fixturedef=self, request=request)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/pluggy/_hooks.py:493: in __call__
    return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/pluggy/_manager.py:115: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/fixtures.py:1123: in pytest_fixture_setup
    result = call_fixture_func(fixturefunc, request, kwargs)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/fixtures.py:895: in call_fixture_func
    fixture_result = next(generator)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <astropy.io.fits.tests.test_table.TestTableFunctions object at 0x7d2b570c1070>
request = <SubRequest '_xunit_setup_method_fixture_TestTableFunctions' for <Function test_assign_multiple_rows_to_table>>

    @fixtures.fixture(
        autouse=True,
        scope="function",
        # Use a unique name to speed up lookup.
        name=f"_xunit_setup_method_fixture_{self.obj.__qualname__}",
    )
    def xunit_setup_method_fixture(self, request) -> Generator[None, None, None]:
        method = request.function
        if setup_method is not None:
            func = getattr(self, setup_name)
            _call_with_optional_argument(func, method)
            if emit_nose_setup_warning:
>               warnings.warn(
                    NOSE_SUPPORT_METHOD.format(
                        nodeid=request.node.nodeid, method="setup"
                    ),
                    stacklevel=2,
                )
E               pytest.PytestRemovedIn8Warning: Support for nose tests is deprecated and will be removed in a future release.
E               astropy/io/fits/tests/test_table.py::TestTableFunctions::test_assign_multiple_rows_to_table is using nose-specific method: `setup(self)`
E               To remove this warning, rename it to `setup_method(self)`
E               See docs: https://docs.pytest.org/en/stable/deprecations.html#support-for-tests-written-for-nose

../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/python.py:898: PytestRemovedIn8Warning
_______ ERROR at setup of TestTableFunctions.test_verify_data_references _______

cls = <class '_pytest.runner.CallInfo'>
func = <function call_runtest_hook.<locals>.<lambda> at 0x7d2b564521f0>
when = 'setup'
reraise = (<class '_pytest.outcomes.Exit'>, <class 'KeyboardInterrupt'>)

    @classmethod
    def from_call(
        cls,
        func: "Callable[[], TResult]",
        when: "Literal['collect', 'setup', 'call', 'teardown']",
        reraise: Optional[
            Union[Type[BaseException], Tuple[Type[BaseException], ...]]
        ] = None,
    ) -> "CallInfo[TResult]":
        """Call func, wrapping the result in a CallInfo.
    
        :param func:
            The function to call. Called without arguments.
        :param when:
            The phase in which the function is called.
        :param reraise:
            Exception or exceptions that shall propagate if raised by the
            function, instead of being wrapped in the CallInfo.
        """
        excinfo = None
        start = timing.time()
        precise_start = timing.perf_counter()
        try:
>           result: Optional[TResult] = func()

../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/runner.py:341: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/runner.py:262: in <lambda>
    lambda: ihook(item=item, **kwds), when=when, reraise=reraise
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/pluggy/_hooks.py:493: in __call__
    return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/pluggy/_manager.py:115: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/runner.py:157: in pytest_runtest_setup
    item.session._setupstate.setup(item)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/runner.py:497: in setup
    raise exc
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/runner.py:494: in setup
    col.setup()
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/python.py:1791: in setup
    self._request._fillfixtures()
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/fixtures.py:566: in _fillfixtures
    item.funcargs[argname] = self.getfixturevalue(argname)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/fixtures.py:585: in getfixturevalue
    fixturedef = self._get_active_fixturedef(argname)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/fixtures.py:607: in _get_active_fixturedef
    self._compute_fixture_value(fixturedef)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/fixtures.py:693: in _compute_fixture_value
    fixturedef.execute(request=subrequest)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/fixtures.py:1069: in execute
    result = ihook.pytest_fixture_setup(fixturedef=self, request=request)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/pluggy/_hooks.py:493: in __call__
    return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/pluggy/_manager.py:115: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/fixtures.py:1123: in pytest_fixture_setup
    result = call_fixture_func(fixturefunc, request, kwargs)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/fixtures.py:895: in call_fixture_func
    fixture_result = next(generator)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <astropy.io.fits.tests.test_table.TestTableFunctions object at 0x7d2b570c14c0>
request = <SubRequest '_xunit_setup_method_fixture_TestTableFunctions' for <Function test_verify_data_references>>

    @fixtures.fixture(
        autouse=True,
        scope="function",
        # Use a unique name to speed up lookup.
        name=f"_xunit_setup_method_fixture_{self.obj.__qualname__}",
    )
    def xunit_setup_method_fixture(self, request) -> Generator[None, None, None]:
        method = request.function
        if setup_method is not None:
            func = getattr(self, setup_name)
            _call_with_optional_argument(func, method)
            if emit_nose_setup_warning:
>               warnings.warn(
                    NOSE_SUPPORT_METHOD.format(
                        nodeid=request.node.nodeid, method="setup"
                    ),
                    stacklevel=2,
                )
E               pytest.PytestRemovedIn8Warning: Support for nose tests is deprecated and will be removed in a future release.
E               astropy/io/fits/tests/test_table.py::TestTableFunctions::test_verify_data_references is using nose-specific method: `setup(self)`
E               To remove this warning, rename it to `setup_method(self)`
E               See docs: https://docs.pytest.org/en/stable/deprecations.html#support-for-tests-written-for-nose

../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/python.py:898: PytestRemovedIn8Warning
_______ ERROR at setup of TestTableFunctions.test_new_table_with_ndarray _______

cls = <class '_pytest.runner.CallInfo'>
func = <function call_runtest_hook.<locals>.<lambda> at 0x7d2b55b6aee0>
when = 'setup'
reraise = (<class '_pytest.outcomes.Exit'>, <class 'KeyboardInterrupt'>)

    @classmethod
    def from_call(
        cls,
        func: "Callable[[], TResult]",
        when: "Literal['collect', 'setup', 'call', 'teardown']",
        reraise: Optional[
            Union[Type[BaseException], Tuple[Type[BaseException], ...]]
        ] = None,
    ) -> "CallInfo[TResult]":
        """Call func, wrapping the result in a CallInfo.
    
        :param func:
            The function to call. Called without arguments.
        :param when:
            The phase in which the function is called.
        :param reraise:
            Exception or exceptions that shall propagate if raised by the
            function, instead of being wrapped in the CallInfo.
        """
        excinfo = None
        start = timing.time()
        precise_start = timing.perf_counter()
        try:
>           result: Optional[TResult] = func()

../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/runner.py:341: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/runner.py:262: in <lambda>
    lambda: ihook(item=item, **kwds), when=when, reraise=reraise
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/pluggy/_hooks.py:493: in __call__
    return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/pluggy/_manager.py:115: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/runner.py:157: in pytest_runtest_setup
    item.session._setupstate.setup(item)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/runner.py:497: in setup
    raise exc
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/runner.py:494: in setup
    col.setup()
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/python.py:1791: in setup
    self._request._fillfixtures()
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/fixtures.py:566: in _fillfixtures
    item.funcargs[argname] = self.getfixturevalue(argname)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/fixtures.py:585: in getfixturevalue
    fixturedef = self._get_active_fixturedef(argname)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/fixtures.py:607: in _get_active_fixturedef
    self._compute_fixture_value(fixturedef)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/fixtures.py:693: in _compute_fixture_value
    fixturedef.execute(request=subrequest)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/fixtures.py:1069: in execute
    result = ihook.pytest_fixture_setup(fixturedef=self, request=request)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/pluggy/_hooks.py:493: in __call__
    return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/pluggy/_manager.py:115: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/fixtures.py:1123: in pytest_fixture_setup
    result = call_fixture_func(fixturefunc, request, kwargs)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/fixtures.py:895: in call_fixture_func
    fixture_result = next(generator)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <astropy.io.fits.tests.test_table.TestTableFunctions object at 0x7d2b570c1c10>
request = <SubRequest '_xunit_setup_method_fixture_TestTableFunctions' for <Function test_new_table_with_ndarray>>

    @fixtures.fixture(
        autouse=True,
        scope="function",
        # Use a unique name to speed up lookup.
        name=f"_xunit_setup_method_fixture_{self.obj.__qualname__}",
    )
    def xunit_setup_method_fixture(self, request) -> Generator[None, None, None]:
        method = request.function
        if setup_method is not None:
            func = getattr(self, setup_name)
            _call_with_optional_argument(func, method)
            if emit_nose_setup_warning:
>               warnings.warn(
                    NOSE_SUPPORT_METHOD.format(
                        nodeid=request.node.nodeid, method="setup"
                    ),
                    stacklevel=2,
                )
E               pytest.PytestRemovedIn8Warning: Support for nose tests is deprecated and will be removed in a future release.
E               astropy/io/fits/tests/test_table.py::TestTableFunctions::test_new_table_with_ndarray is using nose-specific method: `setup(self)`
E               To remove this warning, rename it to `setup_method(self)`
E               See docs: https://docs.pytest.org/en/stable/deprecations.html#support-for-tests-written-for-nose

../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/python.py:898: PytestRemovedIn8Warning
______ ERROR at setup of TestTableFunctions.test_new_table_with_fits_rec _______

cls = <class '_pytest.runner.CallInfo'>
func = <function call_runtest_hook.<locals>.<lambda> at 0x7d2b56476dc0>
when = 'setup'
reraise = (<class '_pytest.outcomes.Exit'>, <class 'KeyboardInterrupt'>)

    @classmethod
    def from_call(
        cls,
        func: "Callable[[], TResult]",
        when: "Literal['collect', 'setup', 'call', 'teardown']",
        reraise: Optional[
            Union[Type[BaseException], Tuple[Type[BaseException], ...]]
        ] = None,
    ) -> "CallInfo[TResult]":
        """Call func, wrapping the result in a CallInfo.
    
        :param func:
            The function to call. Called without arguments.
        :param when:
            The phase in which the function is called.
        :param reraise:
            Exception or exceptions that shall propagate if raised by the
            function, instead of being wrapped in the CallInfo.
        """
        excinfo = None
        start = timing.time()
        precise_start = timing.perf_counter()
        try:
>           result: Optional[TResult] = func()

../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/runner.py:341: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/runner.py:262: in <lambda>
    lambda: ihook(item=item, **kwds), when=when, reraise=reraise
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/pluggy/_hooks.py:493: in __call__
    return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/pluggy/_manager.py:115: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/runner.py:157: in pytest_runtest_setup
    item.session._setupstate.setup(item)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/runner.py:497: in setup
    raise exc
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/runner.py:494: in setup
    col.setup()
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/python.py:1791: in setup
    self._request._fillfixtures()
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/fixtures.py:566: in _fillfixtures
    item.funcargs[argname] = self.getfixturevalue(argname)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/fixtures.py:585: in getfixturevalue
    fixturedef = self._get_active_fixturedef(argname)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/fixtures.py:607: in _get_active_fixturedef
    self._compute_fixture_value(fixturedef)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/fixtures.py:693: in _compute_fixture_value
    fixturedef.execute(request=subrequest)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/fixtures.py:1069: in execute
    result = ihook.pytest_fixture_setup(fixturedef=self, request=request)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/pluggy/_hooks.py:493: in __call__
    return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/pluggy/_manager.py:115: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/fixtures.py:1123: in pytest_fixture_setup
    result = call_fixture_func(fixturefunc, request, kwargs)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/fixtures.py:895: in call_fixture_func
    fixture_result = next(generator)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <astropy.io.fits.tests.test_table.TestTableFunctions object at 0x7d2b570c10a0>
request = <SubRequest '_xunit_setup_method_fixture_TestTableFunctions' for <Function test_new_table_with_fits_rec>>

    @fixtures.fixture(
        autouse=True,
        scope="function",
        # Use a unique name to speed up lookup.
        name=f"_xunit_setup_method_fixture_{self.obj.__qualname__}",
    )
    def xunit_setup_method_fixture(self, request) -> Generator[None, None, None]:
        method = request.function
        if setup_method is not None:
            func = getattr(self, setup_name)
            _call_with_optional_argument(func, method)
            if emit_nose_setup_warning:
>               warnings.warn(
                    NOSE_SUPPORT_METHOD.format(
                        nodeid=request.node.nodeid, method="setup"
                    ),
                    stacklevel=2,
                )
E               pytest.PytestRemovedIn8Warning: Support for nose tests is deprecated and will be removed in a future release.
E               astropy/io/fits/tests/test_table.py::TestTableFunctions::test_new_table_with_fits_rec is using nose-specific method: `setup(self)`
E               To remove this warning, rename it to `setup_method(self)`
E               See docs: https://docs.pytest.org/en/stable/deprecations.html#support-for-tests-written-for-nose

../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/python.py:898: PytestRemovedIn8Warning
_____ ERROR at setup of TestTableFunctions.test_bin_table_hdu_constructor ______

cls = <class '_pytest.runner.CallInfo'>
func = <function call_runtest_hook.<locals>.<lambda> at 0x7d2b564734c0>
when = 'setup'
reraise = (<class '_pytest.outcomes.Exit'>, <class 'KeyboardInterrupt'>)

    @classmethod
    def from_call(
        cls,
        func: "Callable[[], TResult]",
        when: "Literal['collect', 'setup', 'call', 'teardown']",
        reraise: Optional[
            Union[Type[BaseException], Tuple[Type[BaseException], ...]]
        ] = None,
    ) -> "CallInfo[TResult]":
        """Call func, wrapping the result in a CallInfo.
    
        :param func:
            The function to call. Called without arguments.
        :param when:
            The phase in which the function is called.
        :param reraise:
            Exception or exceptions that shall propagate if raised by the
            function, instead of being wrapped in the CallInfo.
        """
        excinfo = None
        start = timing.time()
        precise_start = timing.perf_counter()
        try:
>           result: Optional[TResult] = func()

../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/runner.py:341: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/runner.py:262: in <lambda>
    lambda: ihook(item=item, **kwds), when=when, reraise=reraise
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/pluggy/_hooks.py:493: in __call__
    return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/pluggy/_manager.py:115: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/runner.py:157: in pytest_runtest_setup
    item.session._setupstate.setup(item)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/runner.py:497: in setup
    raise exc
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/runner.py:494: in setup
    col.setup()
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/python.py:1791: in setup
    self._request._fillfixtures()
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/fixtures.py:566: in _fillfixtures
    item.funcargs[argname] = self.getfixturevalue(argname)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/fixtures.py:585: in getfixturevalue
    fixturedef = self._get_active_fixturedef(argname)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/fixtures.py:607: in _get_active_fixturedef
    self._compute_fixture_value(fixturedef)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/fixtures.py:693: in _compute_fixture_value
    fixturedef.execute(request=subrequest)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/fixtures.py:1069: in execute
    result = ihook.pytest_fixture_setup(fixturedef=self, request=request)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/pluggy/_hooks.py:493: in __call__
    return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/pluggy/_manager.py:115: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/fixtures.py:1123: in pytest_fixture_setup
    result = call_fixture_func(fixturefunc, request, kwargs)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/fixtures.py:895: in call_fixture_func
    fixture_result = next(generator)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <astropy.io.fits.tests.test_table.TestTableFunctions object at 0x7d2b570c1880>
request = <SubRequest '_xunit_setup_method_fixture_TestTableFunctions' for <Function test_bin_table_hdu_constructor>>

    @fixtures.fixture(
        autouse=True,
        scope="function",
        # Use a unique name to speed up lookup.
        name=f"_xunit_setup_method_fixture_{self.obj.__qualname__}",
    )
    def xunit_setup_method_fixture(self, request) -> Generator[None, None, None]:
        method = request.function
        if setup_method is not None:
            func = getattr(self, setup_name)
            _call_with_optional_argument(func, method)
            if emit_nose_setup_warning:
>               warnings.warn(
                    NOSE_SUPPORT_METHOD.format(
                        nodeid=request.node.nodeid, method="setup"
                    ),
                    stacklevel=2,
                )
E               pytest.PytestRemovedIn8Warning: Support for nose tests is deprecated and will be removed in a future release.
E               astropy/io/fits/tests/test_table.py::TestTableFunctions::test_bin_table_hdu_constructor is using nose-specific method: `setup(self)`
E               To remove this warning, rename it to `setup_method(self)`
E               See docs: https://docs.pytest.org/en/stable/deprecations.html#support-for-tests-written-for-nose

../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/python.py:898: PytestRemovedIn8Warning
________ ERROR at setup of TestTableFunctions.test_constructor_name_arg ________

cls = <class '_pytest.runner.CallInfo'>
func = <function call_runtest_hook.<locals>.<lambda> at 0x7d2b5645dc10>
when = 'setup'
reraise = (<class '_pytest.outcomes.Exit'>, <class 'KeyboardInterrupt'>)

    @classmethod
    def from_call(
        cls,
        func: "Callable[[], TResult]",
        when: "Literal['collect', 'setup', 'call', 'teardown']",
        reraise: Optional[
            Union[Type[BaseException], Tuple[Type[BaseException], ...]]
        ] = None,
    ) -> "CallInfo[TResult]":
        """Call func, wrapping the result in a CallInfo.
    
        :param func:
            The function to call. Called without arguments.
        :param when:
            The phase in which the function is called.
        :param reraise:
            Exception or exceptions that shall propagate if raised by the
            function, instead of being wrapped in the CallInfo.
        """
        excinfo = None
        start = timing.time()
        precise_start = timing.perf_counter()
        try:
>           result: Optional[TResult] = func()

../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/runner.py:341: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/runner.py:262: in <lambda>
    lambda: ihook(item=item, **kwds), when=when, reraise=reraise
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/pluggy/_hooks.py:493: in __call__
    return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/pluggy/_manager.py:115: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/runner.py:157: in pytest_runtest_setup
    item.session._setupstate.setup(item)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/runner.py:497: in setup
    raise exc
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/runner.py:494: in setup
    col.setup()
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/python.py:1791: in setup
    self._request._fillfixtures()
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/fixtures.py:566: in _fillfixtures
    item.funcargs[argname] = self.getfixturevalue(argname)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/fixtures.py:585: in getfixturevalue
    fixturedef = self._get_active_fixturedef(argname)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/fixtures.py:607: in _get_active_fixturedef
    self._compute_fixture_value(fixturedef)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/fixtures.py:693: in _compute_fixture_value
    fixturedef.execute(request=subrequest)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/fixtures.py:1069: in execute
    result = ihook.pytest_fixture_setup(fixturedef=self, request=request)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/pluggy/_hooks.py:493: in __call__
    return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/pluggy/_manager.py:115: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/fixtures.py:1123: in pytest_fixture_setup
    result = call_fixture_func(fixturefunc, request, kwargs)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/fixtures.py:895: in call_fixture_func
    fixture_result = next(generator)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <astropy.io.fits.tests.test_table.TestTableFunctions object at 0x7d2b570ea400>
request = <SubRequest '_xunit_setup_method_fixture_TestTableFunctions' for <Function test_constructor_name_arg>>

    @fixtures.fixture(
        autouse=True,
        scope="function",
        # Use a unique name to speed up lookup.
        name=f"_xunit_setup_method_fixture_{self.obj.__qualname__}",
    )
    def xunit_setup_method_fixture(self, request) -> Generator[None, None, None]:
        method = request.function
        if setup_method is not None:
            func = getattr(self, setup_name)
            _call_with_optional_argument(func, method)
            if emit_nose_setup_warning:
>               warnings.warn(
                    NOSE_SUPPORT_METHOD.format(
                        nodeid=request.node.nodeid, method="setup"
                    ),
                    stacklevel=2,
                )
E               pytest.PytestRemovedIn8Warning: Support for nose tests is deprecated and will be removed in a future release.
E               astropy/io/fits/tests/test_table.py::TestTableFunctions::test_constructor_name_arg is using nose-specific method: `setup(self)`
E               To remove this warning, rename it to `setup_method(self)`
E               See docs: https://docs.pytest.org/en/stable/deprecations.html#support-for-tests-written-for-nose

../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/python.py:898: PytestRemovedIn8Warning
________ ERROR at setup of TestTableFunctions.test_constructor_ver_arg _________

cls = <class '_pytest.runner.CallInfo'>
func = <function call_runtest_hook.<locals>.<lambda> at 0x7d2b565669d0>
when = 'setup'
reraise = (<class '_pytest.outcomes.Exit'>, <class 'KeyboardInterrupt'>)

    @classmethod
    def from_call(
        cls,
        func: "Callable[[], TResult]",
        when: "Literal['collect', 'setup', 'call', 'teardown']",
        reraise: Optional[
            Union[Type[BaseException], Tuple[Type[BaseException], ...]]
        ] = None,
    ) -> "CallInfo[TResult]":
        """Call func, wrapping the result in a CallInfo.
    
        :param func:
            The function to call. Called without arguments.
        :param when:
            The phase in which the function is called.
        :param reraise:
            Exception or exceptions that shall propagate if raised by the
            function, instead of being wrapped in the CallInfo.
        """
        excinfo = None
        start = timing.time()
        precise_start = timing.perf_counter()
        try:
>           result: Optional[TResult] = func()

../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/runner.py:341: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/runner.py:262: in <lambda>
    lambda: ihook(item=item, **kwds), when=when, reraise=reraise
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/pluggy/_hooks.py:493: in __call__
    return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/pluggy/_manager.py:115: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/runner.py:157: in pytest_runtest_setup
    item.session._setupstate.setup(item)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/runner.py:497: in setup
    raise exc
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/runner.py:494: in setup
    col.setup()
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/python.py:1791: in setup
    self._request._fillfixtures()
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/fixtures.py:566: in _fillfixtures
    item.funcargs[argname] = self.getfixturevalue(argname)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/fixtures.py:585: in getfixturevalue
    fixturedef = self._get_active_fixturedef(argname)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/fixtures.py:607: in _get_active_fixturedef
    self._compute_fixture_value(fixturedef)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/fixtures.py:693: in _compute_fixture_value
    fixturedef.execute(request=subrequest)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/fixtures.py:1069: in execute
    result = ihook.pytest_fixture_setup(fixturedef=self, request=request)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/pluggy/_hooks.py:493: in __call__
    return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/pluggy/_manager.py:115: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/fixtures.py:1123: in pytest_fixture_setup
    result = call_fixture_func(fixturefunc, request, kwargs)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/fixtures.py:895: in call_fixture_func
    fixture_result = next(generator)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <astropy.io.fits.tests.test_table.TestTableFunctions object at 0x7d2b570eac10>
request = <SubRequest '_xunit_setup_method_fixture_TestTableFunctions' for <Function test_constructor_ver_arg>>

    @fixtures.fixture(
        autouse=True,
        scope="function",
        # Use a unique name to speed up lookup.
        name=f"_xunit_setup_method_fixture_{self.obj.__qualname__}",
    )
    def xunit_setup_method_fixture(self, request) -> Generator[None, None, None]:
        method = request.function
        if setup_method is not None:
            func = getattr(self, setup_name)
            _call_with_optional_argument(func, method)
            if emit_nose_setup_warning:
>               warnings.warn(
                    NOSE_SUPPORT_METHOD.format(
                        nodeid=request.node.nodeid, method="setup"
                    ),
                    stacklevel=2,
                )
E               pytest.PytestRemovedIn8Warning: Support for nose tests is deprecated and will be removed in a future release.
E               astropy/io/fits/tests/test_table.py::TestTableFunctions::test_constructor_ver_arg is using nose-specific method: `setup(self)`
E               To remove this warning, rename it to `setup_method(self)`
E               See docs: https://docs.pytest.org/en/stable/deprecations.html#support-for-tests-written-for-nose

../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/python.py:898: PytestRemovedIn8Warning
__________ ERROR at setup of TestTableFunctions.test_unicode_colname ___________

cls = <class '_pytest.runner.CallInfo'>
func = <function call_runtest_hook.<locals>.<lambda> at 0x7d2b564761f0>
when = 'setup'
reraise = (<class '_pytest.outcomes.Exit'>, <class 'KeyboardInterrupt'>)

    @classmethod
    def from_call(
        cls,
        func: "Callable[[], TResult]",
        when: "Literal['collect', 'setup', 'call', 'teardown']",
        reraise: Optional[
            Union[Type[BaseException], Tuple[Type[BaseException], ...]]
        ] = None,
    ) -> "CallInfo[TResult]":
        """Call func, wrapping the result in a CallInfo.
    
        :param func:
            The function to call. Called without arguments.
        :param when:
            The phase in which the function is called.
        :param reraise:
            Exception or exceptions that shall propagate if raised by the
            function, instead of being wrapped in the CallInfo.
        """
        excinfo = None
        start = timing.time()
        precise_start = timing.perf_counter()
        try:
>           result: Optional[TResult] = func()

../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/runner.py:341: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/runner.py:262: in <lambda>
    lambda: ihook(item=item, **kwds), when=when, reraise=reraise
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/pluggy/_hooks.py:493: in __call__
    return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/pluggy/_manager.py:115: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/runner.py:157: in pytest_runtest_setup
    item.session._setupstate.setup(item)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/runner.py:497: in setup
    raise exc
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/runner.py:494: in setup
    col.setup()
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/python.py:1791: in setup
    self._request._fillfixtures()
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/fixtures.py:566: in _fillfixtures
    item.funcargs[argname] = self.getfixturevalue(argname)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/fixtures.py:585: in getfixturevalue
    fixturedef = self._get_active_fixturedef(argname)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/fixtures.py:607: in _get_active_fixturedef
    self._compute_fixture_value(fixturedef)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/fixtures.py:693: in _compute_fixture_value
    fixturedef.execute(request=subrequest)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/fixtures.py:1069: in execute
    result = ihook.pytest_fixture_setup(fixturedef=self, request=request)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/pluggy/_hooks.py:493: in __call__
    return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/pluggy/_manager.py:115: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/fixtures.py:1123: in pytest_fixture_setup
    result = call_fixture_func(fixturefunc, request, kwargs)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/fixtures.py:895: in call_fixture_func
    fixture_result = next(generator)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <astropy.io.fits.tests.test_table.TestTableFunctions object at 0x7d2b570ea2e0>
request = <SubRequest '_xunit_setup_method_fixture_TestTableFunctions' for <Function test_unicode_colname>>

    @fixtures.fixture(
        autouse=True,
        scope="function",
        # Use a unique name to speed up lookup.
        name=f"_xunit_setup_method_fixture_{self.obj.__qualname__}",
    )
    def xunit_setup_method_fixture(self, request) -> Generator[None, None, None]:
        method = request.function
        if setup_method is not None:
            func = getattr(self, setup_name)
            _call_with_optional_argument(func, method)
            if emit_nose_setup_warning:
>               warnings.warn(
                    NOSE_SUPPORT_METHOD.format(
                        nodeid=request.node.nodeid, method="setup"
                    ),
                    stacklevel=2,
                )
E               pytest.PytestRemovedIn8Warning: Support for nose tests is deprecated and will be removed in a future release.
E               astropy/io/fits/tests/test_table.py::TestTableFunctions::test_unicode_colname is using nose-specific method: `setup(self)`
E               To remove this warning, rename it to `setup_method(self)`
E               See docs: https://docs.pytest.org/en/stable/deprecations.html#support-for-tests-written-for-nose

../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/python.py:898: PytestRemovedIn8Warning
____ ERROR at setup of TestTableFunctions.test_bin_table_with_logical_array ____

cls = <class '_pytest.runner.CallInfo'>
func = <function call_runtest_hook.<locals>.<lambda> at 0x7d2b5645d430>
when = 'setup'
reraise = (<class '_pytest.outcomes.Exit'>, <class 'KeyboardInterrupt'>)

    @classmethod
    def from_call(
        cls,
        func: "Callable[[], TResult]",
        when: "Literal['collect', 'setup', 'call', 'teardown']",
        reraise: Optional[
            Union[Type[BaseException], Tuple[Type[BaseException], ...]]
        ] = None,
    ) -> "CallInfo[TResult]":
        """Call func, wrapping the result in a CallInfo.
    
        :param func:
            The function to call. Called without arguments.
        :param when:
            The phase in which the function is called.
        :param reraise:
            Exception or exceptions that shall propagate if raised by the
            function, instead of being wrapped in the CallInfo.
        """
        excinfo = None
        start = timing.time()
        precise_start = timing.perf_counter()
        try:
>           result: Optional[TResult] = func()

../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/runner.py:341: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/runner.py:262: in <lambda>
    lambda: ihook(item=item, **kwds), when=when, reraise=reraise
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/pluggy/_hooks.py:493: in __call__
    return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/pluggy/_manager.py:115: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/runner.py:157: in pytest_runtest_setup
    item.session._setupstate.setup(item)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/runner.py:497: in setup
    raise exc
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/runner.py:494: in setup
    col.setup()
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/python.py:1791: in setup
    self._request._fillfixtures()
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/fixtures.py:566: in _fillfixtures
    item.funcargs[argname] = self.getfixturevalue(argname)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/fixtures.py:585: in getfixturevalue
    fixturedef = self._get_active_fixturedef(argname)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/fixtures.py:607: in _get_active_fixturedef
    self._compute_fixture_value(fixturedef)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/fixtures.py:693: in _compute_fixture_value
    fixturedef.execute(request=subrequest)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/fixtures.py:1069: in execute
    result = ihook.pytest_fixture_setup(fixturedef=self, request=request)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/pluggy/_hooks.py:493: in __call__
    return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/pluggy/_manager.py:115: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/fixtures.py:1123: in pytest_fixture_setup
    result = call_fixture_func(fixturefunc, request, kwargs)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/fixtures.py:895: in call_fixture_func
    fixture_result = next(generator)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <astropy.io.fits.tests.test_table.TestTableFunctions object at 0x7d2b570ea280>
request = <SubRequest '_xunit_setup_method_fixture_TestTableFunctions' for <Function test_bin_table_with_logical_array>>

    @fixtures.fixture(
        autouse=True,
        scope="function",
        # Use a unique name to speed up lookup.
        name=f"_xunit_setup_method_fixture_{self.obj.__qualname__}",
    )
    def xunit_setup_method_fixture(self, request) -> Generator[None, None, None]:
        method = request.function
        if setup_method is not None:
            func = getattr(self, setup_name)
            _call_with_optional_argument(func, method)
            if emit_nose_setup_warning:
>               warnings.warn(
                    NOSE_SUPPORT_METHOD.format(
                        nodeid=request.node.nodeid, method="setup"
                    ),
                    stacklevel=2,
                )
E               pytest.PytestRemovedIn8Warning: Support for nose tests is deprecated and will be removed in a future release.
E               astropy/io/fits/tests/test_table.py::TestTableFunctions::test_bin_table_with_logical_array is using nose-specific method: `setup(self)`
E               To remove this warning, rename it to `setup_method(self)`
E               See docs: https://docs.pytest.org/en/stable/deprecations.html#support-for-tests-written-for-nose

../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/python.py:898: PytestRemovedIn8Warning
_______ ERROR at setup of TestTableFunctions.test_fits_rec_column_access _______

cls = <class '_pytest.runner.CallInfo'>
func = <function call_runtest_hook.<locals>.<lambda> at 0x7d2b5645dc10>
when = 'setup'
reraise = (<class '_pytest.outcomes.Exit'>, <class 'KeyboardInterrupt'>)

    @classmethod
    def from_call(
        cls,
        func: "Callable[[], TResult]",
        when: "Literal['collect', 'setup', 'call', 'teardown']",
        reraise: Optional[
            Union[Type[BaseException], Tuple[Type[BaseException], ...]]
        ] = None,
    ) -> "CallInfo[TResult]":
        """Call func, wrapping the result in a CallInfo.
    
        :param func:
            The function to call. Called without arguments.
        :param when:
            The phase in which the function is called.
        :param reraise:
            Exception or exceptions that shall propagate if raised by the
            function, instead of being wrapped in the CallInfo.
        """
        excinfo = None
        start = timing.time()
        precise_start = timing.perf_counter()
        try:
>           result: Optional[TResult] = func()

../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/runner.py:341: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/runner.py:262: in <lambda>
    lambda: ihook(item=item, **kwds), when=when, reraise=reraise
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/pluggy/_hooks.py:493: in __call__
    return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/pluggy/_manager.py:115: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/runner.py:157: in pytest_runtest_setup
    item.session._setupstate.setup(item)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/runner.py:497: in setup
    raise exc
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/runner.py:494: in setup
    col.setup()
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/python.py:1791: in setup
    self._request._fillfixtures()
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/fixtures.py:566: in _fillfixtures
    item.funcargs[argname] = self.getfixturevalue(argname)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/fixtures.py:585: in getfixturevalue
    fixturedef = self._get_active_fixturedef(argname)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/fixtures.py:607: in _get_active_fixturedef
    self._compute_fixture_value(fixturedef)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/fixtures.py:693: in _compute_fixture_value
    fixturedef.execute(request=subrequest)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/fixtures.py:1069: in execute
    result = ihook.pytest_fixture_setup(fixturedef=self, request=request)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/pluggy/_hooks.py:493: in __call__
    return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/pluggy/_manager.py:115: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/fixtures.py:1123: in pytest_fixture_setup
    result = call_fixture_func(fixturefunc, request, kwargs)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/fixtures.py:895: in call_fixture_func
    fixture_result = next(generator)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <astropy.io.fits.tests.test_table.TestTableFunctions object at 0x7d2b570eaa30>
request = <SubRequest '_xunit_setup_method_fixture_TestTableFunctions' for <Function test_fits_rec_column_access>>

    @fixtures.fixture(
        autouse=True,
        scope="function",
        # Use a unique name to speed up lookup.
        name=f"_xunit_setup_method_fixture_{self.obj.__qualname__}",
    )
    def xunit_setup_method_fixture(self, request) -> Generator[None, None, None]:
        method = request.function
        if setup_method is not None:
            func = getattr(self, setup_name)
            _call_with_optional_argument(func, method)
            if emit_nose_setup_warning:
>               warnings.warn(
                    NOSE_SUPPORT_METHOD.format(
                        nodeid=request.node.nodeid, method="setup"
                    ),
                    stacklevel=2,
                )
E               pytest.PytestRemovedIn8Warning: Support for nose tests is deprecated and will be removed in a future release.
E               astropy/io/fits/tests/test_table.py::TestTableFunctions::test_fits_rec_column_access is using nose-specific method: `setup(self)`
E               To remove this warning, rename it to `setup_method(self)`
E               See docs: https://docs.pytest.org/en/stable/deprecations.html#support-for-tests-written-for-nose

../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/python.py:898: PytestRemovedIn8Warning
____ ERROR at setup of TestTableFunctions.test_table_with_zero_width_column ____

cls = <class '_pytest.runner.CallInfo'>
func = <function call_runtest_hook.<locals>.<lambda> at 0x7d2b56452550>
when = 'setup'
reraise = (<class '_pytest.outcomes.Exit'>, <class 'KeyboardInterrupt'>)

    @classmethod
    def from_call(
        cls,
        func: "Callable[[], TResult]",
        when: "Literal['collect', 'setup', 'call', 'teardown']",
        reraise: Optional[
            Union[Type[BaseException], Tuple[Type[BaseException], ...]]
        ] = None,
    ) -> "CallInfo[TResult]":
        """Call func, wrapping the result in a CallInfo.
    
        :param func:
            The function to call. Called without arguments.
        :param when:
            The phase in which the function is called.
        :param reraise:
            Exception or exceptions that shall propagate if raised by the
            function, instead of being wrapped in the CallInfo.
        """
        excinfo = None
        start = timing.time()
        precise_start = timing.perf_counter()
        try:
>           result: Optional[TResult] = func()

../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/runner.py:341: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/runner.py:262: in <lambda>
    lambda: ihook(item=item, **kwds), when=when, reraise=reraise
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/pluggy/_hooks.py:493: in __call__
    return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/pluggy/_manager.py:115: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/runner.py:157: in pytest_runtest_setup
    item.session._setupstate.setup(item)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/runner.py:497: in setup
    raise exc
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/runner.py:494: in setup
    col.setup()
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/python.py:1791: in setup
    self._request._fillfixtures()
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/fixtures.py:566: in _fillfixtures
    item.funcargs[argname] = self.getfixturevalue(argname)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/fixtures.py:585: in getfixturevalue
    fixturedef = self._get_active_fixturedef(argname)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/fixtures.py:607: in _get_active_fixturedef
    self._compute_fixture_value(fixturedef)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/fixtures.py:693: in _compute_fixture_value
    fixturedef.execute(request=subrequest)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/fixtures.py:1069: in execute
    result = ihook.pytest_fixture_setup(fixturedef=self, request=request)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/pluggy/_hooks.py:493: in __call__
    return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/pluggy/_manager.py:115: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/fixtures.py:1123: in pytest_fixture_setup
    result = call_fixture_func(fixturefunc, request, kwargs)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/fixtures.py:895: in call_fixture_func
    fixture_result = next(generator)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <astropy.io.fits.tests.test_table.TestTableFunctions object at 0x7d2b570c11f0>
request = <SubRequest '_xunit_setup_method_fixture_TestTableFunctions' for <Function test_table_with_zero_width_column>>

    @fixtures.fixture(
        autouse=True,
        scope="function",
        # Use a unique name to speed up lookup.
        name=f"_xunit_setup_method_fixture_{self.obj.__qualname__}",
    )
    def xunit_setup_method_fixture(self, request) -> Generator[None, None, None]:
        method = request.function
        if setup_method is not None:
            func = getattr(self, setup_name)
            _call_with_optional_argument(func, method)
            if emit_nose_setup_warning:
>               warnings.warn(
                    NOSE_SUPPORT_METHOD.format(
                        nodeid=request.node.nodeid, method="setup"
                    ),
                    stacklevel=2,
                )
E               pytest.PytestRemovedIn8Warning: Support for nose tests is deprecated and will be removed in a future release.
E               astropy/io/fits/tests/test_table.py::TestTableFunctions::test_table_with_zero_width_column is using nose-specific method: `setup(self)`
E               To remove this warning, rename it to `setup_method(self)`
E               See docs: https://docs.pytest.org/en/stable/deprecations.html#support-for-tests-written-for-nose

../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/python.py:898: PytestRemovedIn8Warning
_______ ERROR at setup of TestTableFunctions.test_string_column_padding ________

cls = <class '_pytest.runner.CallInfo'>
func = <function call_runtest_hook.<locals>.<lambda> at 0x7d2b56ccc670>
when = 'setup'
reraise = (<class '_pytest.outcomes.Exit'>, <class 'KeyboardInterrupt'>)

    @classmethod
    def from_call(
        cls,
        func: "Callable[[], TResult]",
        when: "Literal['collect', 'setup', 'call', 'teardown']",
        reraise: Optional[
            Union[Type[BaseException], Tuple[Type[BaseException], ...]]
        ] = None,
    ) -> "CallInfo[TResult]":
        """Call func, wrapping the result in a CallInfo.
    
        :param func:
            The function to call. Called without arguments.
        :param when:
            The phase in which the function is called.
        :param reraise:
            Exception or exceptions that shall propagate if raised by the
            function, instead of being wrapped in the CallInfo.
        """
        excinfo = None
        start = timing.time()
        precise_start = timing.perf_counter()
        try:
>           result: Optional[TResult] = func()

../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/runner.py:341: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/runner.py:262: in <lambda>
    lambda: ihook(item=item, **kwds), when=when, reraise=reraise
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/pluggy/_hooks.py:493: in __call__
    return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/pluggy/_manager.py:115: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/runner.py:157: in pytest_runtest_setup
    item.session._setupstate.setup(item)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/runner.py:497: in setup
    raise exc
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/runner.py:494: in setup
    col.setup()
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/python.py:1791: in setup
    self._request._fillfixtures()
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/fixtures.py:566: in _fillfixtures
    item.funcargs[argname] = self.getfixturevalue(argname)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/fixtures.py:585: in getfixturevalue
    fixturedef = self._get_active_fixturedef(argname)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/fixtures.py:607: in _get_active_fixturedef
    self._compute_fixture_value(fixturedef)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/fixtures.py:693: in _compute_fixture_value
    fixturedef.execute(request=subrequest)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/fixtures.py:1069: in execute
    result = ihook.pytest_fixture_setup(fixturedef=self, request=request)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/pluggy/_hooks.py:493: in __call__
    return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/pluggy/_manager.py:115: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/fixtures.py:1123: in pytest_fixture_setup
    result = call_fixture_func(fixturefunc, request, kwargs)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/fixtures.py:895: in call_fixture_func
    fixture_result = next(generator)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <astropy.io.fits.tests.test_table.TestTableFunctions object at 0x7d2b570c1670>
request = <SubRequest '_xunit_setup_method_fixture_TestTableFunctions' for <Function test_string_column_padding>>

    @fixtures.fixture(
        autouse=True,
        scope="function",
        # Use a unique name to speed up lookup.
        name=f"_xunit_setup_method_fixture_{self.obj.__qualname__}",
    )
    def xunit_setup_method_fixture(self, request) -> Generator[None, None, None]:
        method = request.function
        if setup_method is not None:
            func = getattr(self, setup_name)
            _call_with_optional_argument(func, method)
            if emit_nose_setup_warning:
>               warnings.warn(
                    NOSE_SUPPORT_METHOD.format(
                        nodeid=request.node.nodeid, method="setup"
                    ),
                    stacklevel=2,
                )
E               pytest.PytestRemovedIn8Warning: Support for nose tests is deprecated and will be removed in a future release.
E               astropy/io/fits/tests/test_table.py::TestTableFunctions::test_string_column_padding is using nose-specific method: `setup(self)`
E               To remove this warning, rename it to `setup_method(self)`
E               See docs: https://docs.pytest.org/en/stable/deprecations.html#support-for-tests-written-for-nose

../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/python.py:898: PytestRemovedIn8Warning
_____ ERROR at setup of TestTableFunctions.test_multi_dimensional_columns ______

cls = <class '_pytest.runner.CallInfo'>
func = <function call_runtest_hook.<locals>.<lambda> at 0x7d2b55c73b80>
when = 'setup'
reraise = (<class '_pytest.outcomes.Exit'>, <class 'KeyboardInterrupt'>)

    @classmethod
    def from_call(
        cls,
        func: "Callable[[], TResult]",
        when: "Literal['collect', 'setup', 'call', 'teardown']",
        reraise: Optional[
            Union[Type[BaseException], Tuple[Type[BaseException], ...]]
        ] = None,
    ) -> "CallInfo[TResult]":
        """Call func, wrapping the result in a CallInfo.
    
        :param func:
            The function to call. Called without arguments.
        :param when:
            The phase in which the function is called.
        :param reraise:
            Exception or exceptions that shall propagate if raised by the
            function, instead of being wrapped in the CallInfo.
        """
        excinfo = None
        start = timing.time()
        precise_start = timing.perf_counter()
        try:
>           result: Optional[TResult] = func()

../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/runner.py:341: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/runner.py:262: in <lambda>
    lambda: ihook(item=item, **kwds), when=when, reraise=reraise
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/pluggy/_hooks.py:493: in __call__
    return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/pluggy/_manager.py:115: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/runner.py:157: in pytest_runtest_setup
    item.session._setupstate.setup(item)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/runner.py:497: in setup
    raise exc
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/runner.py:494: in setup
    col.setup()
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/python.py:1791: in setup
    self._request._fillfixtures()
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/fixtures.py:566: in _fillfixtures
    item.funcargs[argname] = self.getfixturevalue(argname)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/fixtures.py:585: in getfixturevalue
    fixturedef = self._get_active_fixturedef(argname)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/fixtures.py:607: in _get_active_fixturedef
    self._compute_fixture_value(fixturedef)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/fixtures.py:693: in _compute_fixture_value
    fixturedef.execute(request=subrequest)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/fixtures.py:1069: in execute
    result = ihook.pytest_fixture_setup(fixturedef=self, request=request)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/pluggy/_hooks.py:493: in __call__
    return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/pluggy/_manager.py:115: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/fixtures.py:1123: in pytest_fixture_setup
    result = call_fixture_func(fixturefunc, request, kwargs)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/fixtures.py:895: in call_fixture_func
    fixture_result = next(generator)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <astropy.io.fits.tests.test_table.TestTableFunctions object at 0x7d2b570befd0>
request = <SubRequest '_xunit_setup_method_fixture_TestTableFunctions' for <Function test_multi_dimensional_columns>>

    @fixtures.fixture(
        autouse=True,
        scope="function",
        # Use a unique name to speed up lookup.
        name=f"_xunit_setup_method_fixture_{self.obj.__qualname__}",
    )
    def xunit_setup_method_fixture(self, request) -> Generator[None, None, None]:
        method = request.function
        if setup_method is not None:
            func = getattr(self, setup_name)
            _call_with_optional_argument(func, method)
            if emit_nose_setup_warning:
>               warnings.warn(
                    NOSE_SUPPORT_METHOD.format(
                        nodeid=request.node.nodeid, method="setup"
                    ),
                    stacklevel=2,
                )
E               pytest.PytestRemovedIn8Warning: Support for nose tests is deprecated and will be removed in a future release.
E               astropy/io/fits/tests/test_table.py::TestTableFunctions::test_multi_dimensional_columns is using nose-specific method: `setup(self)`
E               To remove this warning, rename it to `setup_method(self)`
E               See docs: https://docs.pytest.org/en/stable/deprecations.html#support-for-tests-written-for-nose

../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/python.py:898: PytestRemovedIn8Warning
_ ERROR at setup of TestTableFunctions.test_bin_table_init_from_string_array_column _

cls = <class '_pytest.runner.CallInfo'>
func = <function call_runtest_hook.<locals>.<lambda> at 0x7d2b56cc7ca0>
when = 'setup'
reraise = (<class '_pytest.outcomes.Exit'>, <class 'KeyboardInterrupt'>)

    @classmethod
    def from_call(
        cls,
        func: "Callable[[], TResult]",
        when: "Literal['collect', 'setup', 'call', 'teardown']",
        reraise: Optional[
            Union[Type[BaseException], Tuple[Type[BaseException], ...]]
        ] = None,
    ) -> "CallInfo[TResult]":
        """Call func, wrapping the result in a CallInfo.
    
        :param func:
            The function to call. Called without arguments.
        :param when:
            The phase in which the function is called.
        :param reraise:
            Exception or exceptions that shall propagate if raised by the
            function, instead of being wrapped in the CallInfo.
        """
        excinfo = None
        start = timing.time()
        precise_start = timing.perf_counter()
        try:
>           result: Optional[TResult] = func()

../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/runner.py:341: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/runner.py:262: in <lambda>
    lambda: ihook(item=item, **kwds), when=when, reraise=reraise
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/pluggy/_hooks.py:493: in __call__
    return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/pluggy/_manager.py:115: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/runner.py:157: in pytest_runtest_setup
    item.session._setupstate.setup(item)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/runner.py:497: in setup
    raise exc
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/runner.py:494: in setup
    col.setup()
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/python.py:1791: in setup
    self._request._fillfixtures()
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/fixtures.py:566: in _fillfixtures
    item.funcargs[argname] = self.getfixturevalue(argname)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/fixtures.py:585: in getfixturevalue
    fixturedef = self._get_active_fixturedef(argname)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/fixtures.py:607: in _get_active_fixturedef
    self._compute_fixture_value(fixturedef)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/fixtures.py:693: in _compute_fixture_value
    fixturedef.execute(request=subrequest)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/fixtures.py:1069: in execute
    result = ihook.pytest_fixture_setup(fixturedef=self, request=request)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/pluggy/_hooks.py:493: in __call__
    return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/pluggy/_manager.py:115: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/fixtures.py:1123: in pytest_fixture_setup
    result = call_fixture_func(fixturefunc, request, kwargs)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/fixtures.py:895: in call_fixture_func
    fixture_result = next(generator)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <astropy.io.fits.tests.test_table.TestTableFunctions object at 0x7d2b5749baf0>
request = <SubRequest '_xunit_setup_method_fixture_TestTableFunctions' for <Function test_bin_table_init_from_string_array_column>>

    @fixtures.fixture(
        autouse=True,
        scope="function",
        # Use a unique name to speed up lookup.
        name=f"_xunit_setup_method_fixture_{self.obj.__qualname__}",
    )
    def xunit_setup_method_fixture(self, request) -> Generator[None, None, None]:
        method = request.function
        if setup_method is not None:
            func = getattr(self, setup_name)
            _call_with_optional_argument(func, method)
            if emit_nose_setup_warning:
>               warnings.warn(
                    NOSE_SUPPORT_METHOD.format(
                        nodeid=request.node.nodeid, method="setup"
                    ),
                    stacklevel=2,
                )
E               pytest.PytestRemovedIn8Warning: Support for nose tests is deprecated and will be removed in a future release.
E               astropy/io/fits/tests/test_table.py::TestTableFunctions::test_bin_table_init_from_string_array_column is using nose-specific method: `setup(self)`
E               To remove this warning, rename it to `setup_method(self)`
E               See docs: https://docs.pytest.org/en/stable/deprecations.html#support-for-tests-written-for-nose

../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/python.py:898: PytestRemovedIn8Warning
____ ERROR at setup of TestTableFunctions.test_columns_with_truncating_tdim ____

cls = <class '_pytest.runner.CallInfo'>
func = <function call_runtest_hook.<locals>.<lambda> at 0x7d2b55bbad30>
when = 'setup'
reraise = (<class '_pytest.outcomes.Exit'>, <class 'KeyboardInterrupt'>)

    @classmethod
    def from_call(
        cls,
        func: "Callable[[], TResult]",
        when: "Literal['collect', 'setup', 'call', 'teardown']",
        reraise: Optional[
            Union[Type[BaseException], Tuple[Type[BaseException], ...]]
        ] = None,
    ) -> "CallInfo[TResult]":
        """Call func, wrapping the result in a CallInfo.
    
        :param func:
            The function to call. Called without arguments.
        :param when:
            The phase in which the function is called.
        :param reraise:
            Exception or exceptions that shall propagate if raised by the
            function, instead of being wrapped in the CallInfo.
        """
        excinfo = None
        start = timing.time()
        precise_start = timing.perf_counter()
        try:
>           result: Optional[TResult] = func()

../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/runner.py:341: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/runner.py:262: in <lambda>
    lambda: ihook(item=item, **kwds), when=when, reraise=reraise
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/pluggy/_hooks.py:493: in __call__
    return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/pluggy/_manager.py:115: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/runner.py:157: in pytest_runtest_setup
    item.session._setupstate.setup(item)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/runner.py:497: in setup
    raise exc
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/runner.py:494: in setup
    col.setup()
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/python.py:1791: in setup
    self._request._fillfixtures()
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/fixtures.py:566: in _fillfixtures
    item.funcargs[argname] = self.getfixturevalue(argname)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/fixtures.py:585: in getfixturevalue
    fixturedef = self._get_active_fixturedef(argname)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/fixtures.py:607: in _get_active_fixturedef
    self._compute_fixture_value(fixturedef)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/fixtures.py:693: in _compute_fixture_value
    fixturedef.execute(request=subrequest)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/fixtures.py:1069: in execute
    result = ihook.pytest_fixture_setup(fixturedef=self, request=request)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/pluggy/_hooks.py:493: in __call__
    return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/pluggy/_manager.py:115: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/fixtures.py:1123: in pytest_fixture_setup
    result = call_fixture_func(fixturefunc, request, kwargs)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/fixtures.py:895: in call_fixture_func
    fixture_result = next(generator)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <astropy.io.fits.tests.test_table.TestTableFunctions object at 0x7d2b570ea910>
request = <SubRequest '_xunit_setup_method_fixture_TestTableFunctions' for <Function test_columns_with_truncating_tdim>>

    @fixtures.fixture(
        autouse=True,
        scope="function",
        # Use a unique name to speed up lookup.
        name=f"_xunit_setup_method_fixture_{self.obj.__qualname__}",
    )
    def xunit_setup_method_fixture(self, request) -> Generator[None, None, None]:
        method = request.function
        if setup_method is not None:
            func = getattr(self, setup_name)
            _call_with_optional_argument(func, method)
            if emit_nose_setup_warning:
>               warnings.warn(
                    NOSE_SUPPORT_METHOD.format(
                        nodeid=request.node.nodeid, method="setup"
                    ),
                    stacklevel=2,
                )
E               pytest.PytestRemovedIn8Warning: Support for nose tests is deprecated and will be removed in a future release.
E               astropy/io/fits/tests/test_table.py::TestTableFunctions::test_columns_with_truncating_tdim is using nose-specific method: `setup(self)`
E               To remove this warning, rename it to `setup_method(self)`
E               See docs: https://docs.pytest.org/en/stable/deprecations.html#support-for-tests-written-for-nose

../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/python.py:898: PytestRemovedIn8Warning
______ ERROR at setup of TestTableFunctions.test_string_array_round_trip _______

cls = <class '_pytest.runner.CallInfo'>
func = <function call_runtest_hook.<locals>.<lambda> at 0x7d2b56cc78b0>
when = 'setup'
reraise = (<class '_pytest.outcomes.Exit'>, <class 'KeyboardInterrupt'>)

    @classmethod
    def from_call(
        cls,
        func: "Callable[[], TResult]",
        when: "Literal['collect', 'setup', 'call', 'teardown']",
        reraise: Optional[
            Union[Type[BaseException], Tuple[Type[BaseException], ...]]
        ] = None,
    ) -> "CallInfo[TResult]":
        """Call func, wrapping the result in a CallInfo.
    
        :param func:
            The function to call. Called without arguments.
        :param when:
            The phase in which the function is called.
        :param reraise:
            Exception or exceptions that shall propagate if raised by the
            function, instead of being wrapped in the CallInfo.
        """
        excinfo = None
        start = timing.time()
        precise_start = timing.perf_counter()
        try:
>           result: Optional[TResult] = func()

../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/runner.py:341: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/runner.py:262: in <lambda>
    lambda: ihook(item=item, **kwds), when=when, reraise=reraise
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/pluggy/_hooks.py:493: in __call__
    return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/pluggy/_manager.py:115: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/runner.py:157: in pytest_runtest_setup
    item.session._setupstate.setup(item)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/runner.py:497: in setup
    raise exc
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/runner.py:494: in setup
    col.setup()
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/python.py:1791: in setup
    self._request._fillfixtures()
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/fixtures.py:566: in _fillfixtures
    item.funcargs[argname] = self.getfixturevalue(argname)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/fixtures.py:585: in getfixturevalue
    fixturedef = self._get_active_fixturedef(argname)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/fixtures.py:607: in _get_active_fixturedef
    self._compute_fixture_value(fixturedef)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/fixtures.py:693: in _compute_fixture_value
    fixturedef.execute(request=subrequest)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/fixtures.py:1069: in execute
    result = ihook.pytest_fixture_setup(fixturedef=self, request=request)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/pluggy/_hooks.py:493: in __call__
    return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/pluggy/_manager.py:115: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/fixtures.py:1123: in pytest_fixture_setup
    result = call_fixture_func(fixturefunc, request, kwargs)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/fixtures.py:895: in call_fixture_func
    fixture_result = next(generator)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <astropy.io.fits.tests.test_table.TestTableFunctions object at 0x7d2b570ea340>
request = <SubRequest '_xunit_setup_method_fixture_TestTableFunctions' for <Function test_string_array_round_trip>>

    @fixtures.fixture(
        autouse=True,
        scope="function",
        # Use a unique name to speed up lookup.
        name=f"_xunit_setup_method_fixture_{self.obj.__qualname__}",
    )
    def xunit_setup_method_fixture(self, request) -> Generator[None, None, None]:
        method = request.function
        if setup_method is not None:
            func = getattr(self, setup_name)
            _call_with_optional_argument(func, method)
            if emit_nose_setup_warning:
>               warnings.warn(
                    NOSE_SUPPORT_METHOD.format(
                        nodeid=request.node.nodeid, method="setup"
                    ),
                    stacklevel=2,
                )
E               pytest.PytestRemovedIn8Warning: Support for nose tests is deprecated and will be removed in a future release.
E               astropy/io/fits/tests/test_table.py::TestTableFunctions::test_string_array_round_trip is using nose-specific method: `setup(self)`
E               To remove this warning, rename it to `setup_method(self)`
E               See docs: https://docs.pytest.org/en/stable/deprecations.html#support-for-tests-written-for-nose

../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/python.py:898: PytestRemovedIn8Warning
______ ERROR at setup of TestTableFunctions.test_new_table_with_nd_column ______

cls = <class '_pytest.runner.CallInfo'>
func = <function call_runtest_hook.<locals>.<lambda> at 0x7d2b55c73af0>
when = 'setup'
reraise = (<class '_pytest.outcomes.Exit'>, <class 'KeyboardInterrupt'>)

    @classmethod
    def from_call(
        cls,
        func: "Callable[[], TResult]",
        when: "Literal['collect', 'setup', 'call', 'teardown']",
        reraise: Optional[
            Union[Type[BaseException], Tuple[Type[BaseException], ...]]
        ] = None,
    ) -> "CallInfo[TResult]":
        """Call func, wrapping the result in a CallInfo.
    
        :param func:
            The function to call. Called without arguments.
        :param when:
            The phase in which the function is called.
        :param reraise:
            Exception or exceptions that shall propagate if raised by the
            function, instead of being wrapped in the CallInfo.
        """
        excinfo = None
        start = timing.time()
        precise_start = timing.perf_counter()
        try:
>           result: Optional[TResult] = func()

../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/runner.py:341: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/runner.py:262: in <lambda>
    lambda: ihook(item=item, **kwds), when=when, reraise=reraise
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/pluggy/_hooks.py:493: in __call__
    return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/pluggy/_manager.py:115: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/runner.py:157: in pytest_runtest_setup
    item.session._setupstate.setup(item)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/runner.py:497: in setup
    raise exc
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/runner.py:494: in setup
    col.setup()
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/python.py:1791: in setup
    self._request._fillfixtures()
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/fixtures.py:566: in _fillfixtures
    item.funcargs[argname] = self.getfixturevalue(argname)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/fixtures.py:585: in getfixturevalue
    fixturedef = self._get_active_fixturedef(argname)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/fixtures.py:607: in _get_active_fixturedef
    self._compute_fixture_value(fixturedef)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/fixtures.py:693: in _compute_fixture_value
    fixturedef.execute(request=subrequest)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/fixtures.py:1069: in execute
    result = ihook.pytest_fixture_setup(fixturedef=self, request=request)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/pluggy/_hooks.py:493: in __call__
    return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/pluggy/_manager.py:115: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/fixtures.py:1123: in pytest_fixture_setup
    result = call_fixture_func(fixturefunc, request, kwargs)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/fixtures.py:895: in call_fixture_func
    fixture_result = next(generator)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <astropy.io.fits.tests.test_table.TestTableFunctions object at 0x7d2b570ea130>
request = <SubRequest '_xunit_setup_method_fixture_TestTableFunctions' for <Function test_new_table_with_nd_column>>

    @fixtures.fixture(
        autouse=True,
        scope="function",
        # Use a unique name to speed up lookup.
        name=f"_xunit_setup_method_fixture_{self.obj.__qualname__}",
    )
    def xunit_setup_method_fixture(self, request) -> Generator[None, None, None]:
        method = request.function
        if setup_method is not None:
            func = getattr(self, setup_name)
            _call_with_optional_argument(func, method)
            if emit_nose_setup_warning:
>               warnings.warn(
                    NOSE_SUPPORT_METHOD.format(
                        nodeid=request.node.nodeid, method="setup"
                    ),
                    stacklevel=2,
                )
E               pytest.PytestRemovedIn8Warning: Support for nose tests is deprecated and will be removed in a future release.
E               astropy/io/fits/tests/test_table.py::TestTableFunctions::test_new_table_with_nd_column is using nose-specific method: `setup(self)`
E               To remove this warning, rename it to `setup_method(self)`
E               See docs: https://docs.pytest.org/en/stable/deprecations.html#support-for-tests-written-for-nose

../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/python.py:898: PytestRemovedIn8Warning
_____ ERROR at setup of TestTableFunctions.test_mismatched_tform_and_tdim ______

cls = <class '_pytest.runner.CallInfo'>
func = <function call_runtest_hook.<locals>.<lambda> at 0x7d2b56cccca0>
when = 'setup'
reraise = (<class '_pytest.outcomes.Exit'>, <class 'KeyboardInterrupt'>)

    @classmethod
    def from_call(
        cls,
        func: "Callable[[], TResult]",
        when: "Literal['collect', 'setup', 'call', 'teardown']",
        reraise: Optional[
            Union[Type[BaseException], Tuple[Type[BaseException], ...]]
        ] = None,
    ) -> "CallInfo[TResult]":
        """Call func, wrapping the result in a CallInfo.
    
        :param func:
            The function to call. Called without arguments.
        :param when:
            The phase in which the function is called.
        :param reraise:
            Exception or exceptions that shall propagate if raised by the
            function, instead of being wrapped in the CallInfo.
        """
        excinfo = None
        start = timing.time()
        precise_start = timing.perf_counter()
        try:
>           result: Optional[TResult] = func()

../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/runner.py:341: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/runner.py:262: in <lambda>
    lambda: ihook(item=item, **kwds), when=when, reraise=reraise
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/pluggy/_hooks.py:493: in __call__
    return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/pluggy/_manager.py:115: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/runner.py:157: in pytest_runtest_setup
    item.session._setupstate.setup(item)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/runner.py:497: in setup
    raise exc
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/runner.py:494: in setup
    col.setup()
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/python.py:1791: in setup
    self._request._fillfixtures()
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/fixtures.py:566: in _fillfixtures
    item.funcargs[argname] = self.getfixturevalue(argname)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/fixtures.py:585: in getfixturevalue
    fixturedef = self._get_active_fixturedef(argname)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/fixtures.py:607: in _get_active_fixturedef
    self._compute_fixture_value(fixturedef)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/fixtures.py:693: in _compute_fixture_value
    fixturedef.execute(request=subrequest)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/fixtures.py:1069: in execute
    result = ihook.pytest_fixture_setup(fixturedef=self, request=request)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/pluggy/_hooks.py:493: in __call__
    return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/pluggy/_manager.py:115: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/fixtures.py:1123: in pytest_fixture_setup
    result = call_fixture_func(fixturefunc, request, kwargs)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/fixtures.py:895: in call_fixture_func
    fixture_result = next(generator)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <astropy.io.fits.tests.test_table.TestTableFunctions object at 0x7d2b570e7cd0>
request = <SubRequest '_xunit_setup_method_fixture_TestTableFunctions' for <Function test_mismatched_tform_and_tdim>>

    @fixtures.fixture(
        autouse=True,
        scope="function",
        # Use a unique name to speed up lookup.
        name=f"_xunit_setup_method_fixture_{self.obj.__qualname__}",
    )
    def xunit_setup_method_fixture(self, request) -> Generator[None, None, None]:
        method = request.function
        if setup_method is not None:
            func = getattr(self, setup_name)
            _call_with_optional_argument(func, method)
            if emit_nose_setup_warning:
>               warnings.warn(
                    NOSE_SUPPORT_METHOD.format(
                        nodeid=request.node.nodeid, method="setup"
                    ),
                    stacklevel=2,
                )
E               pytest.PytestRemovedIn8Warning: Support for nose tests is deprecated and will be removed in a future release.
E               astropy/io/fits/tests/test_table.py::TestTableFunctions::test_mismatched_tform_and_tdim is using nose-specific method: `setup(self)`
E               To remove this warning, rename it to `setup_method(self)`
E               See docs: https://docs.pytest.org/en/stable/deprecations.html#support-for-tests-written-for-nose

../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/python.py:898: PytestRemovedIn8Warning
__________ ERROR at setup of TestTableFunctions.test_tdim_of_size_one __________

cls = <class '_pytest.runner.CallInfo'>
func = <function call_runtest_hook.<locals>.<lambda> at 0x7d2b56b401f0>
when = 'setup'
reraise = (<class '_pytest.outcomes.Exit'>, <class 'KeyboardInterrupt'>)

    @classmethod
    def from_call(
        cls,
        func: "Callable[[], TResult]",
        when: "Literal['collect', 'setup', 'call', 'teardown']",
        reraise: Optional[
            Union[Type[BaseException], Tuple[Type[BaseException], ...]]
        ] = None,
    ) -> "CallInfo[TResult]":
        """Call func, wrapping the result in a CallInfo.
    
        :param func:
            The function to call. Called without arguments.
        :param when:
            The phase in which the function is called.
        :param reraise:
            Exception or exceptions that shall propagate if raised by the
            function, instead of being wrapped in the CallInfo.
        """
        excinfo = None
        start = timing.time()
        precise_start = timing.perf_counter()
        try:
>           result: Optional[TResult] = func()

../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/runner.py:341: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/runner.py:262: in <lambda>
    lambda: ihook(item=item, **kwds), when=when, reraise=reraise
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/pluggy/_hooks.py:493: in __call__
    return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/pluggy/_manager.py:115: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/runner.py:157: in pytest_runtest_setup
    item.session._setupstate.setup(item)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/runner.py:497: in setup
    raise exc
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/runner.py:494: in setup
    col.setup()
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/python.py:1791: in setup
    self._request._fillfixtures()
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/fixtures.py:566: in _fillfixtures
    item.funcargs[argname] = self.getfixturevalue(argname)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/fixtures.py:585: in getfixturevalue
    fixturedef = self._get_active_fixturedef(argname)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/fixtures.py:607: in _get_active_fixturedef
    self._compute_fixture_value(fixturedef)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/fixtures.py:693: in _compute_fixture_value
    fixturedef.execute(request=subrequest)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/fixtures.py:1069: in execute
    result = ihook.pytest_fixture_setup(fixturedef=self, request=request)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/pluggy/_hooks.py:493: in __call__
    return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/pluggy/_manager.py:115: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/fixtures.py:1123: in pytest_fixture_setup
    result = call_fixture_func(fixturefunc, request, kwargs)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/fixtures.py:895: in call_fixture_func
    fixture_result = next(generator)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <astropy.io.fits.tests.test_table.TestTableFunctions object at 0x7d2b570e7b20>
request = <SubRequest '_xunit_setup_method_fixture_TestTableFunctions' for <Function test_tdim_of_size_one>>

    @fixtures.fixture(
        autouse=True,
        scope="function",
        # Use a unique name to speed up lookup.
        name=f"_xunit_setup_method_fixture_{self.obj.__qualname__}",
    )
    def xunit_setup_method_fixture(self, request) -> Generator[None, None, None]:
        method = request.function
        if setup_method is not None:
            func = getattr(self, setup_name)
            _call_with_optional_argument(func, method)
            if emit_nose_setup_warning:
>               warnings.warn(
                    NOSE_SUPPORT_METHOD.format(
                        nodeid=request.node.nodeid, method="setup"
                    ),
                    stacklevel=2,
                )
E               pytest.PytestRemovedIn8Warning: Support for nose tests is deprecated and will be removed in a future release.
E               astropy/io/fits/tests/test_table.py::TestTableFunctions::test_tdim_of_size_one is using nose-specific method: `setup(self)`
E               To remove this warning, rename it to `setup_method(self)`
E               See docs: https://docs.pytest.org/en/stable/deprecations.html#support-for-tests-written-for-nose

../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/python.py:898: PytestRemovedIn8Warning
______________ ERROR at setup of TestTableFunctions.test_slicing _______________

cls = <class '_pytest.runner.CallInfo'>
func = <function call_runtest_hook.<locals>.<lambda> at 0x7d2b568fadc0>
when = 'setup'
reraise = (<class '_pytest.outcomes.Exit'>, <class 'KeyboardInterrupt'>)

    @classmethod
    def from_call(
        cls,
        func: "Callable[[], TResult]",
        when: "Literal['collect', 'setup', 'call', 'teardown']",
        reraise: Optional[
            Union[Type[BaseException], Tuple[Type[BaseException], ...]]
        ] = None,
    ) -> "CallInfo[TResult]":
        """Call func, wrapping the result in a CallInfo.
    
        :param func:
            The function to call. Called without arguments.
        :param when:
            The phase in which the function is called.
        :param reraise:
            Exception or exceptions that shall propagate if raised by the
            function, instead of being wrapped in the CallInfo.
        """
        excinfo = None
        start = timing.time()
        precise_start = timing.perf_counter()
        try:
>           result: Optional[TResult] = func()

../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/runner.py:341: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/runner.py:262: in <lambda>
    lambda: ihook(item=item, **kwds), when=when, reraise=reraise
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/pluggy/_hooks.py:493: in __call__
    return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/pluggy/_manager.py:115: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/runner.py:157: in pytest_runtest_setup
    item.session._setupstate.setup(item)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/runner.py:497: in setup
    raise exc
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/runner.py:494: in setup
    col.setup()
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/python.py:1791: in setup
    self._request._fillfixtures()
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/fixtures.py:566: in _fillfixtures
    item.funcargs[argname] = self.getfixturevalue(argname)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/fixtures.py:585: in getfixturevalue
    fixturedef = self._get_active_fixturedef(argname)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/fixtures.py:607: in _get_active_fixturedef
    self._compute_fixture_value(fixturedef)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/fixtures.py:693: in _compute_fixture_value
    fixturedef.execute(request=subrequest)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/fixtures.py:1069: in execute
    result = ihook.pytest_fixture_setup(fixturedef=self, request=request)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/pluggy/_hooks.py:493: in __call__
    return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/pluggy/_manager.py:115: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/fixtures.py:1123: in pytest_fixture_setup
    result = call_fixture_func(fixturefunc, request, kwargs)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/fixtures.py:895: in call_fixture_func
    fixture_result = next(generator)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <astropy.io.fits.tests.test_table.TestTableFunctions object at 0x7d2b570e7c70>
request = <SubRequest '_xunit_setup_method_fixture_TestTableFunctions' for <Function test_slicing>>

    @fixtures.fixture(
        autouse=True,
        scope="function",
        # Use a unique name to speed up lookup.
        name=f"_xunit_setup_method_fixture_{self.obj.__qualname__}",
    )
    def xunit_setup_method_fixture(self, request) -> Generator[None, None, None]:
        method = request.function
        if setup_method is not None:
            func = getattr(self, setup_name)
            _call_with_optional_argument(func, method)
            if emit_nose_setup_warning:
>               warnings.warn(
                    NOSE_SUPPORT_METHOD.format(
                        nodeid=request.node.nodeid, method="setup"
                    ),
                    stacklevel=2,
                )
E               pytest.PytestRemovedIn8Warning: Support for nose tests is deprecated and will be removed in a future release.
E               astropy/io/fits/tests/test_table.py::TestTableFunctions::test_slicing is using nose-specific method: `setup(self)`
E               To remove this warning, rename it to `setup_method(self)`
E               See docs: https://docs.pytest.org/en/stable/deprecations.html#support-for-tests-written-for-nose

../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/python.py:898: PytestRemovedIn8Warning
___________ ERROR at setup of TestTableFunctions.test_array_slicing ____________

cls = <class '_pytest.runner.CallInfo'>
func = <function call_runtest_hook.<locals>.<lambda> at 0x7d2b55c73a60>
when = 'setup'
reraise = (<class '_pytest.outcomes.Exit'>, <class 'KeyboardInterrupt'>)

    @classmethod
    def from_call(
        cls,
        func: "Callable[[], TResult]",
        when: "Literal['collect', 'setup', 'call', 'teardown']",
        reraise: Optional[
            Union[Type[BaseException], Tuple[Type[BaseException], ...]]
        ] = None,
    ) -> "CallInfo[TResult]":
        """Call func, wrapping the result in a CallInfo.
    
        :param func:
            The function to call. Called without arguments.
        :param when:
            The phase in which the function is called.
        :param reraise:
            Exception or exceptions that shall propagate if raised by the
            function, instead of being wrapped in the CallInfo.
        """
        excinfo = None
        start = timing.time()
        precise_start = timing.perf_counter()
        try:
>           result: Optional[TResult] = func()

../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/runner.py:341: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/runner.py:262: in <lambda>
    lambda: ihook(item=item, **kwds), when=when, reraise=reraise
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/pluggy/_hooks.py:493: in __call__
    return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/pluggy/_manager.py:115: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/runner.py:157: in pytest_runtest_setup
    item.session._setupstate.setup(item)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/runner.py:497: in setup
    raise exc
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/runner.py:494: in setup
    col.setup()
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/python.py:1791: in setup
    self._request._fillfixtures()
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/fixtures.py:566: in _fillfixtures
    item.funcargs[argname] = self.getfixturevalue(argname)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/fixtures.py:585: in getfixturevalue
    fixturedef = self._get_active_fixturedef(argname)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/fixtures.py:607: in _get_active_fixturedef
    self._compute_fixture_value(fixturedef)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/fixtures.py:693: in _compute_fixture_value
    fixturedef.execute(request=subrequest)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/fixtures.py:1069: in execute
    result = ihook.pytest_fixture_setup(fixturedef=self, request=request)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/pluggy/_hooks.py:493: in __call__
    return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/pluggy/_manager.py:115: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/fixtures.py:1123: in pytest_fixture_setup
    result = call_fixture_func(fixturefunc, request, kwargs)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/fixtures.py:895: in call_fixture_func
    fixture_result = next(generator)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <astropy.io.fits.tests.test_table.TestTableFunctions object at 0x7d2b570e7640>
request = <SubRequest '_xunit_setup_method_fixture_TestTableFunctions' for <Function test_array_slicing>>

    @fixtures.fixture(
        autouse=True,
        scope="function",
        # Use a unique name to speed up lookup.
        name=f"_xunit_setup_method_fixture_{self.obj.__qualname__}",
    )
    def xunit_setup_method_fixture(self, request) -> Generator[None, None, None]:
        method = request.function
        if setup_method is not None:
            func = getattr(self, setup_name)
            _call_with_optional_argument(func, method)
            if emit_nose_setup_warning:
>               warnings.warn(
                    NOSE_SUPPORT_METHOD.format(
                        nodeid=request.node.nodeid, method="setup"
                    ),
                    stacklevel=2,
                )
E               pytest.PytestRemovedIn8Warning: Support for nose tests is deprecated and will be removed in a future release.
E               astropy/io/fits/tests/test_table.py::TestTableFunctions::test_array_slicing is using nose-specific method: `setup(self)`
E               To remove this warning, rename it to `setup_method(self)`
E               See docs: https://docs.pytest.org/en/stable/deprecations.html#support-for-tests-written-for-nose

../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/python.py:898: PytestRemovedIn8Warning
_________ ERROR at setup of TestTableFunctions.test_array_broadcasting _________

cls = <class '_pytest.runner.CallInfo'>
func = <function call_runtest_hook.<locals>.<lambda> at 0x7d2b55bbaf70>
when = 'setup'
reraise = (<class '_pytest.outcomes.Exit'>, <class 'KeyboardInterrupt'>)

    @classmethod
    def from_call(
        cls,
        func: "Callable[[], TResult]",
        when: "Literal['collect', 'setup', 'call', 'teardown']",
        reraise: Optional[
            Union[Type[BaseException], Tuple[Type[BaseException], ...]]
        ] = None,
    ) -> "CallInfo[TResult]":
        """Call func, wrapping the result in a CallInfo.
    
        :param func:
            The function to call. Called without arguments.
        :param when:
            The phase in which the function is called.
        :param reraise:
            Exception or exceptions that shall propagate if raised by the
            function, instead of being wrapped in the CallInfo.
        """
        excinfo = None
        start = timing.time()
        precise_start = timing.perf_counter()
        try:
>           result: Optional[TResult] = func()

../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/runner.py:341: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/runner.py:262: in <lambda>
    lambda: ihook(item=item, **kwds), when=when, reraise=reraise
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/pluggy/_hooks.py:493: in __call__
    return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/pluggy/_manager.py:115: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/runner.py:157: in pytest_runtest_setup
    item.session._setupstate.setup(item)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/runner.py:497: in setup
    raise exc
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/runner.py:494: in setup
    col.setup()
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/python.py:1791: in setup
    self._request._fillfixtures()
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/fixtures.py:566: in _fillfixtures
    item.funcargs[argname] = self.getfixturevalue(argname)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/fixtures.py:585: in getfixturevalue
    fixturedef = self._get_active_fixturedef(argname)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/fixtures.py:607: in _get_active_fixturedef
    self._compute_fixture_value(fixturedef)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/fixtures.py:693: in _compute_fixture_value
    fixturedef.execute(request=subrequest)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/fixtures.py:1069: in execute
    result = ihook.pytest_fixture_setup(fixturedef=self, request=request)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/pluggy/_hooks.py:493: in __call__
    return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/pluggy/_manager.py:115: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/fixtures.py:1123: in pytest_fixture_setup
    result = call_fixture_func(fixturefunc, request, kwargs)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/fixtures.py:895: in call_fixture_func
    fixture_result = next(generator)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <astropy.io.fits.tests.test_table.TestTableFunctions object at 0x7d2b570e73a0>
request = <SubRequest '_xunit_setup_method_fixture_TestTableFunctions' for <Function test_array_broadcasting>>

    @fixtures.fixture(
        autouse=True,
        scope="function",
        # Use a unique name to speed up lookup.
        name=f"_xunit_setup_method_fixture_{self.obj.__qualname__}",
    )
    def xunit_setup_method_fixture(self, request) -> Generator[None, None, None]:
        method = request.function
        if setup_method is not None:
            func = getattr(self, setup_name)
            _call_with_optional_argument(func, method)
            if emit_nose_setup_warning:
>               warnings.warn(
                    NOSE_SUPPORT_METHOD.format(
                        nodeid=request.node.nodeid, method="setup"
                    ),
                    stacklevel=2,
                )
E               pytest.PytestRemovedIn8Warning: Support for nose tests is deprecated and will be removed in a future release.
E               astropy/io/fits/tests/test_table.py::TestTableFunctions::test_array_broadcasting is using nose-specific method: `setup(self)`
E               To remove this warning, rename it to `setup_method(self)`
E               See docs: https://docs.pytest.org/en/stable/deprecations.html#support-for-tests-written-for-nose

../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/python.py:898: PytestRemovedIn8Warning
_______ ERROR at setup of TestTableFunctions.test_array_slicing_readonly _______

cls = <class '_pytest.runner.CallInfo'>
func = <function call_runtest_hook.<locals>.<lambda> at 0x7d2b55c73a60>
when = 'setup'
reraise = (<class '_pytest.outcomes.Exit'>, <class 'KeyboardInterrupt'>)

    @classmethod
    def from_call(
        cls,
        func: "Callable[[], TResult]",
        when: "Literal['collect', 'setup', 'call', 'teardown']",
        reraise: Optional[
            Union[Type[BaseException], Tuple[Type[BaseException], ...]]
        ] = None,
    ) -> "CallInfo[TResult]":
        """Call func, wrapping the result in a CallInfo.
    
        :param func:
            The function to call. Called without arguments.
        :param when:
            The phase in which the function is called.
        :param reraise:
            Exception or exceptions that shall propagate if raised by the
            function, instead of being wrapped in the CallInfo.
        """
        excinfo = None
        start = timing.time()
        precise_start = timing.perf_counter()
        try:
>           result: Optional[TResult] = func()

../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/runner.py:341: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/runner.py:262: in <lambda>
    lambda: ihook(item=item, **kwds), when=when, reraise=reraise
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/pluggy/_hooks.py:493: in __call__
    return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/pluggy/_manager.py:115: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/runner.py:157: in pytest_runtest_setup
    item.session._setupstate.setup(item)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/runner.py:497: in setup
    raise exc
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/runner.py:494: in setup
    col.setup()
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/python.py:1791: in setup
    self._request._fillfixtures()
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/fixtures.py:566: in _fillfixtures
    item.funcargs[argname] = self.getfixturevalue(argname)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/fixtures.py:585: in getfixturevalue
    fixturedef = self._get_active_fixturedef(argname)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/fixtures.py:607: in _get_active_fixturedef
    self._compute_fixture_value(fixturedef)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/fixtures.py:693: in _compute_fixture_value
    fixturedef.execute(request=subrequest)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/fixtures.py:1069: in execute
    result = ihook.pytest_fixture_setup(fixturedef=self, request=request)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/pluggy/_hooks.py:493: in __call__
    return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/pluggy/_manager.py:115: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/fixtures.py:1123: in pytest_fixture_setup
    result = call_fixture_func(fixturefunc, request, kwargs)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/fixtures.py:895: in call_fixture_func
    fixture_result = next(generator)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <astropy.io.fits.tests.test_table.TestTableFunctions object at 0x7d2b570e7100>
request = <SubRequest '_xunit_setup_method_fixture_TestTableFunctions' for <Function test_array_slicing_readonly>>

    @fixtures.fixture(
        autouse=True,
        scope="function",
        # Use a unique name to speed up lookup.
        name=f"_xunit_setup_method_fixture_{self.obj.__qualname__}",
    )
    def xunit_setup_method_fixture(self, request) -> Generator[None, None, None]:
        method = request.function
        if setup_method is not None:
            func = getattr(self, setup_name)
            _call_with_optional_argument(func, method)
            if emit_nose_setup_warning:
>               warnings.warn(
                    NOSE_SUPPORT_METHOD.format(
                        nodeid=request.node.nodeid, method="setup"
                    ),
                    stacklevel=2,
                )
E               pytest.PytestRemovedIn8Warning: Support for nose tests is deprecated and will be removed in a future release.
E               astropy/io/fits/tests/test_table.py::TestTableFunctions::test_array_slicing_readonly is using nose-specific method: `setup(self)`
E               To remove this warning, rename it to `setup_method(self)`
E               See docs: https://docs.pytest.org/en/stable/deprecations.html#support-for-tests-written-for-nose

../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/python.py:898: PytestRemovedIn8Warning
________ ERROR at setup of TestTableFunctions.test_dump_load_round_trip ________

cls = <class '_pytest.runner.CallInfo'>
func = <function call_runtest_hook.<locals>.<lambda> at 0x7d2b56b40160>
when = 'setup'
reraise = (<class '_pytest.outcomes.Exit'>, <class 'KeyboardInterrupt'>)

    @classmethod
    def from_call(
        cls,
        func: "Callable[[], TResult]",
        when: "Literal['collect', 'setup', 'call', 'teardown']",
        reraise: Optional[
            Union[Type[BaseException], Tuple[Type[BaseException], ...]]
        ] = None,
    ) -> "CallInfo[TResult]":
        """Call func, wrapping the result in a CallInfo.
    
        :param func:
            The function to call. Called without arguments.
        :param when:
            The phase in which the function is called.
        :param reraise:
            Exception or exceptions that shall propagate if raised by the
            function, instead of being wrapped in the CallInfo.
        """
        excinfo = None
        start = timing.time()
        precise_start = timing.perf_counter()
        try:
>           result: Optional[TResult] = func()

../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/runner.py:341: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/runner.py:262: in <lambda>
    lambda: ihook(item=item, **kwds), when=when, reraise=reraise
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/pluggy/_hooks.py:493: in __call__
    return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/pluggy/_manager.py:115: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/runner.py:157: in pytest_runtest_setup
    item.session._setupstate.setup(item)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/runner.py:497: in setup
    raise exc
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/runner.py:494: in setup
    col.setup()
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/python.py:1791: in setup
    self._request._fillfixtures()
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/fixtures.py:566: in _fillfixtures
    item.funcargs[argname] = self.getfixturevalue(argname)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/fixtures.py:585: in getfixturevalue
    fixturedef = self._get_active_fixturedef(argname)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/fixtures.py:607: in _get_active_fixturedef
    self._compute_fixture_value(fixturedef)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/fixtures.py:693: in _compute_fixture_value
    fixturedef.execute(request=subrequest)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/fixtures.py:1069: in execute
    result = ihook.pytest_fixture_setup(fixturedef=self, request=request)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/pluggy/_hooks.py:493: in __call__
    return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/pluggy/_manager.py:115: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/fixtures.py:1123: in pytest_fixture_setup
    result = call_fixture_func(fixturefunc, request, kwargs)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/fixtures.py:895: in call_fixture_func
    fixture_result = next(generator)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <astropy.io.fits.tests.test_table.TestTableFunctions object at 0x7d2b570e2490>
request = <SubRequest '_xunit_setup_method_fixture_TestTableFunctions' for <Function test_dump_load_round_trip>>

    @fixtures.fixture(
        autouse=True,
        scope="function",
        # Use a unique name to speed up lookup.
        name=f"_xunit_setup_method_fixture_{self.obj.__qualname__}",
    )
    def xunit_setup_method_fixture(self, request) -> Generator[None, None, None]:
        method = request.function
        if setup_method is not None:
            func = getattr(self, setup_name)
            _call_with_optional_argument(func, method)
            if emit_nose_setup_warning:
>               warnings.warn(
                    NOSE_SUPPORT_METHOD.format(
                        nodeid=request.node.nodeid, method="setup"
                    ),
                    stacklevel=2,
                )
E               pytest.PytestRemovedIn8Warning: Support for nose tests is deprecated and will be removed in a future release.
E               astropy/io/fits/tests/test_table.py::TestTableFunctions::test_dump_load_round_trip is using nose-specific method: `setup(self)`
E               To remove this warning, rename it to `setup_method(self)`
E               See docs: https://docs.pytest.org/en/stable/deprecations.html#support-for-tests-written-for-nose

../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/python.py:898: PytestRemovedIn8Warning
_______ ERROR at setup of TestTableFunctions.test_dump_load_array_colums _______

cls = <class '_pytest.runner.CallInfo'>
func = <function call_runtest_hook.<locals>.<lambda> at 0x7d2b568fadc0>
when = 'setup'
reraise = (<class '_pytest.outcomes.Exit'>, <class 'KeyboardInterrupt'>)

    @classmethod
    def from_call(
        cls,
        func: "Callable[[], TResult]",
        when: "Literal['collect', 'setup', 'call', 'teardown']",
        reraise: Optional[
            Union[Type[BaseException], Tuple[Type[BaseException], ...]]
        ] = None,
    ) -> "CallInfo[TResult]":
        """Call func, wrapping the result in a CallInfo.
    
        :param func:
            The function to call. Called without arguments.
        :param when:
            The phase in which the function is called.
        :param reraise:
            Exception or exceptions that shall propagate if raised by the
            function, instead of being wrapped in the CallInfo.
        """
        excinfo = None
        start = timing.time()
        precise_start = timing.perf_counter()
        try:
>           result: Optional[TResult] = func()

../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/runner.py:341: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/runner.py:262: in <lambda>
    lambda: ihook(item=item, **kwds), when=when, reraise=reraise
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/pluggy/_hooks.py:493: in __call__
    return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/pluggy/_manager.py:115: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/runner.py:157: in pytest_runtest_setup
    item.session._setupstate.setup(item)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/runner.py:497: in setup
    raise exc
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/runner.py:494: in setup
    col.setup()
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/python.py:1791: in setup
    self._request._fillfixtures()
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/fixtures.py:566: in _fillfixtures
    item.funcargs[argname] = self.getfixturevalue(argname)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/fixtures.py:585: in getfixturevalue
    fixturedef = self._get_active_fixturedef(argname)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/fixtures.py:607: in _get_active_fixturedef
    self._compute_fixture_value(fixturedef)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/fixtures.py:693: in _compute_fixture_value
    fixturedef.execute(request=subrequest)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/fixtures.py:1069: in execute
    result = ihook.pytest_fixture_setup(fixturedef=self, request=request)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/pluggy/_hooks.py:493: in __call__
    return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/pluggy/_manager.py:115: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/fixtures.py:1123: in pytest_fixture_setup
    result = call_fixture_func(fixturefunc, request, kwargs)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/fixtures.py:895: in call_fixture_func
    fixture_result = next(generator)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <astropy.io.fits.tests.test_table.TestTableFunctions object at 0x7d2b570e2d00>
request = <SubRequest '_xunit_setup_method_fixture_TestTableFunctions' for <Function test_dump_load_array_colums>>

    @fixtures.fixture(
        autouse=True,
        scope="function",
        # Use a unique name to speed up lookup.
        name=f"_xunit_setup_method_fixture_{self.obj.__qualname__}",
    )
    def xunit_setup_method_fixture(self, request) -> Generator[None, None, None]:
        method = request.function
        if setup_method is not None:
            func = getattr(self, setup_name)
            _call_with_optional_argument(func, method)
            if emit_nose_setup_warning:
>               warnings.warn(
                    NOSE_SUPPORT_METHOD.format(
                        nodeid=request.node.nodeid, method="setup"
                    ),
                    stacklevel=2,
                )
E               pytest.PytestRemovedIn8Warning: Support for nose tests is deprecated and will be removed in a future release.
E               astropy/io/fits/tests/test_table.py::TestTableFunctions::test_dump_load_array_colums is using nose-specific method: `setup(self)`
E               To remove this warning, rename it to `setup_method(self)`
E               See docs: https://docs.pytest.org/en/stable/deprecations.html#support-for-tests-written-for-nose

../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/python.py:898: PytestRemovedIn8Warning
_________ ERROR at setup of TestTableFunctions.test_load_guess_format __________

cls = <class '_pytest.runner.CallInfo'>
func = <function call_runtest_hook.<locals>.<lambda> at 0x7d2b55bac700>
when = 'setup'
reraise = (<class '_pytest.outcomes.Exit'>, <class 'KeyboardInterrupt'>)

    @classmethod
    def from_call(
        cls,
        func: "Callable[[], TResult]",
        when: "Literal['collect', 'setup', 'call', 'teardown']",
        reraise: Optional[
            Union[Type[BaseException], Tuple[Type[BaseException], ...]]
        ] = None,
    ) -> "CallInfo[TResult]":
        """Call func, wrapping the result in a CallInfo.
    
        :param func:
            The function to call. Called without arguments.
        :param when:
            The phase in which the function is called.
        :param reraise:
            Exception or exceptions that shall propagate if raised by the
            function, instead of being wrapped in the CallInfo.
        """
        excinfo = None
        start = timing.time()
        precise_start = timing.perf_counter()
        try:
>           result: Optional[TResult] = func()

../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/runner.py:341: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/runner.py:262: in <lambda>
    lambda: ihook(item=item, **kwds), when=when, reraise=reraise
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/pluggy/_hooks.py:493: in __call__
    return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/pluggy/_manager.py:115: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/runner.py:157: in pytest_runtest_setup
    item.session._setupstate.setup(item)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/runner.py:497: in setup
    raise exc
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/runner.py:494: in setup
    col.setup()
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/python.py:1791: in setup
    self._request._fillfixtures()
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/fixtures.py:566: in _fillfixtures
    item.funcargs[argname] = self.getfixturevalue(argname)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/fixtures.py:585: in getfixturevalue
    fixturedef = self._get_active_fixturedef(argname)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/fixtures.py:607: in _get_active_fixturedef
    self._compute_fixture_value(fixturedef)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/fixtures.py:693: in _compute_fixture_value
    fixturedef.execute(request=subrequest)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/fixtures.py:1069: in execute
    result = ihook.pytest_fixture_setup(fixturedef=self, request=request)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/pluggy/_hooks.py:493: in __call__
    return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/pluggy/_manager.py:115: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/fixtures.py:1123: in pytest_fixture_setup
    result = call_fixture_func(fixturefunc, request, kwargs)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/fixtures.py:895: in call_fixture_func
    fixture_result = next(generator)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <astropy.io.fits.tests.test_table.TestTableFunctions object at 0x7d2b570e2e80>
request = <SubRequest '_xunit_setup_method_fixture_TestTableFunctions' for <Function test_load_guess_format>>

    @fixtures.fixture(
        autouse=True,
        scope="function",
        # Use a unique name to speed up lookup.
        name=f"_xunit_setup_method_fixture_{self.obj.__qualname__}",
    )
    def xunit_setup_method_fixture(self, request) -> Generator[None, None, None]:
        method = request.function
        if setup_method is not None:
            func = getattr(self, setup_name)
            _call_with_optional_argument(func, method)
            if emit_nose_setup_warning:
>               warnings.warn(
                    NOSE_SUPPORT_METHOD.format(
                        nodeid=request.node.nodeid, method="setup"
                    ),
                    stacklevel=2,
                )
E               pytest.PytestRemovedIn8Warning: Support for nose tests is deprecated and will be removed in a future release.
E               astropy/io/fits/tests/test_table.py::TestTableFunctions::test_load_guess_format is using nose-specific method: `setup(self)`
E               To remove this warning, rename it to `setup_method(self)`
E               See docs: https://docs.pytest.org/en/stable/deprecations.html#support-for-tests-written-for-nose

../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/python.py:898: PytestRemovedIn8Warning
_____ ERROR at setup of TestTableFunctions.test_attribute_field_shadowing ______

cls = <class '_pytest.runner.CallInfo'>
func = <function call_runtest_hook.<locals>.<lambda> at 0x7d2b56b40790>
when = 'setup'
reraise = (<class '_pytest.outcomes.Exit'>, <class 'KeyboardInterrupt'>)

    @classmethod
    def from_call(
        cls,
        func: "Callable[[], TResult]",
        when: "Literal['collect', 'setup', 'call', 'teardown']",
        reraise: Optional[
            Union[Type[BaseException], Tuple[Type[BaseException], ...]]
        ] = None,
    ) -> "CallInfo[TResult]":
        """Call func, wrapping the result in a CallInfo.
    
        :param func:
            The function to call. Called without arguments.
        :param when:
            The phase in which the function is called.
        :param reraise:
            Exception or exceptions that shall propagate if raised by the
            function, instead of being wrapped in the CallInfo.
        """
        excinfo = None
        start = timing.time()
        precise_start = timing.perf_counter()
        try:
>           result: Optional[TResult] = func()

../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/runner.py:341: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/runner.py:262: in <lambda>
    lambda: ihook(item=item, **kwds), when=when, reraise=reraise
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/pluggy/_hooks.py:493: in __call__
    return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/pluggy/_manager.py:115: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/runner.py:157: in pytest_runtest_setup
    item.session._setupstate.setup(item)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/runner.py:497: in setup
    raise exc
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/runner.py:494: in setup
    col.setup()
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/python.py:1791: in setup
    self._request._fillfixtures()
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/fixtures.py:566: in _fillfixtures
    item.funcargs[argname] = self.getfixturevalue(argname)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/fixtures.py:585: in getfixturevalue
    fixturedef = self._get_active_fixturedef(argname)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/fixtures.py:607: in _get_active_fixturedef
    self._compute_fixture_value(fixturedef)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/fixtures.py:693: in _compute_fixture_value
    fixturedef.execute(request=subrequest)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/fixtures.py:1069: in execute
    result = ihook.pytest_fixture_setup(fixturedef=self, request=request)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/pluggy/_hooks.py:493: in __call__
    return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/pluggy/_manager.py:115: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/fixtures.py:1123: in pytest_fixture_setup
    result = call_fixture_func(fixturefunc, request, kwargs)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/fixtures.py:895: in call_fixture_func
    fixture_result = next(generator)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <astropy.io.fits.tests.test_table.TestTableFunctions object at 0x7d2b570e2580>
request = <SubRequest '_xunit_setup_method_fixture_TestTableFunctions' for <Function test_attribute_field_shadowing>>

    @fixtures.fixture(
        autouse=True,
        scope="function",
        # Use a unique name to speed up lookup.
        name=f"_xunit_setup_method_fixture_{self.obj.__qualname__}",
    )
    def xunit_setup_method_fixture(self, request) -> Generator[None, None, None]:
        method = request.function
        if setup_method is not None:
            func = getattr(self, setup_name)
            _call_with_optional_argument(func, method)
            if emit_nose_setup_warning:
>               warnings.warn(
                    NOSE_SUPPORT_METHOD.format(
                        nodeid=request.node.nodeid, method="setup"
                    ),
                    stacklevel=2,
                )
E               pytest.PytestRemovedIn8Warning: Support for nose tests is deprecated and will be removed in a future release.
E               astropy/io/fits/tests/test_table.py::TestTableFunctions::test_attribute_field_shadowing is using nose-specific method: `setup(self)`
E               To remove this warning, rename it to `setup_method(self)`
E               See docs: https://docs.pytest.org/en/stable/deprecations.html#support-for-tests-written-for-nose

../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/python.py:898: PytestRemovedIn8Warning
_______ ERROR at setup of TestTableFunctions.test_table_from_bool_fields _______

cls = <class '_pytest.runner.CallInfo'>
func = <function call_runtest_hook.<locals>.<lambda> at 0x7d2b55c47160>
when = 'setup'
reraise = (<class '_pytest.outcomes.Exit'>, <class 'KeyboardInterrupt'>)

    @classmethod
    def from_call(
        cls,
        func: "Callable[[], TResult]",
        when: "Literal['collect', 'setup', 'call', 'teardown']",
        reraise: Optional[
            Union[Type[BaseException], Tuple[Type[BaseException], ...]]
        ] = None,
    ) -> "CallInfo[TResult]":
        """Call func, wrapping the result in a CallInfo.
    
        :param func:
            The function to call. Called without arguments.
        :param when:
            The phase in which the function is called.
        :param reraise:
            Exception or exceptions that shall propagate if raised by the
            function, instead of being wrapped in the CallInfo.
        """
        excinfo = None
        start = timing.time()
        precise_start = timing.perf_counter()
        try:
>           result: Optional[TResult] = func()

../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/runner.py:341: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/runner.py:262: in <lambda>
    lambda: ihook(item=item, **kwds), when=when, reraise=reraise
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/pluggy/_hooks.py:493: in __call__
    return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/pluggy/_manager.py:115: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/runner.py:157: in pytest_runtest_setup
    item.session._setupstate.setup(item)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/runner.py:497: in setup
    raise exc
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/runner.py:494: in setup
    col.setup()
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/python.py:1791: in setup
    self._request._fillfixtures()
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/fixtures.py:566: in _fillfixtures
    item.funcargs[argname] = self.getfixturevalue(argname)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/fixtures.py:585: in getfixturevalue
    fixturedef = self._get_active_fixturedef(argname)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/fixtures.py:607: in _get_active_fixturedef
    self._compute_fixture_value(fixturedef)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/fixtures.py:693: in _compute_fixture_value
    fixturedef.execute(request=subrequest)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/fixtures.py:1069: in execute
    result = ihook.pytest_fixture_setup(fixturedef=self, request=request)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/pluggy/_hooks.py:493: in __call__
    return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/pluggy/_manager.py:115: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/fixtures.py:1123: in pytest_fixture_setup
    result = call_fixture_func(fixturefunc, request, kwargs)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/fixtures.py:895: in call_fixture_func
    fixture_result = next(generator)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <astropy.io.fits.tests.test_table.TestTableFunctions object at 0x7d2b570e2220>
request = <SubRequest '_xunit_setup_method_fixture_TestTableFunctions' for <Function test_table_from_bool_fields>>

    @fixtures.fixture(
        autouse=True,
        scope="function",
        # Use a unique name to speed up lookup.
        name=f"_xunit_setup_method_fixture_{self.obj.__qualname__}",
    )
    def xunit_setup_method_fixture(self, request) -> Generator[None, None, None]:
        method = request.function
        if setup_method is not None:
            func = getattr(self, setup_name)
            _call_with_optional_argument(func, method)
            if emit_nose_setup_warning:
>               warnings.warn(
                    NOSE_SUPPORT_METHOD.format(
                        nodeid=request.node.nodeid, method="setup"
                    ),
                    stacklevel=2,
                )
E               pytest.PytestRemovedIn8Warning: Support for nose tests is deprecated and will be removed in a future release.
E               astropy/io/fits/tests/test_table.py::TestTableFunctions::test_table_from_bool_fields is using nose-specific method: `setup(self)`
E               To remove this warning, rename it to `setup_method(self)`
E               See docs: https://docs.pytest.org/en/stable/deprecations.html#support-for-tests-written-for-nose

../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/python.py:898: PytestRemovedIn8Warning
______ ERROR at setup of TestTableFunctions.test_table_from_bool_fields2 _______

cls = <class '_pytest.runner.CallInfo'>
func = <function call_runtest_hook.<locals>.<lambda> at 0x7d2b55bacca0>
when = 'setup'
reraise = (<class '_pytest.outcomes.Exit'>, <class 'KeyboardInterrupt'>)

    @classmethod
    def from_call(
        cls,
        func: "Callable[[], TResult]",
        when: "Literal['collect', 'setup', 'call', 'teardown']",
        reraise: Optional[
            Union[Type[BaseException], Tuple[Type[BaseException], ...]]
        ] = None,
    ) -> "CallInfo[TResult]":
        """Call func, wrapping the result in a CallInfo.
    
        :param func:
            The function to call. Called without arguments.
        :param when:
            The phase in which the function is called.
        :param reraise:
            Exception or exceptions that shall propagate if raised by the
            function, instead of being wrapped in the CallInfo.
        """
        excinfo = None
        start = timing.time()
        precise_start = timing.perf_counter()
        try:
>           result: Optional[TResult] = func()

../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/runner.py:341: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/runner.py:262: in <lambda>
    lambda: ihook(item=item, **kwds), when=when, reraise=reraise
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/pluggy/_hooks.py:493: in __call__
    return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/pluggy/_manager.py:115: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/runner.py:157: in pytest_runtest_setup
    item.session._setupstate.setup(item)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/runner.py:497: in setup
    raise exc
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/runner.py:494: in setup
    col.setup()
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/python.py:1791: in setup
    self._request._fillfixtures()
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/fixtures.py:566: in _fillfixtures
    item.funcargs[argname] = self.getfixturevalue(argname)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/fixtures.py:585: in getfixturevalue
    fixturedef = self._get_active_fixturedef(argname)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/fixtures.py:607: in _get_active_fixturedef
    self._compute_fixture_value(fixturedef)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/fixtures.py:693: in _compute_fixture_value
    fixturedef.execute(request=subrequest)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/fixtures.py:1069: in execute
    result = ihook.pytest_fixture_setup(fixturedef=self, request=request)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/pluggy/_hooks.py:493: in __call__
    return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/pluggy/_manager.py:115: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/fixtures.py:1123: in pytest_fixture_setup
    result = call_fixture_func(fixturefunc, request, kwargs)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/fixtures.py:895: in call_fixture_func
    fixture_result = next(generator)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <astropy.io.fits.tests.test_table.TestTableFunctions object at 0x7d2b570e20a0>
request = <SubRequest '_xunit_setup_method_fixture_TestTableFunctions' for <Function test_table_from_bool_fields2>>

    @fixtures.fixture(
        autouse=True,
        scope="function",
        # Use a unique name to speed up lookup.
        name=f"_xunit_setup_method_fixture_{self.obj.__qualname__}",
    )
    def xunit_setup_method_fixture(self, request) -> Generator[None, None, None]:
        method = request.function
        if setup_method is not None:
            func = getattr(self, setup_name)
            _call_with_optional_argument(func, method)
            if emit_nose_setup_warning:
>               warnings.warn(
                    NOSE_SUPPORT_METHOD.format(
                        nodeid=request.node.nodeid, method="setup"
                    ),
                    stacklevel=2,
                )
E               pytest.PytestRemovedIn8Warning: Support for nose tests is deprecated and will be removed in a future release.
E               astropy/io/fits/tests/test_table.py::TestTableFunctions::test_table_from_bool_fields2 is using nose-specific method: `setup(self)`
E               To remove this warning, rename it to `setup_method(self)`
E               See docs: https://docs.pytest.org/en/stable/deprecations.html#support-for-tests-written-for-nose

../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/python.py:898: PytestRemovedIn8Warning
_________ ERROR at setup of TestTableFunctions.test_bool_column_update _________

cls = <class '_pytest.runner.CallInfo'>
func = <function call_runtest_hook.<locals>.<lambda> at 0x7d2b55c478b0>
when = 'setup'
reraise = (<class '_pytest.outcomes.Exit'>, <class 'KeyboardInterrupt'>)

    @classmethod
    def from_call(
        cls,
        func: "Callable[[], TResult]",
        when: "Literal['collect', 'setup', 'call', 'teardown']",
        reraise: Optional[
            Union[Type[BaseException], Tuple[Type[BaseException], ...]]
        ] = None,
    ) -> "CallInfo[TResult]":
        """Call func, wrapping the result in a CallInfo.
    
        :param func:
            The function to call. Called without arguments.
        :param when:
            The phase in which the function is called.
        :param reraise:
            Exception or exceptions that shall propagate if raised by the
            function, instead of being wrapped in the CallInfo.
        """
        excinfo = None
        start = timing.time()
        precise_start = timing.perf_counter()
        try:
>           result: Optional[TResult] = func()

../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/runner.py:341: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/runner.py:262: in <lambda>
    lambda: ihook(item=item, **kwds), when=when, reraise=reraise
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/pluggy/_hooks.py:493: in __call__
    return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/pluggy/_manager.py:115: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/runner.py:157: in pytest_runtest_setup
    item.session._setupstate.setup(item)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/runner.py:497: in setup
    raise exc
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/runner.py:494: in setup
    col.setup()
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/python.py:1791: in setup
    self._request._fillfixtures()
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/fixtures.py:566: in _fillfixtures
    item.funcargs[argname] = self.getfixturevalue(argname)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/fixtures.py:585: in getfixturevalue
    fixturedef = self._get_active_fixturedef(argname)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/fixtures.py:607: in _get_active_fixturedef
    self._compute_fixture_value(fixturedef)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/fixtures.py:693: in _compute_fixture_value
    fixturedef.execute(request=subrequest)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/fixtures.py:1069: in execute
    result = ihook.pytest_fixture_setup(fixturedef=self, request=request)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/pluggy/_hooks.py:493: in __call__
    return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/pluggy/_manager.py:115: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/fixtures.py:1123: in pytest_fixture_setup
    result = call_fixture_func(fixturefunc, request, kwargs)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/fixtures.py:895: in call_fixture_func
    fixture_result = next(generator)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <astropy.io.fits.tests.test_table.TestTableFunctions object at 0x7d2b570c4490>
request = <SubRequest '_xunit_setup_method_fixture_TestTableFunctions' for <Function test_bool_column_update>>

    @fixtures.fixture(
        autouse=True,
        scope="function",
        # Use a unique name to speed up lookup.
        name=f"_xunit_setup_method_fixture_{self.obj.__qualname__}",
    )
    def xunit_setup_method_fixture(self, request) -> Generator[None, None, None]:
        method = request.function
        if setup_method is not None:
            func = getattr(self, setup_name)
            _call_with_optional_argument(func, method)
            if emit_nose_setup_warning:
>               warnings.warn(
                    NOSE_SUPPORT_METHOD.format(
                        nodeid=request.node.nodeid, method="setup"
                    ),
                    stacklevel=2,
                )
E               pytest.PytestRemovedIn8Warning: Support for nose tests is deprecated and will be removed in a future release.
E               astropy/io/fits/tests/test_table.py::TestTableFunctions::test_bool_column_update is using nose-specific method: `setup(self)`
E               To remove this warning, rename it to `setup_method(self)`
E               See docs: https://docs.pytest.org/en/stable/deprecations.html#support-for-tests-written-for-nose

../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/python.py:898: PytestRemovedIn8Warning
___________ ERROR at setup of TestTableFunctions.test_missing_tnull ____________

cls = <class '_pytest.runner.CallInfo'>
func = <function call_runtest_hook.<locals>.<lambda> at 0x7d2b55bac280>
when = 'setup'
reraise = (<class '_pytest.outcomes.Exit'>, <class 'KeyboardInterrupt'>)

    @classmethod
    def from_call(
        cls,
        func: "Callable[[], TResult]",
        when: "Literal['collect', 'setup', 'call', 'teardown']",
        reraise: Optional[
            Union[Type[BaseException], Tuple[Type[BaseException], ...]]
        ] = None,
    ) -> "CallInfo[TResult]":
        """Call func, wrapping the result in a CallInfo.
    
        :param func:
            The function to call. Called without arguments.
        :param when:
            The phase in which the function is called.
        :param reraise:
            Exception or exceptions that shall propagate if raised by the
            function, instead of being wrapped in the CallInfo.
        """
        excinfo = None
        start = timing.time()
        precise_start = timing.perf_counter()
        try:
>           result: Optional[TResult] = func()

../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/runner.py:341: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/runner.py:262: in <lambda>
    lambda: ihook(item=item, **kwds), when=when, reraise=reraise
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/pluggy/_hooks.py:493: in __call__
    return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/pluggy/_manager.py:115: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/runner.py:157: in pytest_runtest_setup
    item.session._setupstate.setup(item)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/runner.py:497: in setup
    raise exc
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/runner.py:494: in setup
    col.setup()
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/python.py:1791: in setup
    self._request._fillfixtures()
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/fixtures.py:566: in _fillfixtures
    item.funcargs[argname] = self.getfixturevalue(argname)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/fixtures.py:585: in getfixturevalue
    fixturedef = self._get_active_fixturedef(argname)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/fixtures.py:607: in _get_active_fixturedef
    self._compute_fixture_value(fixturedef)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/fixtures.py:693: in _compute_fixture_value
    fixturedef.execute(request=subrequest)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/fixtures.py:1069: in execute
    result = ihook.pytest_fixture_setup(fixturedef=self, request=request)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/pluggy/_hooks.py:493: in __call__
    return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/pluggy/_manager.py:115: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/fixtures.py:1123: in pytest_fixture_setup
    result = call_fixture_func(fixturefunc, request, kwargs)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/fixtures.py:895: in call_fixture_func
    fixture_result = next(generator)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <astropy.io.fits.tests.test_table.TestTableFunctions object at 0x7d2b570c4610>
request = <SubRequest '_xunit_setup_method_fixture_TestTableFunctions' for <Function test_missing_tnull>>

    @fixtures.fixture(
        autouse=True,
        scope="function",
        # Use a unique name to speed up lookup.
        name=f"_xunit_setup_method_fixture_{self.obj.__qualname__}",
    )
    def xunit_setup_method_fixture(self, request) -> Generator[None, None, None]:
        method = request.function
        if setup_method is not None:
            func = getattr(self, setup_name)
            _call_with_optional_argument(func, method)
            if emit_nose_setup_warning:
>               warnings.warn(
                    NOSE_SUPPORT_METHOD.format(
                        nodeid=request.node.nodeid, method="setup"
                    ),
                    stacklevel=2,
                )
E               pytest.PytestRemovedIn8Warning: Support for nose tests is deprecated and will be removed in a future release.
E               astropy/io/fits/tests/test_table.py::TestTableFunctions::test_missing_tnull is using nose-specific method: `setup(self)`
E               To remove this warning, rename it to `setup_method(self)`
E               See docs: https://docs.pytest.org/en/stable/deprecations.html#support-for-tests-written-for-nose

../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/python.py:898: PytestRemovedIn8Warning
__________ ERROR at setup of TestTableFunctions.test_blank_field_zero __________

cls = <class '_pytest.runner.CallInfo'>
func = <function call_runtest_hook.<locals>.<lambda> at 0x7d2b56564f70>
when = 'setup'
reraise = (<class '_pytest.outcomes.Exit'>, <class 'KeyboardInterrupt'>)

    @classmethod
    def from_call(
        cls,
        func: "Callable[[], TResult]",
        when: "Literal['collect', 'setup', 'call', 'teardown']",
        reraise: Optional[
            Union[Type[BaseException], Tuple[Type[BaseException], ...]]
        ] = None,
    ) -> "CallInfo[TResult]":
        """Call func, wrapping the result in a CallInfo.
    
        :param func:
            The function to call. Called without arguments.
        :param when:
            The phase in which the function is called.
        :param reraise:
            Exception or exceptions that shall propagate if raised by the
            function, instead of being wrapped in the CallInfo.
        """
        excinfo = None
        start = timing.time()
        precise_start = timing.perf_counter()
        try:
>           result: Optional[TResult] = func()

../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/runner.py:341: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/runner.py:262: in <lambda>
    lambda: ihook(item=item, **kwds), when=when, reraise=reraise
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/pluggy/_hooks.py:493: in __call__
    return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/pluggy/_manager.py:115: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/runner.py:157: in pytest_runtest_setup
    item.session._setupstate.setup(item)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/runner.py:497: in setup
    raise exc
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/runner.py:494: in setup
    col.setup()
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/python.py:1791: in setup
    self._request._fillfixtures()
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/fixtures.py:566: in _fillfixtures
    item.funcargs[argname] = self.getfixturevalue(argname)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/fixtures.py:585: in getfixturevalue
    fixturedef = self._get_active_fixturedef(argname)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/fixtures.py:607: in _get_active_fixturedef
    self._compute_fixture_value(fixturedef)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/fixtures.py:693: in _compute_fixture_value
    fixturedef.execute(request=subrequest)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/fixtures.py:1069: in execute
    result = ihook.pytest_fixture_setup(fixturedef=self, request=request)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/pluggy/_hooks.py:493: in __call__
    return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/pluggy/_manager.py:115: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/fixtures.py:1123: in pytest_fixture_setup
    result = call_fixture_func(fixturefunc, request, kwargs)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/fixtures.py:895: in call_fixture_func
    fixture_result = next(generator)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <astropy.io.fits.tests.test_table.TestTableFunctions object at 0x7d2b570e27f0>
request = <SubRequest '_xunit_setup_method_fixture_TestTableFunctions' for <Function test_blank_field_zero>>

    @fixtures.fixture(
        autouse=True,
        scope="function",
        # Use a unique name to speed up lookup.
        name=f"_xunit_setup_method_fixture_{self.obj.__qualname__}",
    )
    def xunit_setup_method_fixture(self, request) -> Generator[None, None, None]:
        method = request.function
        if setup_method is not None:
            func = getattr(self, setup_name)
            _call_with_optional_argument(func, method)
            if emit_nose_setup_warning:
>               warnings.warn(
                    NOSE_SUPPORT_METHOD.format(
                        nodeid=request.node.nodeid, method="setup"
                    ),
                    stacklevel=2,
                )
E               pytest.PytestRemovedIn8Warning: Support for nose tests is deprecated and will be removed in a future release.
E               astropy/io/fits/tests/test_table.py::TestTableFunctions::test_blank_field_zero is using nose-specific method: `setup(self)`
E               To remove this warning, rename it to `setup_method(self)`
E               See docs: https://docs.pytest.org/en/stable/deprecations.html#support-for-tests-written-for-nose

../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/python.py:898: PytestRemovedIn8Warning
_____ ERROR at setup of TestTableFunctions.test_column_array_type_mismatch _____

cls = <class '_pytest.runner.CallInfo'>
func = <function call_runtest_hook.<locals>.<lambda> at 0x7d2b55c478b0>
when = 'setup'
reraise = (<class '_pytest.outcomes.Exit'>, <class 'KeyboardInterrupt'>)

    @classmethod
    def from_call(
        cls,
        func: "Callable[[], TResult]",
        when: "Literal['collect', 'setup', 'call', 'teardown']",
        reraise: Optional[
            Union[Type[BaseException], Tuple[Type[BaseException], ...]]
        ] = None,
    ) -> "CallInfo[TResult]":
        """Call func, wrapping the result in a CallInfo.
    
        :param func:
            The function to call. Called without arguments.
        :param when:
            The phase in which the function is called.
        :param reraise:
            Exception or exceptions that shall propagate if raised by the
            function, instead of being wrapped in the CallInfo.
        """
        excinfo = None
        start = timing.time()
        precise_start = timing.perf_counter()
        try:
>           result: Optional[TResult] = func()

../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/runner.py:341: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/runner.py:262: in <lambda>
    lambda: ihook(item=item, **kwds), when=when, reraise=reraise
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/pluggy/_hooks.py:493: in __call__
    return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/pluggy/_manager.py:115: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/runner.py:157: in pytest_runtest_setup
    item.session._setupstate.setup(item)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/runner.py:497: in setup
    raise exc
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/runner.py:494: in setup
    col.setup()
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/python.py:1791: in setup
    self._request._fillfixtures()
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/fixtures.py:566: in _fillfixtures
    item.funcargs[argname] = self.getfixturevalue(argname)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/fixtures.py:585: in getfixturevalue
    fixturedef = self._get_active_fixturedef(argname)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/fixtures.py:607: in _get_active_fixturedef
    self._compute_fixture_value(fixturedef)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/fixtures.py:693: in _compute_fixture_value
    fixturedef.execute(request=subrequest)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/fixtures.py:1069: in execute
    result = ihook.pytest_fixture_setup(fixturedef=self, request=request)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/pluggy/_hooks.py:493: in __call__
    return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/pluggy/_manager.py:115: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/fixtures.py:1123: in pytest_fixture_setup
    result = call_fixture_func(fixturefunc, request, kwargs)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/fixtures.py:895: in call_fixture_func
    fixture_result = next(generator)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <astropy.io.fits.tests.test_table.TestTableFunctions object at 0x7d2b570e2040>
request = <SubRequest '_xunit_setup_method_fixture_TestTableFunctions' for <Function test_column_array_type_mismatch>>

    @fixtures.fixture(
        autouse=True,
        scope="function",
        # Use a unique name to speed up lookup.
        name=f"_xunit_setup_method_fixture_{self.obj.__qualname__}",
    )
    def xunit_setup_method_fixture(self, request) -> Generator[None, None, None]:
        method = request.function
        if setup_method is not None:
            func = getattr(self, setup_name)
            _call_with_optional_argument(func, method)
            if emit_nose_setup_warning:
>               warnings.warn(
                    NOSE_SUPPORT_METHOD.format(
                        nodeid=request.node.nodeid, method="setup"
                    ),
                    stacklevel=2,
                )
E               pytest.PytestRemovedIn8Warning: Support for nose tests is deprecated and will be removed in a future release.
E               astropy/io/fits/tests/test_table.py::TestTableFunctions::test_column_array_type_mismatch is using nose-specific method: `setup(self)`
E               To remove this warning, rename it to `setup_method(self)`
E               See docs: https://docs.pytest.org/en/stable/deprecations.html#support-for-tests-written-for-nose

../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/python.py:898: PytestRemovedIn8Warning
_____________ ERROR at setup of TestTableFunctions.test_table_none _____________

cls = <class '_pytest.runner.CallInfo'>
func = <function call_runtest_hook.<locals>.<lambda> at 0x7d2b55b62f70>
when = 'setup'
reraise = (<class '_pytest.outcomes.Exit'>, <class 'KeyboardInterrupt'>)

    @classmethod
    def from_call(
        cls,
        func: "Callable[[], TResult]",
        when: "Literal['collect', 'setup', 'call', 'teardown']",
        reraise: Optional[
            Union[Type[BaseException], Tuple[Type[BaseException], ...]]
        ] = None,
    ) -> "CallInfo[TResult]":
        """Call func, wrapping the result in a CallInfo.
    
        :param func:
            The function to call. Called without arguments.
        :param when:
            The phase in which the function is called.
        :param reraise:
            Exception or exceptions that shall propagate if raised by the
            function, instead of being wrapped in the CallInfo.
        """
        excinfo = None
        start = timing.time()
        precise_start = timing.perf_counter()
        try:
>           result: Optional[TResult] = func()

../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/runner.py:341: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/runner.py:262: in <lambda>
    lambda: ihook(item=item, **kwds), when=when, reraise=reraise
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/pluggy/_hooks.py:493: in __call__
    return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/pluggy/_manager.py:115: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/runner.py:157: in pytest_runtest_setup
    item.session._setupstate.setup(item)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/runner.py:497: in setup
    raise exc
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/runner.py:494: in setup
    col.setup()
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/python.py:1791: in setup
    self._request._fillfixtures()
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/fixtures.py:566: in _fillfixtures
    item.funcargs[argname] = self.getfixturevalue(argname)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/fixtures.py:585: in getfixturevalue
    fixturedef = self._get_active_fixturedef(argname)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/fixtures.py:607: in _get_active_fixturedef
    self._compute_fixture_value(fixturedef)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/fixtures.py:693: in _compute_fixture_value
    fixturedef.execute(request=subrequest)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/fixtures.py:1069: in execute
    result = ihook.pytest_fixture_setup(fixturedef=self, request=request)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/pluggy/_hooks.py:493: in __call__
    return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/pluggy/_manager.py:115: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/fixtures.py:1123: in pytest_fixture_setup
    result = call_fixture_func(fixturefunc, request, kwargs)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/fixtures.py:895: in call_fixture_func
    fixture_result = next(generator)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <astropy.io.fits.tests.test_table.TestTableFunctions object at 0x7d2b570e7c40>
request = <SubRequest '_xunit_setup_method_fixture_TestTableFunctions' for <Function test_table_none>>

    @fixtures.fixture(
        autouse=True,
        scope="function",
        # Use a unique name to speed up lookup.
        name=f"_xunit_setup_method_fixture_{self.obj.__qualname__}",
    )
    def xunit_setup_method_fixture(self, request) -> Generator[None, None, None]:
        method = request.function
        if setup_method is not None:
            func = getattr(self, setup_name)
            _call_with_optional_argument(func, method)
            if emit_nose_setup_warning:
>               warnings.warn(
                    NOSE_SUPPORT_METHOD.format(
                        nodeid=request.node.nodeid, method="setup"
                    ),
                    stacklevel=2,
                )
E               pytest.PytestRemovedIn8Warning: Support for nose tests is deprecated and will be removed in a future release.
E               astropy/io/fits/tests/test_table.py::TestTableFunctions::test_table_none is using nose-specific method: `setup(self)`
E               To remove this warning, rename it to `setup_method(self)`
E               See docs: https://docs.pytest.org/en/stable/deprecations.html#support-for-tests-written-for-nose

../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/python.py:898: PytestRemovedIn8Warning
_______ ERROR at setup of TestTableFunctions.test_unncessary_table_load ________

cls = <class '_pytest.runner.CallInfo'>
func = <function call_runtest_hook.<locals>.<lambda> at 0x7d2b55b62d30>
when = 'setup'
reraise = (<class '_pytest.outcomes.Exit'>, <class 'KeyboardInterrupt'>)

    @classmethod
    def from_call(
        cls,
        func: "Callable[[], TResult]",
        when: "Literal['collect', 'setup', 'call', 'teardown']",
        reraise: Optional[
            Union[Type[BaseException], Tuple[Type[BaseException], ...]]
        ] = None,
    ) -> "CallInfo[TResult]":
        """Call func, wrapping the result in a CallInfo.
    
        :param func:
            The function to call. Called without arguments.
        :param when:
            The phase in which the function is called.
        :param reraise:
            Exception or exceptions that shall propagate if raised by the
            function, instead of being wrapped in the CallInfo.
        """
        excinfo = None
        start = timing.time()
        precise_start = timing.perf_counter()
        try:
>           result: Optional[TResult] = func()

../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/runner.py:341: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/runner.py:262: in <lambda>
    lambda: ihook(item=item, **kwds), when=when, reraise=reraise
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/pluggy/_hooks.py:493: in __call__
    return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/pluggy/_manager.py:115: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/runner.py:157: in pytest_runtest_setup
    item.session._setupstate.setup(item)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/runner.py:497: in setup
    raise exc
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/runner.py:494: in setup
    col.setup()
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/python.py:1791: in setup
    self._request._fillfixtures()
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/fixtures.py:566: in _fillfixtures
    item.funcargs[argname] = self.getfixturevalue(argname)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/fixtures.py:585: in getfixturevalue
    fixturedef = self._get_active_fixturedef(argname)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/fixtures.py:607: in _get_active_fixturedef
    self._compute_fixture_value(fixturedef)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/fixtures.py:693: in _compute_fixture_value
    fixturedef.execute(request=subrequest)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/fixtures.py:1069: in execute
    result = ihook.pytest_fixture_setup(fixturedef=self, request=request)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/pluggy/_hooks.py:493: in __call__
    return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/pluggy/_manager.py:115: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/fixtures.py:1123: in pytest_fixture_setup
    result = call_fixture_func(fixturefunc, request, kwargs)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/fixtures.py:895: in call_fixture_func
    fixture_result = next(generator)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <astropy.io.fits.tests.test_table.TestTableFunctions object at 0x7d2b570ea520>
request = <SubRequest '_xunit_setup_method_fixture_TestTableFunctions' for <Function test_unncessary_table_load>>

    @fixtures.fixture(
        autouse=True,
        scope="function",
        # Use a unique name to speed up lookup.
        name=f"_xunit_setup_method_fixture_{self.obj.__qualname__}",
    )
    def xunit_setup_method_fixture(self, request) -> Generator[None, None, None]:
        method = request.function
        if setup_method is not None:
            func = getattr(self, setup_name)
            _call_with_optional_argument(func, method)
            if emit_nose_setup_warning:
>               warnings.warn(
                    NOSE_SUPPORT_METHOD.format(
                        nodeid=request.node.nodeid, method="setup"
                    ),
                    stacklevel=2,
                )
E               pytest.PytestRemovedIn8Warning: Support for nose tests is deprecated and will be removed in a future release.
E               astropy/io/fits/tests/test_table.py::TestTableFunctions::test_unncessary_table_load is using nose-specific method: `setup(self)`
E               To remove this warning, rename it to `setup_method(self)`
E               See docs: https://docs.pytest.org/en/stable/deprecations.html#support-for-tests-written-for-nose

../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/python.py:898: PytestRemovedIn8Warning
_ ERROR at setup of TestTableFunctions.test_table_from_columns_of_other_table __

cls = <class '_pytest.runner.CallInfo'>
func = <function call_runtest_hook.<locals>.<lambda> at 0x7d2b568ca9d0>
when = 'setup'
reraise = (<class '_pytest.outcomes.Exit'>, <class 'KeyboardInterrupt'>)

    @classmethod
    def from_call(
        cls,
        func: "Callable[[], TResult]",
        when: "Literal['collect', 'setup', 'call', 'teardown']",
        reraise: Optional[
            Union[Type[BaseException], Tuple[Type[BaseException], ...]]
        ] = None,
    ) -> "CallInfo[TResult]":
        """Call func, wrapping the result in a CallInfo.
    
        :param func:
            The function to call. Called without arguments.
        :param when:
            The phase in which the function is called.
        :param reraise:
            Exception or exceptions that shall propagate if raised by the
            function, instead of being wrapped in the CallInfo.
        """
        excinfo = None
        start = timing.time()
        precise_start = timing.perf_counter()
        try:
>           result: Optional[TResult] = func()

../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/runner.py:341: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/runner.py:262: in <lambda>
    lambda: ihook(item=item, **kwds), when=when, reraise=reraise
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/pluggy/_hooks.py:493: in __call__
    return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/pluggy/_manager.py:115: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/runner.py:157: in pytest_runtest_setup
    item.session._setupstate.setup(item)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/runner.py:497: in setup
    raise exc
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/runner.py:494: in setup
    col.setup()
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/python.py:1791: in setup
    self._request._fillfixtures()
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/fixtures.py:566: in _fillfixtures
    item.funcargs[argname] = self.getfixturevalue(argname)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/fixtures.py:585: in getfixturevalue
    fixturedef = self._get_active_fixturedef(argname)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/fixtures.py:607: in _get_active_fixturedef
    self._compute_fixture_value(fixturedef)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/fixtures.py:693: in _compute_fixture_value
    fixturedef.execute(request=subrequest)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/fixtures.py:1069: in execute
    result = ihook.pytest_fixture_setup(fixturedef=self, request=request)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/pluggy/_hooks.py:493: in __call__
    return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/pluggy/_manager.py:115: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/fixtures.py:1123: in pytest_fixture_setup
    result = call_fixture_func(fixturefunc, request, kwargs)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/fixtures.py:895: in call_fixture_func
    fixture_result = next(generator)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <astropy.io.fits.tests.test_table.TestTableFunctions object at 0x7d2b570bec40>
request = <SubRequest '_xunit_setup_method_fixture_TestTableFunctions' for <Function test_table_from_columns_of_other_table>>

    @fixtures.fixture(
        autouse=True,
        scope="function",
        # Use a unique name to speed up lookup.
        name=f"_xunit_setup_method_fixture_{self.obj.__qualname__}",
    )
    def xunit_setup_method_fixture(self, request) -> Generator[None, None, None]:
        method = request.function
        if setup_method is not None:
            func = getattr(self, setup_name)
            _call_with_optional_argument(func, method)
            if emit_nose_setup_warning:
>               warnings.warn(
                    NOSE_SUPPORT_METHOD.format(
                        nodeid=request.node.nodeid, method="setup"
                    ),
                    stacklevel=2,
                )
E               pytest.PytestRemovedIn8Warning: Support for nose tests is deprecated and will be removed in a future release.
E               astropy/io/fits/tests/test_table.py::TestTableFunctions::test_table_from_columns_of_other_table is using nose-specific method: `setup(self)`
E               To remove this warning, rename it to `setup_method(self)`
E               See docs: https://docs.pytest.org/en/stable/deprecations.html#support-for-tests-written-for-nose

../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/python.py:898: PytestRemovedIn8Warning
_______ ERROR at setup of TestTableFunctions.test_bintable_to_asciitable _______

cls = <class '_pytest.runner.CallInfo'>
func = <function call_runtest_hook.<locals>.<lambda> at 0x7d2b564a6e50>
when = 'setup'
reraise = (<class '_pytest.outcomes.Exit'>, <class 'KeyboardInterrupt'>)

    @classmethod
    def from_call(
        cls,
        func: "Callable[[], TResult]",
        when: "Literal['collect', 'setup', 'call', 'teardown']",
        reraise: Optional[
            Union[Type[BaseException], Tuple[Type[BaseException], ...]]
        ] = None,
    ) -> "CallInfo[TResult]":
        """Call func, wrapping the result in a CallInfo.
    
        :param func:
            The function to call. Called without arguments.
        :param when:
            The phase in which the function is called.
        :param reraise:
            Exception or exceptions that shall propagate if raised by the
            function, instead of being wrapped in the CallInfo.
        """
        excinfo = None
        start = timing.time()
        precise_start = timing.perf_counter()
        try:
>           result: Optional[TResult] = func()

../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/runner.py:341: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/runner.py:262: in <lambda>
    lambda: ihook(item=item, **kwds), when=when, reraise=reraise
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/pluggy/_hooks.py:493: in __call__
    return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/pluggy/_manager.py:115: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/runner.py:157: in pytest_runtest_setup
    item.session._setupstate.setup(item)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/runner.py:497: in setup
    raise exc
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/runner.py:494: in setup
    col.setup()
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/python.py:1791: in setup
    self._request._fillfixtures()
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/fixtures.py:566: in _fillfixtures
    item.funcargs[argname] = self.getfixturevalue(argname)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/fixtures.py:585: in getfixturevalue
    fixturedef = self._get_active_fixturedef(argname)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/fixtures.py:607: in _get_active_fixturedef
    self._compute_fixture_value(fixturedef)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/fixtures.py:693: in _compute_fixture_value
    fixturedef.execute(request=subrequest)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/fixtures.py:1069: in execute
    result = ihook.pytest_fixture_setup(fixturedef=self, request=request)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/pluggy/_hooks.py:493: in __call__
    return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/pluggy/_manager.py:115: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/fixtures.py:1123: in pytest_fixture_setup
    result = call_fixture_func(fixturefunc, request, kwargs)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/fixtures.py:895: in call_fixture_func
    fixture_result = next(generator)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <astropy.io.fits.tests.test_table.TestTableFunctions object at 0x7d2b570c4640>
request = <SubRequest '_xunit_setup_method_fixture_TestTableFunctions' for <Function test_bintable_to_asciitable>>

    @fixtures.fixture(
        autouse=True,
        scope="function",
        # Use a unique name to speed up lookup.
        name=f"_xunit_setup_method_fixture_{self.obj.__qualname__}",
    )
    def xunit_setup_method_fixture(self, request) -> Generator[None, None, None]:
        method = request.function
        if setup_method is not None:
            func = getattr(self, setup_name)
            _call_with_optional_argument(func, method)
            if emit_nose_setup_warning:
>               warnings.warn(
                    NOSE_SUPPORT_METHOD.format(
                        nodeid=request.node.nodeid, method="setup"
                    ),
                    stacklevel=2,
                )
E               pytest.PytestRemovedIn8Warning: Support for nose tests is deprecated and will be removed in a future release.
E               astropy/io/fits/tests/test_table.py::TestTableFunctions::test_bintable_to_asciitable is using nose-specific method: `setup(self)`
E               To remove this warning, rename it to `setup_method(self)`
E               See docs: https://docs.pytest.org/en/stable/deprecations.html#support-for-tests-written-for-nose

../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/python.py:898: PytestRemovedIn8Warning
_______________ ERROR at setup of TestTableFunctions.test_pickle _______________

cls = <class '_pytest.runner.CallInfo'>
func = <function call_runtest_hook.<locals>.<lambda> at 0x7d2b55b62700>
when = 'setup'
reraise = (<class '_pytest.outcomes.Exit'>, <class 'KeyboardInterrupt'>)

    @classmethod
    def from_call(
        cls,
        func: "Callable[[], TResult]",
        when: "Literal['collect', 'setup', 'call', 'teardown']",
        reraise: Optional[
            Union[Type[BaseException], Tuple[Type[BaseException], ...]]
        ] = None,
    ) -> "CallInfo[TResult]":
        """Call func, wrapping the result in a CallInfo.
    
        :param func:
            The function to call. Called without arguments.
        :param when:
            The phase in which the function is called.
        :param reraise:
            Exception or exceptions that shall propagate if raised by the
            function, instead of being wrapped in the CallInfo.
        """
        excinfo = None
        start = timing.time()
        precise_start = timing.perf_counter()
        try:
>           result: Optional[TResult] = func()

../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/runner.py:341: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/runner.py:262: in <lambda>
    lambda: ihook(item=item, **kwds), when=when, reraise=reraise
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/pluggy/_hooks.py:493: in __call__
    return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/pluggy/_manager.py:115: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/runner.py:157: in pytest_runtest_setup
    item.session._setupstate.setup(item)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/runner.py:497: in setup
    raise exc
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/runner.py:494: in setup
    col.setup()
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/python.py:1791: in setup
    self._request._fillfixtures()
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/fixtures.py:566: in _fillfixtures
    item.funcargs[argname] = self.getfixturevalue(argname)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/fixtures.py:585: in getfixturevalue
    fixturedef = self._get_active_fixturedef(argname)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/fixtures.py:607: in _get_active_fixturedef
    self._compute_fixture_value(fixturedef)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/fixtures.py:693: in _compute_fixture_value
    fixturedef.execute(request=subrequest)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/fixtures.py:1069: in execute
    result = ihook.pytest_fixture_setup(fixturedef=self, request=request)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/pluggy/_hooks.py:493: in __call__
    return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/pluggy/_manager.py:115: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/fixtures.py:1123: in pytest_fixture_setup
    result = call_fixture_func(fixturefunc, request, kwargs)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/fixtures.py:895: in call_fixture_func
    fixture_result = next(generator)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <astropy.io.fits.tests.test_table.TestTableFunctions object at 0x7d2b570c4a00>
request = <SubRequest '_xunit_setup_method_fixture_TestTableFunctions' for <Function test_pickle>>

    @fixtures.fixture(
        autouse=True,
        scope="function",
        # Use a unique name to speed up lookup.
        name=f"_xunit_setup_method_fixture_{self.obj.__qualname__}",
    )
    def xunit_setup_method_fixture(self, request) -> Generator[None, None, None]:
        method = request.function
        if setup_method is not None:
            func = getattr(self, setup_name)
            _call_with_optional_argument(func, method)
            if emit_nose_setup_warning:
>               warnings.warn(
                    NOSE_SUPPORT_METHOD.format(
                        nodeid=request.node.nodeid, method="setup"
                    ),
                    stacklevel=2,
                )
E               pytest.PytestRemovedIn8Warning: Support for nose tests is deprecated and will be removed in a future release.
E               astropy/io/fits/tests/test_table.py::TestTableFunctions::test_pickle is using nose-specific method: `setup(self)`
E               To remove this warning, rename it to `setup_method(self)`
E               See docs: https://docs.pytest.org/en/stable/deprecations.html#support-for-tests-written-for-nose

../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/python.py:898: PytestRemovedIn8Warning
_________ ERROR at setup of TestTableFunctions.test_zero_length_table __________

cls = <class '_pytest.runner.CallInfo'>
func = <function call_runtest_hook.<locals>.<lambda> at 0x7d2b564b3d30>
when = 'setup'
reraise = (<class '_pytest.outcomes.Exit'>, <class 'KeyboardInterrupt'>)

    @classmethod
    def from_call(
        cls,
        func: "Callable[[], TResult]",
        when: "Literal['collect', 'setup', 'call', 'teardown']",
        reraise: Optional[
            Union[Type[BaseException], Tuple[Type[BaseException], ...]]
        ] = None,
    ) -> "CallInfo[TResult]":
        """Call func, wrapping the result in a CallInfo.
    
        :param func:
            The function to call. Called without arguments.
        :param when:
            The phase in which the function is called.
        :param reraise:
            Exception or exceptions that shall propagate if raised by the
            function, instead of being wrapped in the CallInfo.
        """
        excinfo = None
        start = timing.time()
        precise_start = timing.perf_counter()
        try:
>           result: Optional[TResult] = func()

../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/runner.py:341: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/runner.py:262: in <lambda>
    lambda: ihook(item=item, **kwds), when=when, reraise=reraise
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/pluggy/_hooks.py:493: in __call__
    return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/pluggy/_manager.py:115: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/runner.py:157: in pytest_runtest_setup
    item.session._setupstate.setup(item)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/runner.py:497: in setup
    raise exc
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/runner.py:494: in setup
    col.setup()
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/python.py:1791: in setup
    self._request._fillfixtures()
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/fixtures.py:566: in _fillfixtures
    item.funcargs[argname] = self.getfixturevalue(argname)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/fixtures.py:585: in getfixturevalue
    fixturedef = self._get_active_fixturedef(argname)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/fixtures.py:607: in _get_active_fixturedef
    self._compute_fixture_value(fixturedef)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/fixtures.py:693: in _compute_fixture_value
    fixturedef.execute(request=subrequest)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/fixtures.py:1069: in execute
    result = ihook.pytest_fixture_setup(fixturedef=self, request=request)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/pluggy/_hooks.py:493: in __call__
    return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/pluggy/_manager.py:115: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/fixtures.py:1123: in pytest_fixture_setup
    result = call_fixture_func(fixturefunc, request, kwargs)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/fixtures.py:895: in call_fixture_func
    fixture_result = next(generator)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <astropy.io.fits.tests.test_table.TestTableFunctions object at 0x7d2b570c4e20>
request = <SubRequest '_xunit_setup_method_fixture_TestTableFunctions' for <Function test_zero_length_table>>

    @fixtures.fixture(
        autouse=True,
        scope="function",
        # Use a unique name to speed up lookup.
        name=f"_xunit_setup_method_fixture_{self.obj.__qualname__}",
    )
    def xunit_setup_method_fixture(self, request) -> Generator[None, None, None]:
        method = request.function
        if setup_method is not None:
            func = getattr(self, setup_name)
            _call_with_optional_argument(func, method)
            if emit_nose_setup_warning:
>               warnings.warn(
                    NOSE_SUPPORT_METHOD.format(
                        nodeid=request.node.nodeid, method="setup"
                    ),
                    stacklevel=2,
                )
E               pytest.PytestRemovedIn8Warning: Support for nose tests is deprecated and will be removed in a future release.
E               astropy/io/fits/tests/test_table.py::TestTableFunctions::test_zero_length_table is using nose-specific method: `setup(self)`
E               To remove this warning, rename it to `setup_method(self)`
E               See docs: https://docs.pytest.org/en/stable/deprecations.html#support-for-tests-written-for-nose

../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/python.py:898: PytestRemovedIn8Warning
___ ERROR at setup of TestTableFunctions.test_dim_column_byte_order_mismatch ___

cls = <class '_pytest.runner.CallInfo'>
func = <function call_runtest_hook.<locals>.<lambda> at 0x7d2b564b3dc0>
when = 'setup'
reraise = (<class '_pytest.outcomes.Exit'>, <class 'KeyboardInterrupt'>)

    @classmethod
    def from_call(
        cls,
        func: "Callable[[], TResult]",
        when: "Literal['collect', 'setup', 'call', 'teardown']",
        reraise: Optional[
            Union[Type[BaseException], Tuple[Type[BaseException], ...]]
        ] = None,
    ) -> "CallInfo[TResult]":
        """Call func, wrapping the result in a CallInfo.
    
        :param func:
            The function to call. Called without arguments.
        :param when:
            The phase in which the function is called.
        :param reraise:
            Exception or exceptions that shall propagate if raised by the
            function, instead of being wrapped in the CallInfo.
        """
        excinfo = None
        start = timing.time()
        precise_start = timing.perf_counter()
        try:
>           result: Optional[TResult] = func()

../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/runner.py:341: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/runner.py:262: in <lambda>
    lambda: ihook(item=item, **kwds), when=when, reraise=reraise
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/pluggy/_hooks.py:493: in __call__
    return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/pluggy/_manager.py:115: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/runner.py:157: in pytest_runtest_setup
    item.session._setupstate.setup(item)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/runner.py:497: in setup
    raise exc
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/runner.py:494: in setup
    col.setup()
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/python.py:1791: in setup
    self._request._fillfixtures()
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/fixtures.py:566: in _fillfixtures
    item.funcargs[argname] = self.getfixturevalue(argname)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/fixtures.py:585: in getfixturevalue
    fixturedef = self._get_active_fixturedef(argname)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/fixtures.py:607: in _get_active_fixturedef
    self._compute_fixture_value(fixturedef)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/fixtures.py:693: in _compute_fixture_value
    fixturedef.execute(request=subrequest)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/fixtures.py:1069: in execute
    result = ihook.pytest_fixture_setup(fixturedef=self, request=request)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/pluggy/_hooks.py:493: in __call__
    return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/pluggy/_manager.py:115: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/fixtures.py:1123: in pytest_fixture_setup
    result = call_fixture_func(fixturefunc, request, kwargs)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/fixtures.py:895: in call_fixture_func
    fixture_result = next(generator)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <astropy.io.fits.tests.test_table.TestTableFunctions object at 0x7d2b570c4970>
request = <SubRequest '_xunit_setup_method_fixture_TestTableFunctions' for <Function test_dim_column_byte_order_mismatch>>

    @fixtures.fixture(
        autouse=True,
        scope="function",
        # Use a unique name to speed up lookup.
        name=f"_xunit_setup_method_fixture_{self.obj.__qualname__}",
    )
    def xunit_setup_method_fixture(self, request) -> Generator[None, None, None]:
        method = request.function
        if setup_method is not None:
            func = getattr(self, setup_name)
            _call_with_optional_argument(func, method)
            if emit_nose_setup_warning:
>               warnings.warn(
                    NOSE_SUPPORT_METHOD.format(
                        nodeid=request.node.nodeid, method="setup"
                    ),
                    stacklevel=2,
                )
E               pytest.PytestRemovedIn8Warning: Support for nose tests is deprecated and will be removed in a future release.
E               astropy/io/fits/tests/test_table.py::TestTableFunctions::test_dim_column_byte_order_mismatch is using nose-specific method: `setup(self)`
E               To remove this warning, rename it to `setup_method(self)`
E               See docs: https://docs.pytest.org/en/stable/deprecations.html#support-for-tests-written-for-nose

../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/python.py:898: PytestRemovedIn8Warning
_______ ERROR at setup of TestTableFunctions.test_fits_rec_from_existing _______

cls = <class '_pytest.runner.CallInfo'>
func = <function call_runtest_hook.<locals>.<lambda> at 0x7d2b564bd040>
when = 'setup'
reraise = (<class '_pytest.outcomes.Exit'>, <class 'KeyboardInterrupt'>)

    @classmethod
    def from_call(
        cls,
        func: "Callable[[], TResult]",
        when: "Literal['collect', 'setup', 'call', 'teardown']",
        reraise: Optional[
            Union[Type[BaseException], Tuple[Type[BaseException], ...]]
        ] = None,
    ) -> "CallInfo[TResult]":
        """Call func, wrapping the result in a CallInfo.
    
        :param func:
            The function to call. Called without arguments.
        :param when:
            The phase in which the function is called.
        :param reraise:
            Exception or exceptions that shall propagate if raised by the
            function, instead of being wrapped in the CallInfo.
        """
        excinfo = None
        start = timing.time()
        precise_start = timing.perf_counter()
        try:
>           result: Optional[TResult] = func()

../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/runner.py:341: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/runner.py:262: in <lambda>
    lambda: ihook(item=item, **kwds), when=when, reraise=reraise
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/pluggy/_hooks.py:493: in __call__
    return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/pluggy/_manager.py:115: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/runner.py:157: in pytest_runtest_setup
    item.session._setupstate.setup(item)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/runner.py:497: in setup
    raise exc
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/runner.py:494: in setup
    col.setup()
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/python.py:1791: in setup
    self._request._fillfixtures()
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/fixtures.py:566: in _fillfixtures
    item.funcargs[argname] = self.getfixturevalue(argname)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/fixtures.py:585: in getfixturevalue
    fixturedef = self._get_active_fixturedef(argname)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/fixtures.py:607: in _get_active_fixturedef
    self._compute_fixture_value(fixturedef)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/fixtures.py:693: in _compute_fixture_value
    fixturedef.execute(request=subrequest)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/fixtures.py:1069: in execute
    result = ihook.pytest_fixture_setup(fixturedef=self, request=request)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/pluggy/_hooks.py:493: in __call__
    return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/pluggy/_manager.py:115: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/fixtures.py:1123: in pytest_fixture_setup
    result = call_fixture_func(fixturefunc, request, kwargs)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/fixtures.py:895: in call_fixture_func
    fixture_result = next(generator)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <astropy.io.fits.tests.test_table.TestTableFunctions object at 0x7d2b5703fe50>
request = <SubRequest '_xunit_setup_method_fixture_TestTableFunctions' for <Function test_fits_rec_from_existing>>

    @fixtures.fixture(
        autouse=True,
        scope="function",
        # Use a unique name to speed up lookup.
        name=f"_xunit_setup_method_fixture_{self.obj.__qualname__}",
    )
    def xunit_setup_method_fixture(self, request) -> Generator[None, None, None]:
        method = request.function
        if setup_method is not None:
            func = getattr(self, setup_name)
            _call_with_optional_argument(func, method)
            if emit_nose_setup_warning:
>               warnings.warn(
                    NOSE_SUPPORT_METHOD.format(
                        nodeid=request.node.nodeid, method="setup"
                    ),
                    stacklevel=2,
                )
E               pytest.PytestRemovedIn8Warning: Support for nose tests is deprecated and will be removed in a future release.
E               astropy/io/fits/tests/test_table.py::TestTableFunctions::test_fits_rec_from_existing is using nose-specific method: `setup(self)`
E               To remove this warning, rename it to `setup_method(self)`
E               See docs: https://docs.pytest.org/en/stable/deprecations.html#support-for-tests-written-for-nose

../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/python.py:898: PytestRemovedIn8Warning
____ ERROR at setup of TestTableFunctions.test_update_string_column_inplace ____

cls = <class '_pytest.runner.CallInfo'>
func = <function call_runtest_hook.<locals>.<lambda> at 0x7d2b564baa60>
when = 'setup'
reraise = (<class '_pytest.outcomes.Exit'>, <class 'KeyboardInterrupt'>)

    @classmethod
    def from_call(
        cls,
        func: "Callable[[], TResult]",
        when: "Literal['collect', 'setup', 'call', 'teardown']",
        reraise: Optional[
            Union[Type[BaseException], Tuple[Type[BaseException], ...]]
        ] = None,
    ) -> "CallInfo[TResult]":
        """Call func, wrapping the result in a CallInfo.
    
        :param func:
            The function to call. Called without arguments.
        :param when:
            The phase in which the function is called.
        :param reraise:
            Exception or exceptions that shall propagate if raised by the
            function, instead of being wrapped in the CallInfo.
        """
        excinfo = None
        start = timing.time()
        precise_start = timing.perf_counter()
        try:
>           result: Optional[TResult] = func()

../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/runner.py:341: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/runner.py:262: in <lambda>
    lambda: ihook(item=item, **kwds), when=when, reraise=reraise
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/pluggy/_hooks.py:493: in __call__
    return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/pluggy/_manager.py:115: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/runner.py:157: in pytest_runtest_setup
    item.session._setupstate.setup(item)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/runner.py:497: in setup
    raise exc
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/runner.py:494: in setup
    col.setup()
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/python.py:1791: in setup
    self._request._fillfixtures()
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/fixtures.py:566: in _fillfixtures
    item.funcargs[argname] = self.getfixturevalue(argname)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/fixtures.py:585: in getfixturevalue
    fixturedef = self._get_active_fixturedef(argname)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/fixtures.py:607: in _get_active_fixturedef
    self._compute_fixture_value(fixturedef)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/fixtures.py:693: in _compute_fixture_value
    fixturedef.execute(request=subrequest)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/fixtures.py:1069: in execute
    result = ihook.pytest_fixture_setup(fixturedef=self, request=request)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/pluggy/_hooks.py:493: in __call__
    return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/pluggy/_manager.py:115: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/fixtures.py:1123: in pytest_fixture_setup
    result = call_fixture_func(fixturefunc, request, kwargs)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/fixtures.py:895: in call_fixture_func
    fixture_result = next(generator)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <astropy.io.fits.tests.test_table.TestTableFunctions object at 0x7d2b56d7d160>
request = <SubRequest '_xunit_setup_method_fixture_TestTableFunctions' for <Function test_update_string_column_inplace>>

    @fixtures.fixture(
        autouse=True,
        scope="function",
        # Use a unique name to speed up lookup.
        name=f"_xunit_setup_method_fixture_{self.obj.__qualname__}",
    )
    def xunit_setup_method_fixture(self, request) -> Generator[None, None, None]:
        method = request.function
        if setup_method is not None:
            func = getattr(self, setup_name)
            _call_with_optional_argument(func, method)
            if emit_nose_setup_warning:
>               warnings.warn(
                    NOSE_SUPPORT_METHOD.format(
                        nodeid=request.node.nodeid, method="setup"
                    ),
                    stacklevel=2,
                )
E               pytest.PytestRemovedIn8Warning: Support for nose tests is deprecated and will be removed in a future release.
E               astropy/io/fits/tests/test_table.py::TestTableFunctions::test_update_string_column_inplace is using nose-specific method: `setup(self)`
E               To remove this warning, rename it to `setup_method(self)`
E               See docs: https://docs.pytest.org/en/stable/deprecations.html#support-for-tests-written-for-nose

../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/python.py:898: PytestRemovedIn8Warning
_____ ERROR at setup of TestTableFunctions.test_dump_clobber_vs_overwrite ______

cls = <class '_pytest.runner.CallInfo'>
func = <function call_runtest_hook.<locals>.<lambda> at 0x7d2b564ba1f0>
when = 'setup'
reraise = (<class '_pytest.outcomes.Exit'>, <class 'KeyboardInterrupt'>)

    @classmethod
    def from_call(
        cls,
        func: "Callable[[], TResult]",
        when: "Literal['collect', 'setup', 'call', 'teardown']",
        reraise: Optional[
            Union[Type[BaseException], Tuple[Type[BaseException], ...]]
        ] = None,
    ) -> "CallInfo[TResult]":
        """Call func, wrapping the result in a CallInfo.
    
        :param func:
            The function to call. Called without arguments.
        :param when:
            The phase in which the function is called.
        :param reraise:
            Exception or exceptions that shall propagate if raised by the
            function, instead of being wrapped in the CallInfo.
        """
        excinfo = None
        start = timing.time()
        precise_start = timing.perf_counter()
        try:
>           result: Optional[TResult] = func()

../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/runner.py:341: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/runner.py:262: in <lambda>
    lambda: ihook(item=item, **kwds), when=when, reraise=reraise
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/pluggy/_hooks.py:493: in __call__
    return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/pluggy/_manager.py:115: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/runner.py:157: in pytest_runtest_setup
    item.session._setupstate.setup(item)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/runner.py:497: in setup
    raise exc
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/runner.py:494: in setup
    col.setup()
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/python.py:1791: in setup
    self._request._fillfixtures()
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/fixtures.py:566: in _fillfixtures
    item.funcargs[argname] = self.getfixturevalue(argname)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/fixtures.py:585: in getfixturevalue
    fixturedef = self._get_active_fixturedef(argname)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/fixtures.py:607: in _get_active_fixturedef
    self._compute_fixture_value(fixturedef)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/fixtures.py:693: in _compute_fixture_value
    fixturedef.execute(request=subrequest)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/fixtures.py:1069: in execute
    result = ihook.pytest_fixture_setup(fixturedef=self, request=request)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/pluggy/_hooks.py:493: in __call__
    return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/pluggy/_manager.py:115: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/fixtures.py:1123: in pytest_fixture_setup
    result = call_fixture_func(fixturefunc, request, kwargs)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/fixtures.py:895: in call_fixture_func
    fixture_result = next(generator)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <astropy.io.fits.tests.test_table.TestTableFunctions object at 0x7d2b56d7d8e0>
request = <SubRequest '_xunit_setup_method_fixture_TestTableFunctions' for <Function test_dump_clobber_vs_overwrite>>

    @fixtures.fixture(
        autouse=True,
        scope="function",
        # Use a unique name to speed up lookup.
        name=f"_xunit_setup_method_fixture_{self.obj.__qualname__}",
    )
    def xunit_setup_method_fixture(self, request) -> Generator[None, None, None]:
        method = request.function
        if setup_method is not None:
            func = getattr(self, setup_name)
            _call_with_optional_argument(func, method)
            if emit_nose_setup_warning:
>               warnings.warn(
                    NOSE_SUPPORT_METHOD.format(
                        nodeid=request.node.nodeid, method="setup"
                    ),
                    stacklevel=2,
                )
E               pytest.PytestRemovedIn8Warning: Support for nose tests is deprecated and will be removed in a future release.
E               astropy/io/fits/tests/test_table.py::TestTableFunctions::test_dump_clobber_vs_overwrite is using nose-specific method: `setup(self)`
E               To remove this warning, rename it to `setup_method(self)`
E               See docs: https://docs.pytest.org/en/stable/deprecations.html#support-for-tests-written-for-nose

../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/python.py:898: PytestRemovedIn8Warning
_________ ERROR at setup of TestVLATables.test_variable_length_columns _________

cls = <class '_pytest.runner.CallInfo'>
func = <function call_runtest_hook.<locals>.<lambda> at 0x7d2b564bf280>
when = 'setup'
reraise = (<class '_pytest.outcomes.Exit'>, <class 'KeyboardInterrupt'>)

    @classmethod
    def from_call(
        cls,
        func: "Callable[[], TResult]",
        when: "Literal['collect', 'setup', 'call', 'teardown']",
        reraise: Optional[
            Union[Type[BaseException], Tuple[Type[BaseException], ...]]
        ] = None,
    ) -> "CallInfo[TResult]":
        """Call func, wrapping the result in a CallInfo.
    
        :param func:
            The function to call. Called without arguments.
        :param when:
            The phase in which the function is called.
        :param reraise:
            Exception or exceptions that shall propagate if raised by the
            function, instead of being wrapped in the CallInfo.
        """
        excinfo = None
        start = timing.time()
        precise_start = timing.perf_counter()
        try:
>           result: Optional[TResult] = func()

../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/runner.py:341: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/runner.py:262: in <lambda>
    lambda: ihook(item=item, **kwds), when=when, reraise=reraise
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/pluggy/_hooks.py:493: in __call__
    return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/pluggy/_manager.py:115: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/runner.py:157: in pytest_runtest_setup
    item.session._setupstate.setup(item)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/runner.py:497: in setup
    raise exc
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/runner.py:494: in setup
    col.setup()
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/python.py:1791: in setup
    self._request._fillfixtures()
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/fixtures.py:566: in _fillfixtures
    item.funcargs[argname] = self.getfixturevalue(argname)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/fixtures.py:585: in getfixturevalue
    fixturedef = self._get_active_fixturedef(argname)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/fixtures.py:607: in _get_active_fixturedef
    self._compute_fixture_value(fixturedef)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/fixtures.py:693: in _compute_fixture_value
    fixturedef.execute(request=subrequest)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/fixtures.py:1069: in execute
    result = ihook.pytest_fixture_setup(fixturedef=self, request=request)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/pluggy/_hooks.py:493: in __call__
    return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/pluggy/_manager.py:115: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/fixtures.py:1123: in pytest_fixture_setup
    result = call_fixture_func(fixturefunc, request, kwargs)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/fixtures.py:895: in call_fixture_func
    fixture_result = next(generator)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <astropy.io.fits.tests.test_table.TestVLATables object at 0x7d2b56d431f0>
request = <SubRequest '_xunit_setup_method_fixture_TestVLATables' for <Function test_variable_length_columns>>

    @fixtures.fixture(
        autouse=True,
        scope="function",
        # Use a unique name to speed up lookup.
        name=f"_xunit_setup_method_fixture_{self.obj.__qualname__}",
    )
    def xunit_setup_method_fixture(self, request) -> Generator[None, None, None]:
        method = request.function
        if setup_method is not None:
            func = getattr(self, setup_name)
            _call_with_optional_argument(func, method)
            if emit_nose_setup_warning:
>               warnings.warn(
                    NOSE_SUPPORT_METHOD.format(
                        nodeid=request.node.nodeid, method="setup"
                    ),
                    stacklevel=2,
                )
E               pytest.PytestRemovedIn8Warning: Support for nose tests is deprecated and will be removed in a future release.
E               astropy/io/fits/tests/test_table.py::TestVLATables::test_variable_length_columns is using nose-specific method: `setup(self)`
E               To remove this warning, rename it to `setup_method(self)`
E               See docs: https://docs.pytest.org/en/stable/deprecations.html#support-for-tests-written-for-nose

../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/python.py:898: PytestRemovedIn8Warning
______ ERROR at setup of TestVLATables.test_extend_variable_length_array _______

cls = <class '_pytest.runner.CallInfo'>
func = <function call_runtest_hook.<locals>.<lambda> at 0x7d2b564bfc10>
when = 'setup'
reraise = (<class '_pytest.outcomes.Exit'>, <class 'KeyboardInterrupt'>)

    @classmethod
    def from_call(
        cls,
        func: "Callable[[], TResult]",
        when: "Literal['collect', 'setup', 'call', 'teardown']",
        reraise: Optional[
            Union[Type[BaseException], Tuple[Type[BaseException], ...]]
        ] = None,
    ) -> "CallInfo[TResult]":
        """Call func, wrapping the result in a CallInfo.
    
        :param func:
            The function to call. Called without arguments.
        :param when:
            The phase in which the function is called.
        :param reraise:
            Exception or exceptions that shall propagate if raised by the
            function, instead of being wrapped in the CallInfo.
        """
        excinfo = None
        start = timing.time()
        precise_start = timing.perf_counter()
        try:
>           result: Optional[TResult] = func()

../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/runner.py:341: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/runner.py:262: in <lambda>
    lambda: ihook(item=item, **kwds), when=when, reraise=reraise
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/pluggy/_hooks.py:493: in __call__
    return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/pluggy/_manager.py:115: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/runner.py:157: in pytest_runtest_setup
    item.session._setupstate.setup(item)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/runner.py:497: in setup
    raise exc
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/runner.py:494: in setup
    col.setup()
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/python.py:1791: in setup
    self._request._fillfixtures()
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/fixtures.py:566: in _fillfixtures
    item.funcargs[argname] = self.getfixturevalue(argname)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/fixtures.py:585: in getfixturevalue
    fixturedef = self._get_active_fixturedef(argname)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/fixtures.py:607: in _get_active_fixturedef
    self._compute_fixture_value(fixturedef)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/fixtures.py:693: in _compute_fixture_value
    fixturedef.execute(request=subrequest)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/fixtures.py:1069: in execute
    result = ihook.pytest_fixture_setup(fixturedef=self, request=request)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/pluggy/_hooks.py:493: in __call__
    return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/pluggy/_manager.py:115: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/fixtures.py:1123: in pytest_fixture_setup
    result = call_fixture_func(fixturefunc, request, kwargs)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/fixtures.py:895: in call_fixture_func
    fixture_result = next(generator)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <astropy.io.fits.tests.test_table.TestVLATables object at 0x7d2b56d40820>
request = <SubRequest '_xunit_setup_method_fixture_TestVLATables' for <Function test_extend_variable_length_array>>

    @fixtures.fixture(
        autouse=True,
        scope="function",
        # Use a unique name to speed up lookup.
        name=f"_xunit_setup_method_fixture_{self.obj.__qualname__}",
    )
    def xunit_setup_method_fixture(self, request) -> Generator[None, None, None]:
        method = request.function
        if setup_method is not None:
            func = getattr(self, setup_name)
            _call_with_optional_argument(func, method)
            if emit_nose_setup_warning:
>               warnings.warn(
                    NOSE_SUPPORT_METHOD.format(
                        nodeid=request.node.nodeid, method="setup"
                    ),
                    stacklevel=2,
                )
E               pytest.PytestRemovedIn8Warning: Support for nose tests is deprecated and will be removed in a future release.
E               astropy/io/fits/tests/test_table.py::TestVLATables::test_extend_variable_length_array is using nose-specific method: `setup(self)`
E               To remove this warning, rename it to `setup_method(self)`
E               See docs: https://docs.pytest.org/en/stable/deprecations.html#support-for-tests-written-for-nose

../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/python.py:898: PytestRemovedIn8Warning
_ ERROR at setup of TestVLATables.test_variable_length_table_format_pd_from_object_array _

cls = <class '_pytest.runner.CallInfo'>
func = <function call_runtest_hook.<locals>.<lambda> at 0x7d2b56b5a550>
when = 'setup'
reraise = (<class '_pytest.outcomes.Exit'>, <class 'KeyboardInterrupt'>)

    @classmethod
    def from_call(
        cls,
        func: "Callable[[], TResult]",
        when: "Literal['collect', 'setup', 'call', 'teardown']",
        reraise: Optional[
            Union[Type[BaseException], Tuple[Type[BaseException], ...]]
        ] = None,
    ) -> "CallInfo[TResult]":
        """Call func, wrapping the result in a CallInfo.
    
        :param func:
            The function to call. Called without arguments.
        :param when:
            The phase in which the function is called.
        :param reraise:
            Exception or exceptions that shall propagate if raised by the
            function, instead of being wrapped in the CallInfo.
        """
        excinfo = None
        start = timing.time()
        precise_start = timing.perf_counter()
        try:
>           result: Optional[TResult] = func()

../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/runner.py:341: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/runner.py:262: in <lambda>
    lambda: ihook(item=item, **kwds), when=when, reraise=reraise
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/pluggy/_hooks.py:493: in __call__
    return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/pluggy/_manager.py:115: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/runner.py:157: in pytest_runtest_setup
    item.session._setupstate.setup(item)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/runner.py:497: in setup
    raise exc
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/runner.py:494: in setup
    col.setup()
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/python.py:1791: in setup
    self._request._fillfixtures()
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/fixtures.py:566: in _fillfixtures
    item.funcargs[argname] = self.getfixturevalue(argname)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/fixtures.py:585: in getfixturevalue
    fixturedef = self._get_active_fixturedef(argname)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/fixtures.py:607: in _get_active_fixturedef
    self._compute_fixture_value(fixturedef)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/fixtures.py:693: in _compute_fixture_value
    fixturedef.execute(request=subrequest)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/fixtures.py:1069: in execute
    result = ihook.pytest_fixture_setup(fixturedef=self, request=request)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/pluggy/_hooks.py:493: in __call__
    return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/pluggy/_manager.py:115: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/fixtures.py:1123: in pytest_fixture_setup
    result = call_fixture_func(fixturefunc, request, kwargs)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/fixtures.py:895: in call_fixture_func
    fixture_result = next(generator)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <astropy.io.fits.tests.test_table.TestVLATables object at 0x7d2b56d40ee0>
request = <SubRequest '_xunit_setup_method_fixture_TestVLATables' for <Function test_variable_length_table_format_pd_from_object_array>>

    @fixtures.fixture(
        autouse=True,
        scope="function",
        # Use a unique name to speed up lookup.
        name=f"_xunit_setup_method_fixture_{self.obj.__qualname__}",
    )
    def xunit_setup_method_fixture(self, request) -> Generator[None, None, None]:
        method = request.function
        if setup_method is not None:
            func = getattr(self, setup_name)
            _call_with_optional_argument(func, method)
            if emit_nose_setup_warning:
>               warnings.warn(
                    NOSE_SUPPORT_METHOD.format(
                        nodeid=request.node.nodeid, method="setup"
                    ),
                    stacklevel=2,
                )
E               pytest.PytestRemovedIn8Warning: Support for nose tests is deprecated and will be removed in a future release.
E               astropy/io/fits/tests/test_table.py::TestVLATables::test_variable_length_table_format_pd_from_object_array is using nose-specific method: `setup(self)`
E               To remove this warning, rename it to `setup_method(self)`
E               See docs: https://docs.pytest.org/en/stable/deprecations.html#support-for-tests-written-for-nose

../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/python.py:898: PytestRemovedIn8Warning
_ ERROR at setup of TestVLATables.test_variable_length_table_format_pd_from_list _

cls = <class '_pytest.runner.CallInfo'>
func = <function call_runtest_hook.<locals>.<lambda> at 0x7d2b56b5a040>
when = 'setup'
reraise = (<class '_pytest.outcomes.Exit'>, <class 'KeyboardInterrupt'>)

    @classmethod
    def from_call(
        cls,
        func: "Callable[[], TResult]",
        when: "Literal['collect', 'setup', 'call', 'teardown']",
        reraise: Optional[
            Union[Type[BaseException], Tuple[Type[BaseException], ...]]
        ] = None,
    ) -> "CallInfo[TResult]":
        """Call func, wrapping the result in a CallInfo.
    
        :param func:
            The function to call. Called without arguments.
        :param when:
            The phase in which the function is called.
        :param reraise:
            Exception or exceptions that shall propagate if raised by the
            function, instead of being wrapped in the CallInfo.
        """
        excinfo = None
        start = timing.time()
        precise_start = timing.perf_counter()
        try:
>           result: Optional[TResult] = func()

../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/runner.py:341: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/runner.py:262: in <lambda>
    lambda: ihook(item=item, **kwds), when=when, reraise=reraise
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/pluggy/_hooks.py:493: in __call__
    return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/pluggy/_manager.py:115: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/runner.py:157: in pytest_runtest_setup
    item.session._setupstate.setup(item)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/runner.py:497: in setup
    raise exc
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/runner.py:494: in setup
    col.setup()
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/python.py:1791: in setup
    self._request._fillfixtures()
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/fixtures.py:566: in _fillfixtures
    item.funcargs[argname] = self.getfixturevalue(argname)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/fixtures.py:585: in getfixturevalue
    fixturedef = self._get_active_fixturedef(argname)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/fixtures.py:607: in _get_active_fixturedef
    self._compute_fixture_value(fixturedef)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/fixtures.py:693: in _compute_fixture_value
    fixturedef.execute(request=subrequest)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/fixtures.py:1069: in execute
    result = ihook.pytest_fixture_setup(fixturedef=self, request=request)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/pluggy/_hooks.py:493: in __call__
    return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/pluggy/_manager.py:115: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/fixtures.py:1123: in pytest_fixture_setup
    result = call_fixture_func(fixturefunc, request, kwargs)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/fixtures.py:895: in call_fixture_func
    fixture_result = next(generator)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <astropy.io.fits.tests.test_table.TestVLATables object at 0x7d2b56d404c0>
request = <SubRequest '_xunit_setup_method_fixture_TestVLATables' for <Function test_variable_length_table_format_pd_from_list>>

    @fixtures.fixture(
        autouse=True,
        scope="function",
        # Use a unique name to speed up lookup.
        name=f"_xunit_setup_method_fixture_{self.obj.__qualname__}",
    )
    def xunit_setup_method_fixture(self, request) -> Generator[None, None, None]:
        method = request.function
        if setup_method is not None:
            func = getattr(self, setup_name)
            _call_with_optional_argument(func, method)
            if emit_nose_setup_warning:
>               warnings.warn(
                    NOSE_SUPPORT_METHOD.format(
                        nodeid=request.node.nodeid, method="setup"
                    ),
                    stacklevel=2,
                )
E               pytest.PytestRemovedIn8Warning: Support for nose tests is deprecated and will be removed in a future release.
E               astropy/io/fits/tests/test_table.py::TestVLATables::test_variable_length_table_format_pd_from_list is using nose-specific method: `setup(self)`
E               To remove this warning, rename it to `setup_method(self)`
E               See docs: https://docs.pytest.org/en/stable/deprecations.html#support-for-tests-written-for-nose

../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/python.py:898: PytestRemovedIn8Warning
_ ERROR at setup of TestVLATables.test_variable_length_table_format_pa_from_object_array _

cls = <class '_pytest.runner.CallInfo'>
func = <function call_runtest_hook.<locals>.<lambda> at 0x7d2b56b5a0d0>
when = 'setup'
reraise = (<class '_pytest.outcomes.Exit'>, <class 'KeyboardInterrupt'>)

    @classmethod
    def from_call(
        cls,
        func: "Callable[[], TResult]",
        when: "Literal['collect', 'setup', 'call', 'teardown']",
        reraise: Optional[
            Union[Type[BaseException], Tuple[Type[BaseException], ...]]
        ] = None,
    ) -> "CallInfo[TResult]":
        """Call func, wrapping the result in a CallInfo.
    
        :param func:
            The function to call. Called without arguments.
        :param when:
            The phase in which the function is called.
        :param reraise:
            Exception or exceptions that shall propagate if raised by the
            function, instead of being wrapped in the CallInfo.
        """
        excinfo = None
        start = timing.time()
        precise_start = timing.perf_counter()
        try:
>           result: Optional[TResult] = func()

../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/runner.py:341: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/runner.py:262: in <lambda>
    lambda: ihook(item=item, **kwds), when=when, reraise=reraise
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/pluggy/_hooks.py:493: in __call__
    return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/pluggy/_manager.py:115: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/runner.py:157: in pytest_runtest_setup
    item.session._setupstate.setup(item)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/runner.py:497: in setup
    raise exc
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/runner.py:494: in setup
    col.setup()
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/python.py:1791: in setup
    self._request._fillfixtures()
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/fixtures.py:566: in _fillfixtures
    item.funcargs[argname] = self.getfixturevalue(argname)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/fixtures.py:585: in getfixturevalue
    fixturedef = self._get_active_fixturedef(argname)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/fixtures.py:607: in _get_active_fixturedef
    self._compute_fixture_value(fixturedef)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/fixtures.py:693: in _compute_fixture_value
    fixturedef.execute(request=subrequest)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/fixtures.py:1069: in execute
    result = ihook.pytest_fixture_setup(fixturedef=self, request=request)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/pluggy/_hooks.py:493: in __call__
    return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/pluggy/_manager.py:115: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/fixtures.py:1123: in pytest_fixture_setup
    result = call_fixture_func(fixturefunc, request, kwargs)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/fixtures.py:895: in call_fixture_func
    fixture_result = next(generator)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <astropy.io.fits.tests.test_table.TestVLATables object at 0x7d2b56d559a0>
request = <SubRequest '_xunit_setup_method_fixture_TestVLATables' for <Function test_variable_length_table_format_pa_from_object_array>>

    @fixtures.fixture(
        autouse=True,
        scope="function",
        # Use a unique name to speed up lookup.
        name=f"_xunit_setup_method_fixture_{self.obj.__qualname__}",
    )
    def xunit_setup_method_fixture(self, request) -> Generator[None, None, None]:
        method = request.function
        if setup_method is not None:
            func = getattr(self, setup_name)
            _call_with_optional_argument(func, method)
            if emit_nose_setup_warning:
>               warnings.warn(
                    NOSE_SUPPORT_METHOD.format(
                        nodeid=request.node.nodeid, method="setup"
                    ),
                    stacklevel=2,
                )
E               pytest.PytestRemovedIn8Warning: Support for nose tests is deprecated and will be removed in a future release.
E               astropy/io/fits/tests/test_table.py::TestVLATables::test_variable_length_table_format_pa_from_object_array is using nose-specific method: `setup(self)`
E               To remove this warning, rename it to `setup_method(self)`
E               See docs: https://docs.pytest.org/en/stable/deprecations.html#support-for-tests-written-for-nose

../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/python.py:898: PytestRemovedIn8Warning
_ ERROR at setup of TestVLATables.test_variable_length_table_format_pa_from_list _

cls = <class '_pytest.runner.CallInfo'>
func = <function call_runtest_hook.<locals>.<lambda> at 0x7d2b56199040>
when = 'setup'
reraise = (<class '_pytest.outcomes.Exit'>, <class 'KeyboardInterrupt'>)

    @classmethod
    def from_call(
        cls,
        func: "Callable[[], TResult]",
        when: "Literal['collect', 'setup', 'call', 'teardown']",
        reraise: Optional[
            Union[Type[BaseException], Tuple[Type[BaseException], ...]]
        ] = None,
    ) -> "CallInfo[TResult]":
        """Call func, wrapping the result in a CallInfo.
    
        :param func:
            The function to call. Called without arguments.
        :param when:
            The phase in which the function is called.
        :param reraise:
            Exception or exceptions that shall propagate if raised by the
            function, instead of being wrapped in the CallInfo.
        """
        excinfo = None
        start = timing.time()
        precise_start = timing.perf_counter()
        try:
>           result: Optional[TResult] = func()

../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/runner.py:341: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/runner.py:262: in <lambda>
    lambda: ihook(item=item, **kwds), when=when, reraise=reraise
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/pluggy/_hooks.py:493: in __call__
    return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/pluggy/_manager.py:115: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/runner.py:157: in pytest_runtest_setup
    item.session._setupstate.setup(item)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/runner.py:497: in setup
    raise exc
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/runner.py:494: in setup
    col.setup()
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/python.py:1791: in setup
    self._request._fillfixtures()
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/fixtures.py:566: in _fillfixtures
    item.funcargs[argname] = self.getfixturevalue(argname)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/fixtures.py:585: in getfixturevalue
    fixturedef = self._get_active_fixturedef(argname)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/fixtures.py:607: in _get_active_fixturedef
    self._compute_fixture_value(fixturedef)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/fixtures.py:693: in _compute_fixture_value
    fixturedef.execute(request=subrequest)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/fixtures.py:1069: in execute
    result = ihook.pytest_fixture_setup(fixturedef=self, request=request)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/pluggy/_hooks.py:493: in __call__
    return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/pluggy/_manager.py:115: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/fixtures.py:1123: in pytest_fixture_setup
    result = call_fixture_func(fixturefunc, request, kwargs)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/fixtures.py:895: in call_fixture_func
    fixture_result = next(generator)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <astropy.io.fits.tests.test_table.TestVLATables object at 0x7d2b56d401c0>
request = <SubRequest '_xunit_setup_method_fixture_TestVLATables' for <Function test_variable_length_table_format_pa_from_list>>

    @fixtures.fixture(
        autouse=True,
        scope="function",
        # Use a unique name to speed up lookup.
        name=f"_xunit_setup_method_fixture_{self.obj.__qualname__}",
    )
    def xunit_setup_method_fixture(self, request) -> Generator[None, None, None]:
        method = request.function
        if setup_method is not None:
            func = getattr(self, setup_name)
            _call_with_optional_argument(func, method)
            if emit_nose_setup_warning:
>               warnings.warn(
                    NOSE_SUPPORT_METHOD.format(
                        nodeid=request.node.nodeid, method="setup"
                    ),
                    stacklevel=2,
                )
E               pytest.PytestRemovedIn8Warning: Support for nose tests is deprecated and will be removed in a future release.
E               astropy/io/fits/tests/test_table.py::TestVLATables::test_variable_length_table_format_pa_from_list is using nose-specific method: `setup(self)`
E               To remove this warning, rename it to `setup_method(self)`
E               See docs: https://docs.pytest.org/en/stable/deprecations.html#support-for-tests-written-for-nose

../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/python.py:898: PytestRemovedIn8Warning
_______________ ERROR at setup of TestVLATables.test_getdata_vla _______________

cls = <class '_pytest.runner.CallInfo'>
func = <function call_runtest_hook.<locals>.<lambda> at 0x7d2b56199ee0>
when = 'setup'
reraise = (<class '_pytest.outcomes.Exit'>, <class 'KeyboardInterrupt'>)

    @classmethod
    def from_call(
        cls,
        func: "Callable[[], TResult]",
        when: "Literal['collect', 'setup', 'call', 'teardown']",
        reraise: Optional[
            Union[Type[BaseException], Tuple[Type[BaseException], ...]]
        ] = None,
    ) -> "CallInfo[TResult]":
        """Call func, wrapping the result in a CallInfo.
    
        :param func:
            The function to call. Called without arguments.
        :param when:
            The phase in which the function is called.
        :param reraise:
            Exception or exceptions that shall propagate if raised by the
            function, instead of being wrapped in the CallInfo.
        """
        excinfo = None
        start = timing.time()
        precise_start = timing.perf_counter()
        try:
>           result: Optional[TResult] = func()

../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/runner.py:341: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/runner.py:262: in <lambda>
    lambda: ihook(item=item, **kwds), when=when, reraise=reraise
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/pluggy/_hooks.py:493: in __call__
    return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/pluggy/_manager.py:115: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/runner.py:157: in pytest_runtest_setup
    item.session._setupstate.setup(item)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/runner.py:497: in setup
    raise exc
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/runner.py:494: in setup
    col.setup()
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/python.py:1791: in setup
    self._request._fillfixtures()
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/fixtures.py:566: in _fillfixtures
    item.funcargs[argname] = self.getfixturevalue(argname)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/fixtures.py:585: in getfixturevalue
    fixturedef = self._get_active_fixturedef(argname)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/fixtures.py:607: in _get_active_fixturedef
    self._compute_fixture_value(fixturedef)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/fixtures.py:693: in _compute_fixture_value
    fixturedef.execute(request=subrequest)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/fixtures.py:1069: in execute
    result = ihook.pytest_fixture_setup(fixturedef=self, request=request)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/pluggy/_hooks.py:493: in __call__
    return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/pluggy/_manager.py:115: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/fixtures.py:1123: in pytest_fixture_setup
    result = call_fixture_func(fixturefunc, request, kwargs)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/fixtures.py:895: in call_fixture_func
    fixture_result = next(generator)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <astropy.io.fits.tests.test_table.TestVLATables object at 0x7d2b56d43ca0>
request = <SubRequest '_xunit_setup_method_fixture_TestVLATables' for <Function test_getdata_vla>>

    @fixtures.fixture(
        autouse=True,
        scope="function",
        # Use a unique name to speed up lookup.
        name=f"_xunit_setup_method_fixture_{self.obj.__qualname__}",
    )
    def xunit_setup_method_fixture(self, request) -> Generator[None, None, None]:
        method = request.function
        if setup_method is not None:
            func = getattr(self, setup_name)
            _call_with_optional_argument(func, method)
            if emit_nose_setup_warning:
>               warnings.warn(
                    NOSE_SUPPORT_METHOD.format(
                        nodeid=request.node.nodeid, method="setup"
                    ),
                    stacklevel=2,
                )
E               pytest.PytestRemovedIn8Warning: Support for nose tests is deprecated and will be removed in a future release.
E               astropy/io/fits/tests/test_table.py::TestVLATables::test_getdata_vla is using nose-specific method: `setup(self)`
E               To remove this warning, rename it to `setup_method(self)`
E               See docs: https://docs.pytest.org/en/stable/deprecations.html#support-for-tests-written-for-nose

../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/python.py:898: PytestRemovedIn8Warning
________________ ERROR at setup of TestVLATables.test_copy_vla _________________

cls = <class '_pytest.runner.CallInfo'>
func = <function call_runtest_hook.<locals>.<lambda> at 0x7d2b56b5a8b0>
when = 'setup'
reraise = (<class '_pytest.outcomes.Exit'>, <class 'KeyboardInterrupt'>)

    @classmethod
    def from_call(
        cls,
        func: "Callable[[], TResult]",
        when: "Literal['collect', 'setup', 'call', 'teardown']",
        reraise: Optional[
            Union[Type[BaseException], Tuple[Type[BaseException], ...]]
        ] = None,
    ) -> "CallInfo[TResult]":
        """Call func, wrapping the result in a CallInfo.
    
        :param func:
            The function to call. Called without arguments.
        :param when:
            The phase in which the function is called.
        :param reraise:
            Exception or exceptions that shall propagate if raised by the
            function, instead of being wrapped in the CallInfo.
        """
        excinfo = None
        start = timing.time()
        precise_start = timing.perf_counter()
        try:
>           result: Optional[TResult] = func()

../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/runner.py:341: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/runner.py:262: in <lambda>
    lambda: ihook(item=item, **kwds), when=when, reraise=reraise
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/pluggy/_hooks.py:493: in __call__
    return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/pluggy/_manager.py:115: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/runner.py:157: in pytest_runtest_setup
    item.session._setupstate.setup(item)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/runner.py:497: in setup
    raise exc
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/runner.py:494: in setup
    col.setup()
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/python.py:1791: in setup
    self._request._fillfixtures()
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/fixtures.py:566: in _fillfixtures
    item.funcargs[argname] = self.getfixturevalue(argname)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/fixtures.py:585: in getfixturevalue
    fixturedef = self._get_active_fixturedef(argname)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/fixtures.py:607: in _get_active_fixturedef
    self._compute_fixture_value(fixturedef)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/fixtures.py:693: in _compute_fixture_value
    fixturedef.execute(request=subrequest)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/fixtures.py:1069: in execute
    result = ihook.pytest_fixture_setup(fixturedef=self, request=request)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/pluggy/_hooks.py:493: in __call__
    return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/pluggy/_manager.py:115: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/fixtures.py:1123: in pytest_fixture_setup
    result = call_fixture_func(fixturefunc, request, kwargs)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/fixtures.py:895: in call_fixture_func
    fixture_result = next(generator)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <astropy.io.fits.tests.test_table.TestVLATables object at 0x7d2b56d7d550>
request = <SubRequest '_xunit_setup_method_fixture_TestVLATables' for <Function test_copy_vla>>

    @fixtures.fixture(
        autouse=True,
        scope="function",
        # Use a unique name to speed up lookup.
        name=f"_xunit_setup_method_fixture_{self.obj.__qualname__}",
    )
    def xunit_setup_method_fixture(self, request) -> Generator[None, None, None]:
        method = request.function
        if setup_method is not None:
            func = getattr(self, setup_name)
            _call_with_optional_argument(func, method)
            if emit_nose_setup_warning:
>               warnings.warn(
                    NOSE_SUPPORT_METHOD.format(
                        nodeid=request.node.nodeid, method="setup"
                    ),
                    stacklevel=2,
                )
E               pytest.PytestRemovedIn8Warning: Support for nose tests is deprecated and will be removed in a future release.
E               astropy/io/fits/tests/test_table.py::TestVLATables::test_copy_vla is using nose-specific method: `setup(self)`
E               To remove this warning, rename it to `setup_method(self)`
E               See docs: https://docs.pytest.org/en/stable/deprecations.html#support-for-tests-written-for-nose

../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/python.py:898: PytestRemovedIn8Warning
___ ERROR at setup of TestColumnFunctions.test_column_format_interpretation ____

cls = <class '_pytest.runner.CallInfo'>
func = <function call_runtest_hook.<locals>.<lambda> at 0x7d2b568d2700>
when = 'setup'
reraise = (<class '_pytest.outcomes.Exit'>, <class 'KeyboardInterrupt'>)

    @classmethod
    def from_call(
        cls,
        func: "Callable[[], TResult]",
        when: "Literal['collect', 'setup', 'call', 'teardown']",
        reraise: Optional[
            Union[Type[BaseException], Tuple[Type[BaseException], ...]]
        ] = None,
    ) -> "CallInfo[TResult]":
        """Call func, wrapping the result in a CallInfo.
    
        :param func:
            The function to call. Called without arguments.
        :param when:
            The phase in which the function is called.
        :param reraise:
            Exception or exceptions that shall propagate if raised by the
            function, instead of being wrapped in the CallInfo.
        """
        excinfo = None
        start = timing.time()
        precise_start = timing.perf_counter()
        try:
>           result: Optional[TResult] = func()

../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/runner.py:341: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/runner.py:262: in <lambda>
    lambda: ihook(item=item, **kwds), when=when, reraise=reraise
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/pluggy/_hooks.py:493: in __call__
    return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/pluggy/_manager.py:115: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/runner.py:157: in pytest_runtest_setup
    item.session._setupstate.setup(item)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/runner.py:497: in setup
    raise exc
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/runner.py:494: in setup
    col.setup()
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/python.py:1791: in setup
    self._request._fillfixtures()
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/fixtures.py:566: in _fillfixtures
    item.funcargs[argname] = self.getfixturevalue(argname)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/fixtures.py:585: in getfixturevalue
    fixturedef = self._get_active_fixturedef(argname)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/fixtures.py:607: in _get_active_fixturedef
    self._compute_fixture_value(fixturedef)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/fixtures.py:693: in _compute_fixture_value
    fixturedef.execute(request=subrequest)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/fixtures.py:1069: in execute
    result = ihook.pytest_fixture_setup(fixturedef=self, request=request)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/pluggy/_hooks.py:493: in __call__
    return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/pluggy/_manager.py:115: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/fixtures.py:1123: in pytest_fixture_setup
    result = call_fixture_func(fixturefunc, request, kwargs)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/fixtures.py:895: in call_fixture_func
    fixture_result = next(generator)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <astropy.io.fits.tests.test_table.TestColumnFunctions object at 0x7d2b56d55580>
request = <SubRequest '_xunit_setup_method_fixture_TestColumnFunctions' for <Function test_column_format_interpretation>>

    @fixtures.fixture(
        autouse=True,
        scope="function",
        # Use a unique name to speed up lookup.
        name=f"_xunit_setup_method_fixture_{self.obj.__qualname__}",
    )
    def xunit_setup_method_fixture(self, request) -> Generator[None, None, None]:
        method = request.function
        if setup_method is not None:
            func = getattr(self, setup_name)
            _call_with_optional_argument(func, method)
            if emit_nose_setup_warning:
>               warnings.warn(
                    NOSE_SUPPORT_METHOD.format(
                        nodeid=request.node.nodeid, method="setup"
                    ),
                    stacklevel=2,
                )
E               pytest.PytestRemovedIn8Warning: Support for nose tests is deprecated and will be removed in a future release.
E               astropy/io/fits/tests/test_table.py::TestColumnFunctions::test_column_format_interpretation is using nose-specific method: `setup(self)`
E               To remove this warning, rename it to `setup_method(self)`
E               See docs: https://docs.pytest.org/en/stable/deprecations.html#support-for-tests-written-for-nose

../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/python.py:898: PytestRemovedIn8Warning
____ ERROR at setup of TestColumnFunctions.test_zero_precision_float_column ____

cls = <class '_pytest.runner.CallInfo'>
func = <function call_runtest_hook.<locals>.<lambda> at 0x7d2b561ab430>
when = 'setup'
reraise = (<class '_pytest.outcomes.Exit'>, <class 'KeyboardInterrupt'>)

    @classmethod
    def from_call(
        cls,
        func: "Callable[[], TResult]",
        when: "Literal['collect', 'setup', 'call', 'teardown']",
        reraise: Optional[
            Union[Type[BaseException], Tuple[Type[BaseException], ...]]
        ] = None,
    ) -> "CallInfo[TResult]":
        """Call func, wrapping the result in a CallInfo.
    
        :param func:
            The function to call. Called without arguments.
        :param when:
            The phase in which the function is called.
        :param reraise:
            Exception or exceptions that shall propagate if raised by the
            function, instead of being wrapped in the CallInfo.
        """
        excinfo = None
        start = timing.time()
        precise_start = timing.perf_counter()
        try:
>           result: Optional[TResult] = func()

../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/runner.py:341: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/runner.py:262: in <lambda>
    lambda: ihook(item=item, **kwds), when=when, reraise=reraise
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/pluggy/_hooks.py:493: in __call__
    return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/pluggy/_manager.py:115: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/runner.py:157: in pytest_runtest_setup
    item.session._setupstate.setup(item)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/runner.py:497: in setup
    raise exc
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/runner.py:494: in setup
    col.setup()
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/python.py:1791: in setup
    self._request._fillfixtures()
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/fixtures.py:566: in _fillfixtures
    item.funcargs[argname] = self.getfixturevalue(argname)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/fixtures.py:585: in getfixturevalue
    fixturedef = self._get_active_fixturedef(argname)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/fixtures.py:607: in _get_active_fixturedef
    self._compute_fixture_value(fixturedef)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/fixtures.py:693: in _compute_fixture_value
    fixturedef.execute(request=subrequest)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/fixtures.py:1069: in execute
    result = ihook.pytest_fixture_setup(fixturedef=self, request=request)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/pluggy/_hooks.py:493: in __call__
    return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/pluggy/_manager.py:115: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/fixtures.py:1123: in pytest_fixture_setup
    result = call_fixture_func(fixturefunc, request, kwargs)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/fixtures.py:895: in call_fixture_func
    fixture_result = next(generator)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <astropy.io.fits.tests.test_table.TestColumnFunctions object at 0x7d2b56d55cd0>
request = <SubRequest '_xunit_setup_method_fixture_TestColumnFunctions' for <Function test_zero_precision_float_column>>

    @fixtures.fixture(
        autouse=True,
        scope="function",
        # Use a unique name to speed up lookup.
        name=f"_xunit_setup_method_fixture_{self.obj.__qualname__}",
    )
    def xunit_setup_method_fixture(self, request) -> Generator[None, None, None]:
        method = request.function
        if setup_method is not None:
            func = getattr(self, setup_name)
            _call_with_optional_argument(func, method)
            if emit_nose_setup_warning:
>               warnings.warn(
                    NOSE_SUPPORT_METHOD.format(
                        nodeid=request.node.nodeid, method="setup"
                    ),
                    stacklevel=2,
                )
E               pytest.PytestRemovedIn8Warning: Support for nose tests is deprecated and will be removed in a future release.
E               astropy/io/fits/tests/test_table.py::TestColumnFunctions::test_zero_precision_float_column is using nose-specific method: `setup(self)`
E               To remove this warning, rename it to `setup_method(self)`
E               See docs: https://docs.pytest.org/en/stable/deprecations.html#support-for-tests-written-for-nose

../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/python.py:898: PytestRemovedIn8Warning
____ ERROR at setup of TestColumnFunctions.test_column_array_type_mismatch _____

cls = <class '_pytest.runner.CallInfo'>
func = <function call_runtest_hook.<locals>.<lambda> at 0x7d2b56622160>
when = 'setup'
reraise = (<class '_pytest.outcomes.Exit'>, <class 'KeyboardInterrupt'>)

    @classmethod
    def from_call(
        cls,
        func: "Callable[[], TResult]",
        when: "Literal['collect', 'setup', 'call', 'teardown']",
        reraise: Optional[
            Union[Type[BaseException], Tuple[Type[BaseException], ...]]
        ] = None,
    ) -> "CallInfo[TResult]":
        """Call func, wrapping the result in a CallInfo.
    
        :param func:
            The function to call. Called without arguments.
        :param when:
            The phase in which the function is called.
        :param reraise:
            Exception or exceptions that shall propagate if raised by the
            function, instead of being wrapped in the CallInfo.
        """
        excinfo = None
        start = timing.time()
        precise_start = timing.perf_counter()
        try:
>           result: Optional[TResult] = func()

../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/runner.py:341: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/runner.py:262: in <lambda>
    lambda: ihook(item=item, **kwds), when=when, reraise=reraise
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/pluggy/_hooks.py:493: in __call__
    return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/pluggy/_manager.py:115: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/runner.py:157: in pytest_runtest_setup
    item.session._setupstate.setup(item)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/runner.py:497: in setup
    raise exc
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/runner.py:494: in setup
    col.setup()
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/python.py:1791: in setup
    self._request._fillfixtures()
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/fixtures.py:566: in _fillfixtures
    item.funcargs[argname] = self.getfixturevalue(argname)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/fixtures.py:585: in getfixturevalue
    fixturedef = self._get_active_fixturedef(argname)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/fixtures.py:607: in _get_active_fixturedef
    self._compute_fixture_value(fixturedef)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/fixtures.py:693: in _compute_fixture_value
    fixturedef.execute(request=subrequest)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/fixtures.py:1069: in execute
    result = ihook.pytest_fixture_setup(fixturedef=self, request=request)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/pluggy/_hooks.py:493: in __call__
    return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/pluggy/_manager.py:115: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/fixtures.py:1123: in pytest_fixture_setup
    result = call_fixture_func(fixturefunc, request, kwargs)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/fixtures.py:895: in call_fixture_func
    fixture_result = next(generator)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <astropy.io.fits.tests.test_table.TestColumnFunctions object at 0x7d2b56d559d0>
request = <SubRequest '_xunit_setup_method_fixture_TestColumnFunctions' for <Function test_column_array_type_mismatch>>

    @fixtures.fixture(
        autouse=True,
        scope="function",
        # Use a unique name to speed up lookup.
        name=f"_xunit_setup_method_fixture_{self.obj.__qualname__}",
    )
    def xunit_setup_method_fixture(self, request) -> Generator[None, None, None]:
        method = request.function
        if setup_method is not None:
            func = getattr(self, setup_name)
            _call_with_optional_argument(func, method)
            if emit_nose_setup_warning:
>               warnings.warn(
                    NOSE_SUPPORT_METHOD.format(
                        nodeid=request.node.nodeid, method="setup"
                    ),
                    stacklevel=2,
                )
E               pytest.PytestRemovedIn8Warning: Support for nose tests is deprecated and will be removed in a future release.
E               astropy/io/fits/tests/test_table.py::TestColumnFunctions::test_column_array_type_mismatch is using nose-specific method: `setup(self)`
E               To remove this warning, rename it to `setup_method(self)`
E               See docs: https://docs.pytest.org/en/stable/deprecations.html#support-for-tests-written-for-nose

../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/python.py:898: PytestRemovedIn8Warning
_ ERROR at setup of TestColumnFunctions.test_new_coldefs_with_invalid_seqence __

cls = <class '_pytest.runner.CallInfo'>
func = <function call_runtest_hook.<locals>.<lambda> at 0x7d2b568d29d0>
when = 'setup'
reraise = (<class '_pytest.outcomes.Exit'>, <class 'KeyboardInterrupt'>)

    @classmethod
    def from_call(
        cls,
        func: "Callable[[], TResult]",
        when: "Literal['collect', 'setup', 'call', 'teardown']",
        reraise: Optional[
            Union[Type[BaseException], Tuple[Type[BaseException], ...]]
        ] = None,
    ) -> "CallInfo[TResult]":
        """Call func, wrapping the result in a CallInfo.
    
        :param func:
            The function to call. Called without arguments.
        :param when:
            The phase in which the function is called.
        :param reraise:
            Exception or exceptions that shall propagate if raised by the
            function, instead of being wrapped in the CallInfo.
        """
        excinfo = None
        start = timing.time()
        precise_start = timing.perf_counter()
        try:
>           result: Optional[TResult] = func()

../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/runner.py:341: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/runner.py:262: in <lambda>
    lambda: ihook(item=item, **kwds), when=when, reraise=reraise
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/pluggy/_hooks.py:493: in __call__
    return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/pluggy/_manager.py:115: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/runner.py:157: in pytest_runtest_setup
    item.session._setupstate.setup(item)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/runner.py:497: in setup
    raise exc
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/runner.py:494: in setup
    col.setup()
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/python.py:1791: in setup
    self._request._fillfixtures()
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/fixtures.py:566: in _fillfixtures
    item.funcargs[argname] = self.getfixturevalue(argname)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/fixtures.py:585: in getfixturevalue
    fixturedef = self._get_active_fixturedef(argname)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/fixtures.py:607: in _get_active_fixturedef
    self._compute_fixture_value(fixturedef)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/fixtures.py:693: in _compute_fixture_value
    fixturedef.execute(request=subrequest)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/fixtures.py:1069: in execute
    result = ihook.pytest_fixture_setup(fixturedef=self, request=request)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/pluggy/_hooks.py:493: in __call__
    return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/pluggy/_manager.py:115: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/fixtures.py:1123: in pytest_fixture_setup
    result = call_fixture_func(fixturefunc, request, kwargs)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/fixtures.py:895: in call_fixture_func
    fixture_result = next(generator)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <astropy.io.fits.tests.test_table.TestColumnFunctions object at 0x7d2b56d55220>
request = <SubRequest '_xunit_setup_method_fixture_TestColumnFunctions' for <Function test_new_coldefs_with_invalid_seqence>>

    @fixtures.fixture(
        autouse=True,
        scope="function",
        # Use a unique name to speed up lookup.
        name=f"_xunit_setup_method_fixture_{self.obj.__qualname__}",
    )
    def xunit_setup_method_fixture(self, request) -> Generator[None, None, None]:
        method = request.function
        if setup_method is not None:
            func = getattr(self, setup_name)
            _call_with_optional_argument(func, method)
            if emit_nose_setup_warning:
>               warnings.warn(
                    NOSE_SUPPORT_METHOD.format(
                        nodeid=request.node.nodeid, method="setup"
                    ),
                    stacklevel=2,
                )
E               pytest.PytestRemovedIn8Warning: Support for nose tests is deprecated and will be removed in a future release.
E               astropy/io/fits/tests/test_table.py::TestColumnFunctions::test_new_coldefs_with_invalid_seqence is using nose-specific method: `setup(self)`
E               To remove this warning, rename it to `setup_method(self)`
E               See docs: https://docs.pytest.org/en/stable/deprecations.html#support-for-tests-written-for-nose

../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/python.py:898: PytestRemovedIn8Warning
______________ ERROR at setup of TestColumnFunctions.test_pickle _______________

cls = <class '_pytest.runner.CallInfo'>
func = <function call_runtest_hook.<locals>.<lambda> at 0x7d2b561ab430>
when = 'setup'
reraise = (<class '_pytest.outcomes.Exit'>, <class 'KeyboardInterrupt'>)

    @classmethod
    def from_call(
        cls,
        func: "Callable[[], TResult]",
        when: "Literal['collect', 'setup', 'call', 'teardown']",
        reraise: Optional[
            Union[Type[BaseException], Tuple[Type[BaseException], ...]]
        ] = None,
    ) -> "CallInfo[TResult]":
        """Call func, wrapping the result in a CallInfo.
    
        :param func:
            The function to call. Called without arguments.
        :param when:
            The phase in which the function is called.
        :param reraise:
            Exception or exceptions that shall propagate if raised by the
            function, instead of being wrapped in the CallInfo.
        """
        excinfo = None
        start = timing.time()
        precise_start = timing.perf_counter()
        try:
>           result: Optional[TResult] = func()

../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/runner.py:341: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/runner.py:262: in <lambda>
    lambda: ihook(item=item, **kwds), when=when, reraise=reraise
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/pluggy/_hooks.py:493: in __call__
    return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/pluggy/_manager.py:115: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/runner.py:157: in pytest_runtest_setup
    item.session._setupstate.setup(item)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/runner.py:497: in setup
    raise exc
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/runner.py:494: in setup
    col.setup()
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/python.py:1791: in setup
    self._request._fillfixtures()
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/fixtures.py:566: in _fillfixtures
    item.funcargs[argname] = self.getfixturevalue(argname)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/fixtures.py:585: in getfixturevalue
    fixturedef = self._get_active_fixturedef(argname)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/fixtures.py:607: in _get_active_fixturedef
    self._compute_fixture_value(fixturedef)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/fixtures.py:693: in _compute_fixture_value
    fixturedef.execute(request=subrequest)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/fixtures.py:1069: in execute
    result = ihook.pytest_fixture_setup(fixturedef=self, request=request)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/pluggy/_hooks.py:493: in __call__
    return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/pluggy/_manager.py:115: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/fixtures.py:1123: in pytest_fixture_setup
    result = call_fixture_func(fixturefunc, request, kwargs)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/fixtures.py:895: in call_fixture_func
    fixture_result = next(generator)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <astropy.io.fits.tests.test_table.TestColumnFunctions object at 0x7d2b56d5fc10>
request = <SubRequest '_xunit_setup_method_fixture_TestColumnFunctions' for <Function test_pickle>>

    @fixtures.fixture(
        autouse=True,
        scope="function",
        # Use a unique name to speed up lookup.
        name=f"_xunit_setup_method_fixture_{self.obj.__qualname__}",
    )
    def xunit_setup_method_fixture(self, request) -> Generator[None, None, None]:
        method = request.function
        if setup_method is not None:
            func = getattr(self, setup_name)
            _call_with_optional_argument(func, method)
            if emit_nose_setup_warning:
>               warnings.warn(
                    NOSE_SUPPORT_METHOD.format(
                        nodeid=request.node.nodeid, method="setup"
                    ),
                    stacklevel=2,
                )
E               pytest.PytestRemovedIn8Warning: Support for nose tests is deprecated and will be removed in a future release.
E               astropy/io/fits/tests/test_table.py::TestColumnFunctions::test_pickle is using nose-specific method: `setup(self)`
E               To remove this warning, rename it to `setup_method(self)`
E               See docs: https://docs.pytest.org/en/stable/deprecations.html#support-for-tests-written-for-nose

../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/python.py:898: PytestRemovedIn8Warning
_______ ERROR at setup of TestColumnFunctions.test_column_lookup_by_name _______

cls = <class '_pytest.runner.CallInfo'>
func = <function call_runtest_hook.<locals>.<lambda> at 0x7d2b565518b0>
when = 'setup'
reraise = (<class '_pytest.outcomes.Exit'>, <class 'KeyboardInterrupt'>)

    @classmethod
    def from_call(
        cls,
        func: "Callable[[], TResult]",
        when: "Literal['collect', 'setup', 'call', 'teardown']",
        reraise: Optional[
            Union[Type[BaseException], Tuple[Type[BaseException], ...]]
        ] = None,
    ) -> "CallInfo[TResult]":
        """Call func, wrapping the result in a CallInfo.
    
        :param func:
            The function to call. Called without arguments.
        :param when:
            The phase in which the function is called.
        :param reraise:
            Exception or exceptions that shall propagate if raised by the
            function, instead of being wrapped in the CallInfo.
        """
        excinfo = None
        start = timing.time()
        precise_start = timing.perf_counter()
        try:
>           result: Optional[TResult] = func()

../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/runner.py:341: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/runner.py:262: in <lambda>
    lambda: ihook(item=item, **kwds), when=when, reraise=reraise
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/pluggy/_hooks.py:493: in __call__
    return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/pluggy/_manager.py:115: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/runner.py:157: in pytest_runtest_setup
    item.session._setupstate.setup(item)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/runner.py:497: in setup
    raise exc
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/runner.py:494: in setup
    col.setup()
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/python.py:1791: in setup
    self._request._fillfixtures()
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/fixtures.py:566: in _fillfixtures
    item.funcargs[argname] = self.getfixturevalue(argname)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/fixtures.py:585: in getfixturevalue
    fixturedef = self._get_active_fixturedef(argname)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/fixtures.py:607: in _get_active_fixturedef
    self._compute_fixture_value(fixturedef)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/fixtures.py:693: in _compute_fixture_value
    fixturedef.execute(request=subrequest)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/fixtures.py:1069: in execute
    result = ihook.pytest_fixture_setup(fixturedef=self, request=request)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/pluggy/_hooks.py:493: in __call__
    return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/pluggy/_manager.py:115: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/fixtures.py:1123: in pytest_fixture_setup
    result = call_fixture_func(fixturefunc, request, kwargs)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/fixtures.py:895: in call_fixture_func
    fixture_result = next(generator)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <astropy.io.fits.tests.test_table.TestColumnFunctions object at 0x7d2b56d5f9d0>
request = <SubRequest '_xunit_setup_method_fixture_TestColumnFunctions' for <Function test_column_lookup_by_name>>

    @fixtures.fixture(
        autouse=True,
        scope="function",
        # Use a unique name to speed up lookup.
        name=f"_xunit_setup_method_fixture_{self.obj.__qualname__}",
    )
    def xunit_setup_method_fixture(self, request) -> Generator[None, None, None]:
        method = request.function
        if setup_method is not None:
            func = getattr(self, setup_name)
            _call_with_optional_argument(func, method)
            if emit_nose_setup_warning:
>               warnings.warn(
                    NOSE_SUPPORT_METHOD.format(
                        nodeid=request.node.nodeid, method="setup"
                    ),
                    stacklevel=2,
                )
E               pytest.PytestRemovedIn8Warning: Support for nose tests is deprecated and will be removed in a future release.
E               astropy/io/fits/tests/test_table.py::TestColumnFunctions::test_column_lookup_by_name is using nose-specific method: `setup(self)`
E               To remove this warning, rename it to `setup_method(self)`
E               See docs: https://docs.pytest.org/en/stable/deprecations.html#support-for-tests-written-for-nose

../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/python.py:898: PytestRemovedIn8Warning
_ ERROR at setup of TestColumnFunctions.test_column_attribute_change_after_removal _

cls = <class '_pytest.runner.CallInfo'>
func = <function call_runtest_hook.<locals>.<lambda> at 0x7d2b55bb9670>
when = 'setup'
reraise = (<class '_pytest.outcomes.Exit'>, <class 'KeyboardInterrupt'>)

    @classmethod
    def from_call(
        cls,
        func: "Callable[[], TResult]",
        when: "Literal['collect', 'setup', 'call', 'teardown']",
        reraise: Optional[
            Union[Type[BaseException], Tuple[Type[BaseException], ...]]
        ] = None,
    ) -> "CallInfo[TResult]":
        """Call func, wrapping the result in a CallInfo.
    
        :param func:
            The function to call. Called without arguments.
        :param when:
            The phase in which the function is called.
        :param reraise:
            Exception or exceptions that shall propagate if raised by the
            function, instead of being wrapped in the CallInfo.
        """
        excinfo = None
        start = timing.time()
        precise_start = timing.perf_counter()
        try:
>           result: Optional[TResult] = func()

../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/runner.py:341: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/runner.py:262: in <lambda>
    lambda: ihook(item=item, **kwds), when=when, reraise=reraise
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/pluggy/_hooks.py:493: in __call__
    return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/pluggy/_manager.py:115: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/runner.py:157: in pytest_runtest_setup
    item.session._setupstate.setup(item)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/runner.py:497: in setup
    raise exc
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/runner.py:494: in setup
    col.setup()
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/python.py:1791: in setup
    self._request._fillfixtures()
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/fixtures.py:566: in _fillfixtures
    item.funcargs[argname] = self.getfixturevalue(argname)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/fixtures.py:585: in getfixturevalue
    fixturedef = self._get_active_fixturedef(argname)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/fixtures.py:607: in _get_active_fixturedef
    self._compute_fixture_value(fixturedef)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/fixtures.py:693: in _compute_fixture_value
    fixturedef.execute(request=subrequest)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/fixtures.py:1069: in execute
    result = ihook.pytest_fixture_setup(fixturedef=self, request=request)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/pluggy/_hooks.py:493: in __call__
    return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/pluggy/_manager.py:115: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/fixtures.py:1123: in pytest_fixture_setup
    result = call_fixture_func(fixturefunc, request, kwargs)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/fixtures.py:895: in call_fixture_func
    fixture_result = next(generator)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <astropy.io.fits.tests.test_table.TestColumnFunctions object at 0x7d2b56d5fb50>
request = <SubRequest '_xunit_setup_method_fixture_TestColumnFunctions' for <Function test_column_attribute_change_after_removal>>

    @fixtures.fixture(
        autouse=True,
        scope="function",
        # Use a unique name to speed up lookup.
        name=f"_xunit_setup_method_fixture_{self.obj.__qualname__}",
    )
    def xunit_setup_method_fixture(self, request) -> Generator[None, None, None]:
        method = request.function
        if setup_method is not None:
            func = getattr(self, setup_name)
            _call_with_optional_argument(func, method)
            if emit_nose_setup_warning:
>               warnings.warn(
                    NOSE_SUPPORT_METHOD.format(
                        nodeid=request.node.nodeid, method="setup"
                    ),
                    stacklevel=2,
                )
E               pytest.PytestRemovedIn8Warning: Support for nose tests is deprecated and will be removed in a future release.
E               astropy/io/fits/tests/test_table.py::TestColumnFunctions::test_column_attribute_change_after_removal is using nose-specific method: `setup(self)`
E               To remove this warning, rename it to `setup_method(self)`
E               See docs: https://docs.pytest.org/en/stable/deprecations.html#support-for-tests-written-for-nose

../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/python.py:898: PytestRemovedIn8Warning
_________ ERROR at setup of TestColumnFunctions.test_x_column_deepcopy _________

cls = <class '_pytest.runner.CallInfo'>
func = <function call_runtest_hook.<locals>.<lambda> at 0x7d2b561abc10>
when = 'setup'
reraise = (<class '_pytest.outcomes.Exit'>, <class 'KeyboardInterrupt'>)

    @classmethod
    def from_call(
        cls,
        func: "Callable[[], TResult]",
        when: "Literal['collect', 'setup', 'call', 'teardown']",
        reraise: Optional[
            Union[Type[BaseException], Tuple[Type[BaseException], ...]]
        ] = None,
    ) -> "CallInfo[TResult]":
        """Call func, wrapping the result in a CallInfo.
    
        :param func:
            The function to call. Called without arguments.
        :param when:
            The phase in which the function is called.
        :param reraise:
            Exception or exceptions that shall propagate if raised by the
            function, instead of being wrapped in the CallInfo.
        """
        excinfo = None
        start = timing.time()
        precise_start = timing.perf_counter()
        try:
>           result: Optional[TResult] = func()

../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/runner.py:341: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/runner.py:262: in <lambda>
    lambda: ihook(item=item, **kwds), when=when, reraise=reraise
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/pluggy/_hooks.py:493: in __call__
    return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/pluggy/_manager.py:115: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/runner.py:157: in pytest_runtest_setup
    item.session._setupstate.setup(item)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/runner.py:497: in setup
    raise exc
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/runner.py:494: in setup
    col.setup()
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/python.py:1791: in setup
    self._request._fillfixtures()
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/fixtures.py:566: in _fillfixtures
    item.funcargs[argname] = self.getfixturevalue(argname)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/fixtures.py:585: in getfixturevalue
    fixturedef = self._get_active_fixturedef(argname)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/fixtures.py:607: in _get_active_fixturedef
    self._compute_fixture_value(fixturedef)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/fixtures.py:693: in _compute_fixture_value
    fixturedef.execute(request=subrequest)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/fixtures.py:1069: in execute
    result = ihook.pytest_fixture_setup(fixturedef=self, request=request)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/pluggy/_hooks.py:493: in __call__
    return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/pluggy/_manager.py:115: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/fixtures.py:1123: in pytest_fixture_setup
    result = call_fixture_func(fixturefunc, request, kwargs)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/fixtures.py:895: in call_fixture_func
    fixture_result = next(generator)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <astropy.io.fits.tests.test_table.TestColumnFunctions object at 0x7d2b56d5f5b0>
request = <SubRequest '_xunit_setup_method_fixture_TestColumnFunctions' for <Function test_x_column_deepcopy>>

    @fixtures.fixture(
        autouse=True,
        scope="function",
        # Use a unique name to speed up lookup.
        name=f"_xunit_setup_method_fixture_{self.obj.__qualname__}",
    )
    def xunit_setup_method_fixture(self, request) -> Generator[None, None, None]:
        method = request.function
        if setup_method is not None:
            func = getattr(self, setup_name)
            _call_with_optional_argument(func, method)
            if emit_nose_setup_warning:
>               warnings.warn(
                    NOSE_SUPPORT_METHOD.format(
                        nodeid=request.node.nodeid, method="setup"
                    ),
                    stacklevel=2,
                )
E               pytest.PytestRemovedIn8Warning: Support for nose tests is deprecated and will be removed in a future release.
E               astropy/io/fits/tests/test_table.py::TestColumnFunctions::test_x_column_deepcopy is using nose-specific method: `setup(self)`
E               To remove this warning, rename it to `setup_method(self)`
E               See docs: https://docs.pytest.org/en/stable/deprecations.html#support-for-tests-written-for-nose

../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/python.py:898: PytestRemovedIn8Warning
_________ ERROR at setup of TestColumnFunctions.test_p_column_deepcopy _________

cls = <class '_pytest.runner.CallInfo'>
func = <function call_runtest_hook.<locals>.<lambda> at 0x7d2b55bb9670>
when = 'setup'
reraise = (<class '_pytest.outcomes.Exit'>, <class 'KeyboardInterrupt'>)

    @classmethod
    def from_call(
        cls,
        func: "Callable[[], TResult]",
        when: "Literal['collect', 'setup', 'call', 'teardown']",
        reraise: Optional[
            Union[Type[BaseException], Tuple[Type[BaseException], ...]]
        ] = None,
    ) -> "CallInfo[TResult]":
        """Call func, wrapping the result in a CallInfo.
    
        :param func:
            The function to call. Called without arguments.
        :param when:
            The phase in which the function is called.
        :param reraise:
            Exception or exceptions that shall propagate if raised by the
            function, instead of being wrapped in the CallInfo.
        """
        excinfo = None
        start = timing.time()
        precise_start = timing.perf_counter()
        try:
>           result: Optional[TResult] = func()

../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/runner.py:341: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/runner.py:262: in <lambda>
    lambda: ihook(item=item, **kwds), when=when, reraise=reraise
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/pluggy/_hooks.py:493: in __call__
    return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/pluggy/_manager.py:115: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/runner.py:157: in pytest_runtest_setup
    item.session._setupstate.setup(item)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/runner.py:497: in setup
    raise exc
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/runner.py:494: in setup
    col.setup()
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/python.py:1791: in setup
    self._request._fillfixtures()
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/fixtures.py:566: in _fillfixtures
    item.funcargs[argname] = self.getfixturevalue(argname)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/fixtures.py:585: in getfixturevalue
    fixturedef = self._get_active_fixturedef(argname)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/fixtures.py:607: in _get_active_fixturedef
    self._compute_fixture_value(fixturedef)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/fixtures.py:693: in _compute_fixture_value
    fixturedef.execute(request=subrequest)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/fixtures.py:1069: in execute
    result = ihook.pytest_fixture_setup(fixturedef=self, request=request)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/pluggy/_hooks.py:493: in __call__
    return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/pluggy/_manager.py:115: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/fixtures.py:1123: in pytest_fixture_setup
    result = call_fixture_func(fixturefunc, request, kwargs)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/fixtures.py:895: in call_fixture_func
    fixture_result = next(generator)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <astropy.io.fits.tests.test_table.TestColumnFunctions object at 0x7d2b56d5f2e0>
request = <SubRequest '_xunit_setup_method_fixture_TestColumnFunctions' for <Function test_p_column_deepcopy>>

    @fixtures.fixture(
        autouse=True,
        scope="function",
        # Use a unique name to speed up lookup.
        name=f"_xunit_setup_method_fixture_{self.obj.__qualname__}",
    )
    def xunit_setup_method_fixture(self, request) -> Generator[None, None, None]:
        method = request.function
        if setup_method is not None:
            func = getattr(self, setup_name)
            _call_with_optional_argument(func, method)
            if emit_nose_setup_warning:
>               warnings.warn(
                    NOSE_SUPPORT_METHOD.format(
                        nodeid=request.node.nodeid, method="setup"
                    ),
                    stacklevel=2,
                )
E               pytest.PytestRemovedIn8Warning: Support for nose tests is deprecated and will be removed in a future release.
E               astropy/io/fits/tests/test_table.py::TestColumnFunctions::test_p_column_deepcopy is using nose-specific method: `setup(self)`
E               To remove this warning, rename it to `setup_method(self)`
E               See docs: https://docs.pytest.org/en/stable/deprecations.html#support-for-tests-written-for-nose

../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/python.py:898: PytestRemovedIn8Warning
______ ERROR at setup of TestColumnFunctions.test_column_verify_keywords _______

cls = <class '_pytest.runner.CallInfo'>
func = <function call_runtest_hook.<locals>.<lambda> at 0x7d2b562b7550>
when = 'setup'
reraise = (<class '_pytest.outcomes.Exit'>, <class 'KeyboardInterrupt'>)

    @classmethod
    def from_call(
        cls,
        func: "Callable[[], TResult]",
        when: "Literal['collect', 'setup', 'call', 'teardown']",
        reraise: Optional[
            Union[Type[BaseException], Tuple[Type[BaseException], ...]]
        ] = None,
    ) -> "CallInfo[TResult]":
        """Call func, wrapping the result in a CallInfo.
    
        :param func:
            The function to call. Called without arguments.
        :param when:
            The phase in which the function is called.
        :param reraise:
            Exception or exceptions that shall propagate if raised by the
            function, instead of being wrapped in the CallInfo.
        """
        excinfo = None
        start = timing.time()
        precise_start = timing.perf_counter()
        try:
>           result: Optional[TResult] = func()

../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/runner.py:341: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/runner.py:262: in <lambda>
    lambda: ihook(item=item, **kwds), when=when, reraise=reraise
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/pluggy/_hooks.py:493: in __call__
    return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/pluggy/_manager.py:115: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/runner.py:157: in pytest_runtest_setup
    item.session._setupstate.setup(item)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/runner.py:497: in setup
    raise exc
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/runner.py:494: in setup
    col.setup()
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/python.py:1791: in setup
    self._request._fillfixtures()
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/fixtures.py:566: in _fillfixtures
    item.funcargs[argname] = self.getfixturevalue(argname)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/fixtures.py:585: in getfixturevalue
    fixturedef = self._get_active_fixturedef(argname)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/fixtures.py:607: in _get_active_fixturedef
    self._compute_fixture_value(fixturedef)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/fixtures.py:693: in _compute_fixture_value
    fixturedef.execute(request=subrequest)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/fixtures.py:1069: in execute
    result = ihook.pytest_fixture_setup(fixturedef=self, request=request)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/pluggy/_hooks.py:493: in __call__
    return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/pluggy/_manager.py:115: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/fixtures.py:1123: in pytest_fixture_setup
    result = call_fixture_func(fixturefunc, request, kwargs)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/fixtures.py:895: in call_fixture_func
    fixture_result = next(generator)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <astropy.io.fits.tests.test_table.TestColumnFunctions object at 0x7d2b56d5f370>
request = <SubRequest '_xunit_setup_method_fixture_TestColumnFunctions' for <Function test_column_verify_keywords>>

    @fixtures.fixture(
        autouse=True,
        scope="function",
        # Use a unique name to speed up lookup.
        name=f"_xunit_setup_method_fixture_{self.obj.__qualname__}",
    )
    def xunit_setup_method_fixture(self, request) -> Generator[None, None, None]:
        method = request.function
        if setup_method is not None:
            func = getattr(self, setup_name)
            _call_with_optional_argument(func, method)
            if emit_nose_setup_warning:
>               warnings.warn(
                    NOSE_SUPPORT_METHOD.format(
                        nodeid=request.node.nodeid, method="setup"
                    ),
                    stacklevel=2,
                )
E               pytest.PytestRemovedIn8Warning: Support for nose tests is deprecated and will be removed in a future release.
E               astropy/io/fits/tests/test_table.py::TestColumnFunctions::test_column_verify_keywords is using nose-specific method: `setup(self)`
E               To remove this warning, rename it to `setup_method(self)`
E               See docs: https://docs.pytest.org/en/stable/deprecations.html#support-for-tests-written-for-nose

../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/python.py:898: PytestRemovedIn8Warning
________ ERROR at setup of TestColumnFunctions.test_column_verify_start ________

cls = <class '_pytest.runner.CallInfo'>
func = <function call_runtest_hook.<locals>.<lambda> at 0x7d2b568d2ee0>
when = 'setup'
reraise = (<class '_pytest.outcomes.Exit'>, <class 'KeyboardInterrupt'>)

    @classmethod
    def from_call(
        cls,
        func: "Callable[[], TResult]",
        when: "Literal['collect', 'setup', 'call', 'teardown']",
        reraise: Optional[
            Union[Type[BaseException], Tuple[Type[BaseException], ...]]
        ] = None,
    ) -> "CallInfo[TResult]":
        """Call func, wrapping the result in a CallInfo.
    
        :param func:
            The function to call. Called without arguments.
        :param when:
            The phase in which the function is called.
        :param reraise:
            Exception or exceptions that shall propagate if raised by the
            function, instead of being wrapped in the CallInfo.
        """
        excinfo = None
        start = timing.time()
        precise_start = timing.perf_counter()
        try:
>           result: Optional[TResult] = func()

../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/runner.py:341: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/runner.py:262: in <lambda>
    lambda: ihook(item=item, **kwds), when=when, reraise=reraise
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/pluggy/_hooks.py:493: in __call__
    return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/pluggy/_manager.py:115: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/runner.py:157: in pytest_runtest_setup
    item.session._setupstate.setup(item)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/runner.py:497: in setup
    raise exc
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/runner.py:494: in setup
    col.setup()
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/python.py:1791: in setup
    self._request._fillfixtures()
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/fixtures.py:566: in _fillfixtures
    item.funcargs[argname] = self.getfixturevalue(argname)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/fixtures.py:585: in getfixturevalue
    fixturedef = self._get_active_fixturedef(argname)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/fixtures.py:607: in _get_active_fixturedef
    self._compute_fixture_value(fixturedef)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/fixtures.py:693: in _compute_fixture_value
    fixturedef.execute(request=subrequest)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/fixtures.py:1069: in execute
    result = ihook.pytest_fixture_setup(fixturedef=self, request=request)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/pluggy/_hooks.py:493: in __call__
    return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/pluggy/_manager.py:115: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/fixtures.py:1123: in pytest_fixture_setup
    result = call_fixture_func(fixturefunc, request, kwargs)
../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/fixtures.py:895: in call_fixture_func
    fixture_result = next(generator)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <astropy.io.fits.tests.test_table.TestColumnFunctions object at 0x7d2b56d5f100>
request = <SubRequest '_xunit_setup_method_fixture_TestColumnFunctions' for <Function test_column_verify_start>>

    @fixtures.fixture(
        autouse=True,
        scope="function",
        # Use a unique name to speed up lookup.
        name=f"_xunit_setup_method_fixture_{self.obj.__qualname__}",
    )
    def xunit_setup_method_fixture(self, request) -> Generator[None, None, None]:
        method = request.function
        if setup_method is not None:
            func = getattr(self, setup_name)
            _call_with_optional_argument(func, method)
            if emit_nose_setup_warning:
>               warnings.warn(
                    NOSE_SUPPORT_METHOD.format(
                        nodeid=request.node.nodeid, method="setup"
                    ),
                    stacklevel=2,
                )
E               pytest.PytestRemovedIn8Warning: Support for nose tests is deprecated and will be removed in a future release.
E               astropy/io/fits/tests/test_table.py::TestColumnFunctions::test_column_verify_start is using nose-specific method: `setup(self)`
E               To remove this warning, rename it to `setup_method(self)`
E               See docs: https://docs.pytest.org/en/stable/deprecations.html#support-for-tests-written-for-nose

../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/_pytest/python.py:898: PytestRemovedIn8Warning
=================================== FAILURES ===================================
_________________ TestChecksumFunctions.test_binary_table_data _________________

self = <astropy.io.fits.tests.test_checksum.TestChecksumFunctions object at 0x7d2b57143a90>

    def test_binary_table_data(self):
        a1 = np.array(['NGC1001', 'NGC1002', 'NGC1003'])
        a2 = np.array([11.1, 12.3, 15.2])
        col1 = fits.Column(name='target', format='20A', array=a1)
        col2 = fits.Column(name='V_mag', format='E', array=a2)
        cols = fits.ColDefs([col1, col2])
>       tbhdu = fits.BinTableHDU.from_columns(cols)

astropy/io/fits/tests/test_checksum.py:154: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
astropy/io/fits/hdu/table.py:129: in from_columns
    hdu = cls(data=data, header=header, character_as_bytes=character_as_bytes, **kwargs)
astropy/io/fits/hdu/table.py:848: in __init__
    from ....table import Table
astropy/table/__init__.py:41: in <module>
    from .column import Column, MaskedColumn, StringTruncateWarning, ColumnInfo
astropy/table/column.py:28: in <module>
    from .np_utils import fix_column_name
astropy/table/np_utils.py:15: in <module>
    from . import _np_utils
astropy/table/_np_utils.pyx:14: in init astropy.table._np_utils
    DTYPE = np.int
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

attr = 'int'

    def __getattr__(attr):
        # Warn for expired attributes, and return a dummy function
        # that always raises an exception.
        import warnings
        import math
        try:
            msg = __expired_functions__[attr]
        except KeyError:
            pass
        else:
            warnings.warn(msg, DeprecationWarning, stacklevel=2)
    
            def _expired(*args, **kwds):
                raise RuntimeError(msg)
    
            return _expired
    
        # Emit warnings for deprecated attributes
        try:
            val, msg = __deprecated_attrs__[attr]
        except KeyError:
            pass
        else:
            warnings.warn(msg, DeprecationWarning, stacklevel=2)
            return val
    
        if attr in __future_scalars__:
            # And future warnings for those that will change, but also give
            # the AttributeError
            warnings.warn(
                f"In the future `np.{attr}` will be defined as the "
                "corresponding NumPy scalar.", FutureWarning, stacklevel=2)
    
        if attr in __former_attrs__:
>           raise AttributeError(__former_attrs__[attr])
E           AttributeError: module 'numpy' has no attribute 'int'.
E           `np.int` was a deprecated alias for the builtin `int`. To avoid this error in existing code, use `int` by itself. Doing this will not modify any behavior and is safe. When replacing `np.int`, you may wish to use e.g. `np.int64` or `np.int32` to specify the precision. If you wish to review your current use, check the release note link for additional information.
E           The aliases was originally deprecated in NumPy 1.20; for more details and guidance see the original release note at:
E               https://numpy.org/devdocs/release/1.20.0-notes.html#deprecations

../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/numpy/__init__.py:319: AttributeError
____________ TestChecksumFunctions.test_variable_length_table_data _____________

self = <astropy.io.fits.tests.test_checksum.TestChecksumFunctions object at 0x7d2b571438e0>

    def test_variable_length_table_data(self):
        c1 = fits.Column(name='var', format='PJ()',
                         array=np.array([[45.0, 56], np.array([11, 12, 13])],
                         'O'))
        c2 = fits.Column(name='xyz', format='2I', array=[[11, 3], [12, 4]])
>       tbhdu = fits.BinTableHDU.from_columns([c1, c2])

astropy/io/fits/tests/test_checksum.py:172: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
astropy/io/fits/hdu/table.py:129: in from_columns
    hdu = cls(data=data, header=header, character_as_bytes=character_as_bytes, **kwargs)
astropy/io/fits/hdu/table.py:848: in __init__
    from ....table import Table
astropy/table/__init__.py:41: in <module>
    from .column import Column, MaskedColumn, StringTruncateWarning, ColumnInfo
astropy/table/column.py:28: in <module>
    from .np_utils import fix_column_name
astropy/table/np_utils.py:15: in <module>
    from . import _np_utils
astropy/table/_np_utils.pyx:14: in init astropy.table._np_utils
    DTYPE = np.int
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

attr = 'int'

    def __getattr__(attr):
        # Warn for expired attributes, and return a dummy function
        # that always raises an exception.
        import warnings
        import math
        try:
            msg = __expired_functions__[attr]
        except KeyError:
            pass
        else:
            warnings.warn(msg, DeprecationWarning, stacklevel=2)
    
            def _expired(*args, **kwds):
                raise RuntimeError(msg)
    
            return _expired
    
        # Emit warnings for deprecated attributes
        try:
            val, msg = __deprecated_attrs__[attr]
        except KeyError:
            pass
        else:
            warnings.warn(msg, DeprecationWarning, stacklevel=2)
            return val
    
        if attr in __future_scalars__:
            # And future warnings for those that will change, but also give
            # the AttributeError
            warnings.warn(
                f"In the future `np.{attr}` will be defined as the "
                "corresponding NumPy scalar.", FutureWarning, stacklevel=2)
    
        if attr in __former_attrs__:
>           raise AttributeError(__former_attrs__[attr])
E           AttributeError: module 'numpy' has no attribute 'int'.
E           `np.int` was a deprecated alias for the builtin `int`. To avoid this error in existing code, use `int` by itself. Doing this will not modify any behavior and is safe. When replacing `np.int`, you may wish to use e.g. `np.int64` or `np.int32` to specify the precision. If you wish to review your current use, check the release note link for additional information.
E           The aliases was originally deprecated in NumPy 1.20; for more details and guidance see the original release note at:
E               https://numpy.org/devdocs/release/1.20.0-notes.html#deprecations

../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/numpy/__init__.py:319: AttributeError
_______________ TestChecksumFunctions.test_compressed_image_data _______________

self = <astropy.io.fits.tests.test_checksum.TestChecksumFunctions object at 0x7d2b55888130>

    def test_compressed_image_data(self):
        with fits.open(self.data('comp.fits')) as h1:
>           h1.writeto(self.temp('tmp.fits'), overwrite=True, checksum=True)

astropy/io/fits/tests/test_checksum.py:214: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
astropy/utils/decorators.py:487: in wrapper
    return function(*args, **kwargs)
astropy/io/fits/hdu/hdulist.py:848: in writeto
    if (len(self) == 0):
astropy/io/fits/hdu/hdulist.py:241: in __len__
    while self._read_next_hdu():
astropy/io/fits/hdu/hdulist.py:1086: in _read_next_hdu
    hdu = _BaseHDU.readfrom(fileobj, **kwargs)
astropy/io/fits/hdu/base.py:326: in readfrom
    hdu = cls._readfrom_internal(fileobj, checksum=checksum,
astropy/io/fits/hdu/base.py:442: in _readfrom_internal
    hdu = cls(data=DELAYED, header=header, **new_kwargs)
astropy/io/fits/hdu/compressed.py:635: in __init__
    super().__init__(data=data, header=header)
astropy/io/fits/hdu/table.py:848: in __init__
    from ....table import Table
astropy/table/__init__.py:41: in <module>
    from .column import Column, MaskedColumn, StringTruncateWarning, ColumnInfo
astropy/table/column.py:28: in <module>
    from .np_utils import fix_column_name
astropy/table/np_utils.py:15: in <module>
    from . import _np_utils
astropy/table/_np_utils.pyx:14: in init astropy.table._np_utils
    DTYPE = np.int
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

attr = 'int'

    def __getattr__(attr):
        # Warn for expired attributes, and return a dummy function
        # that always raises an exception.
        import warnings
        import math
        try:
            msg = __expired_functions__[attr]
        except KeyError:
            pass
        else:
            warnings.warn(msg, DeprecationWarning, stacklevel=2)
    
            def _expired(*args, **kwds):
                raise RuntimeError(msg)
    
            return _expired
    
        # Emit warnings for deprecated attributes
        try:
            val, msg = __deprecated_attrs__[attr]
        except KeyError:
            pass
        else:
            warnings.warn(msg, DeprecationWarning, stacklevel=2)
            return val
    
        if attr in __future_scalars__:
            # And future warnings for those that will change, but also give
            # the AttributeError
            warnings.warn(
                f"In the future `np.{attr}` will be defined as the "
                "corresponding NumPy scalar.", FutureWarning, stacklevel=2)
    
        if attr in __former_attrs__:
>           raise AttributeError(__former_attrs__[attr])
E           AttributeError: module 'numpy' has no attribute 'int'.
E           `np.int` was a deprecated alias for the builtin `int`. To avoid this error in existing code, use `int` by itself. Doing this will not modify any behavior and is safe. When replacing `np.int`, you may wish to use e.g. `np.int64` or `np.int32` to specify the precision. If you wish to review your current use, check the release note link for additional information.
E           The aliases was originally deprecated in NumPy 1.20; for more details and guidance see the original release note at:
E               https://numpy.org/devdocs/release/1.20.0-notes.html#deprecations

../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/numpy/__init__.py:319: AttributeError
____________ TestChecksumFunctions.test_compressed_image_data_int16 ____________

self = <astropy.io.fits.tests.test_checksum.TestChecksumFunctions object at 0x7d2b558880a0>

    def test_compressed_image_data_int16(self):
        n = np.arange(100, dtype='int16')
        hdu = fits.ImageHDU(n)
>       comp_hdu = fits.CompImageHDU(hdu.data, hdu.header)

astropy/io/fits/tests/test_checksum.py:229: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
astropy/io/fits/hdu/compressed.py:639: in __init__
    super().__init__(data=None, header=header)
astropy/io/fits/hdu/table.py:848: in __init__
    from ....table import Table
astropy/table/__init__.py:41: in <module>
    from .column import Column, MaskedColumn, StringTruncateWarning, ColumnInfo
astropy/table/column.py:28: in <module>
    from .np_utils import fix_column_name
astropy/table/np_utils.py:15: in <module>
    from . import _np_utils
astropy/table/_np_utils.pyx:14: in init astropy.table._np_utils
    DTYPE = np.int
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

attr = 'int'

    def __getattr__(attr):
        # Warn for expired attributes, and return a dummy function
        # that always raises an exception.
        import warnings
        import math
        try:
            msg = __expired_functions__[attr]
        except KeyError:
            pass
        else:
            warnings.warn(msg, DeprecationWarning, stacklevel=2)
    
            def _expired(*args, **kwds):
                raise RuntimeError(msg)
    
            return _expired
    
        # Emit warnings for deprecated attributes
        try:
            val, msg = __deprecated_attrs__[attr]
        except KeyError:
            pass
        else:
            warnings.warn(msg, DeprecationWarning, stacklevel=2)
            return val
    
        if attr in __future_scalars__:
            # And future warnings for those that will change, but also give
            # the AttributeError
            warnings.warn(
                f"In the future `np.{attr}` will be defined as the "
                "corresponding NumPy scalar.", FutureWarning, stacklevel=2)
    
        if attr in __former_attrs__:
>           raise AttributeError(__former_attrs__[attr])
E           AttributeError: module 'numpy' has no attribute 'int'.
E           `np.int` was a deprecated alias for the builtin `int`. To avoid this error in existing code, use `int` by itself. Doing this will not modify any behavior and is safe. When replacing `np.int`, you may wish to use e.g. `np.int64` or `np.int32` to specify the precision. If you wish to review your current use, check the release note link for additional information.
E           The aliases was originally deprecated in NumPy 1.20; for more details and guidance see the original release note at:
E               https://numpy.org/devdocs/release/1.20.0-notes.html#deprecations

../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/numpy/__init__.py:319: AttributeError
___________ TestChecksumFunctions.test_compressed_image_data_float32 ___________

self = <astropy.io.fits.tests.test_checksum.TestChecksumFunctions object at 0x7d2b55888520>

    def test_compressed_image_data_float32(self):
        n = np.arange(100, dtype='float32')
        hdu = fits.ImageHDU(n)
>       comp_hdu = fits.CompImageHDU(hdu.data, hdu.header)

astropy/io/fits/tests/test_checksum.py:261: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
astropy/io/fits/hdu/compressed.py:639: in __init__
    super().__init__(data=None, header=header)
astropy/io/fits/hdu/table.py:848: in __init__
    from ....table import Table
astropy/table/__init__.py:41: in <module>
    from .column import Column, MaskedColumn, StringTruncateWarning, ColumnInfo
astropy/table/column.py:28: in <module>
    from .np_utils import fix_column_name
astropy/table/np_utils.py:15: in <module>
    from . import _np_utils
astropy/table/_np_utils.pyx:14: in init astropy.table._np_utils
    DTYPE = np.int
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

attr = 'int'

    def __getattr__(attr):
        # Warn for expired attributes, and return a dummy function
        # that always raises an exception.
        import warnings
        import math
        try:
            msg = __expired_functions__[attr]
        except KeyError:
            pass
        else:
            warnings.warn(msg, DeprecationWarning, stacklevel=2)
    
            def _expired(*args, **kwds):
                raise RuntimeError(msg)
    
            return _expired
    
        # Emit warnings for deprecated attributes
        try:
            val, msg = __deprecated_attrs__[attr]
        except KeyError:
            pass
        else:
            warnings.warn(msg, DeprecationWarning, stacklevel=2)
            return val
    
        if attr in __future_scalars__:
            # And future warnings for those that will change, but also give
            # the AttributeError
            warnings.warn(
                f"In the future `np.{attr}` will be defined as the "
                "corresponding NumPy scalar.", FutureWarning, stacklevel=2)
    
        if attr in __former_attrs__:
>           raise AttributeError(__former_attrs__[attr])
E           AttributeError: module 'numpy' has no attribute 'int'.
E           `np.int` was a deprecated alias for the builtin `int`. To avoid this error in existing code, use `int` by itself. Doing this will not modify any behavior and is safe. When replacing `np.int`, you may wish to use e.g. `np.int64` or `np.int32` to specify the precision. If you wish to review your current use, check the release note link for additional information.
E           The aliases was originally deprecated in NumPy 1.20; for more details and guidance see the original release note at:
E               https://numpy.org/devdocs/release/1.20.0-notes.html#deprecations

../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/numpy/__init__.py:319: AttributeError
______________________ TestChecksumFunctions.test_append _______________________

self = <astropy.io.fits.tests.test_checksum.TestChecksumFunctions object at 0x7d2b575e0130>

    def test_append(self):
        hdul = fits.open(self.data('tb.fits'))
>       hdul.writeto(self.temp('tmp.fits'), overwrite=True)

astropy/io/fits/tests/test_checksum.py:299: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
astropy/utils/decorators.py:487: in wrapper
    return function(*args, **kwargs)
astropy/io/fits/hdu/hdulist.py:848: in writeto
    if (len(self) == 0):
astropy/io/fits/hdu/hdulist.py:241: in __len__
    while self._read_next_hdu():
astropy/io/fits/hdu/hdulist.py:1086: in _read_next_hdu
    hdu = _BaseHDU.readfrom(fileobj, **kwargs)
astropy/io/fits/hdu/base.py:326: in readfrom
    hdu = cls._readfrom_internal(fileobj, checksum=checksum,
astropy/io/fits/hdu/base.py:442: in _readfrom_internal
    hdu = cls(data=DELAYED, header=header, **new_kwargs)
astropy/io/fits/hdu/table.py:848: in __init__
    from ....table import Table
astropy/table/__init__.py:41: in <module>
    from .column import Column, MaskedColumn, StringTruncateWarning, ColumnInfo
astropy/table/column.py:28: in <module>
    from .np_utils import fix_column_name
astropy/table/np_utils.py:15: in <module>
    from . import _np_utils
astropy/table/_np_utils.pyx:14: in init astropy.table._np_utils
    DTYPE = np.int
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

attr = 'int'

    def __getattr__(attr):
        # Warn for expired attributes, and return a dummy function
        # that always raises an exception.
        import warnings
        import math
        try:
            msg = __expired_functions__[attr]
        except KeyError:
            pass
        else:
            warnings.warn(msg, DeprecationWarning, stacklevel=2)
    
            def _expired(*args, **kwds):
                raise RuntimeError(msg)
    
            return _expired
    
        # Emit warnings for deprecated attributes
        try:
            val, msg = __deprecated_attrs__[attr]
        except KeyError:
            pass
        else:
            warnings.warn(msg, DeprecationWarning, stacklevel=2)
            return val
    
        if attr in __future_scalars__:
            # And future warnings for those that will change, but also give
            # the AttributeError
            warnings.warn(
                f"In the future `np.{attr}` will be defined as the "
                "corresponding NumPy scalar.", FutureWarning, stacklevel=2)
    
        if attr in __former_attrs__:
>           raise AttributeError(__former_attrs__[attr])
E           AttributeError: module 'numpy' has no attribute 'int'.
E           `np.int` was a deprecated alias for the builtin `int`. To avoid this error in existing code, use `int` by itself. Doing this will not modify any behavior and is safe. When replacing `np.int`, you may wish to use e.g. `np.int64` or `np.int32` to specify the precision. If you wish to review your current use, check the release note link for additional information.
E           The aliases was originally deprecated in NumPy 1.20; for more details and guidance see the original release note at:
E               https://numpy.org/devdocs/release/1.20.0-notes.html#deprecations

../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/numpy/__init__.py:319: AttributeError
_______________ TestChecksumFunctions.test_hdu_writeto_existing ________________

self = <astropy.io.fits.tests.test_checksum.TestChecksumFunctions object at 0x7d2b574d24c0>

    def test_hdu_writeto_existing(self):
        """
        Tests that when using writeto with checksum=True, a checksum and
        datasum are added to HDUs that did not previously have one.
    
        Regression test for https://github.com/spacetelescope/PyFITS/issues/8
        """
    
        with fits.open(self.data('tb.fits')) as hdul:
>           hdul.writeto(self.temp('test.fits'), checksum=True)

astropy/io/fits/tests/test_checksum.py:331: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
astropy/utils/decorators.py:487: in wrapper
    return function(*args, **kwargs)
astropy/io/fits/hdu/hdulist.py:848: in writeto
    if (len(self) == 0):
astropy/io/fits/hdu/hdulist.py:241: in __len__
    while self._read_next_hdu():
astropy/io/fits/hdu/hdulist.py:1086: in _read_next_hdu
    hdu = _BaseHDU.readfrom(fileobj, **kwargs)
astropy/io/fits/hdu/base.py:326: in readfrom
    hdu = cls._readfrom_internal(fileobj, checksum=checksum,
astropy/io/fits/hdu/base.py:442: in _readfrom_internal
    hdu = cls(data=DELAYED, header=header, **new_kwargs)
astropy/io/fits/hdu/table.py:848: in __init__
    from ....table import Table
astropy/table/__init__.py:41: in <module>
    from .column import Column, MaskedColumn, StringTruncateWarning, ColumnInfo
astropy/table/column.py:28: in <module>
    from .np_utils import fix_column_name
astropy/table/np_utils.py:15: in <module>
    from . import _np_utils
astropy/table/_np_utils.pyx:14: in init astropy.table._np_utils
    DTYPE = np.int
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

attr = 'int'

    def __getattr__(attr):
        # Warn for expired attributes, and return a dummy function
        # that always raises an exception.
        import warnings
        import math
        try:
            msg = __expired_functions__[attr]
        except KeyError:
            pass
        else:
            warnings.warn(msg, DeprecationWarning, stacklevel=2)
    
            def _expired(*args, **kwds):
                raise RuntimeError(msg)
    
            return _expired
    
        # Emit warnings for deprecated attributes
        try:
            val, msg = __deprecated_attrs__[attr]
        except KeyError:
            pass
        else:
            warnings.warn(msg, DeprecationWarning, stacklevel=2)
            return val
    
        if attr in __future_scalars__:
            # And future warnings for those that will change, but also give
            # the AttributeError
            warnings.warn(
                f"In the future `np.{attr}` will be defined as the "
                "corresponding NumPy scalar.", FutureWarning, stacklevel=2)
    
        if attr in __former_attrs__:
>           raise AttributeError(__former_attrs__[attr])
E           AttributeError: module 'numpy' has no attribute 'int'.
E           `np.int` was a deprecated alias for the builtin `int`. To avoid this error in existing code, use `int` by itself. Doing this will not modify any behavior and is safe. When replacing `np.int`, you may wish to use e.g. `np.int64` or `np.int32` to specify the precision. If you wish to review your current use, check the release note link for additional information.
E           The aliases was originally deprecated in NumPy 1.20; for more details and guidance see the original release note at:
E               https://numpy.org/devdocs/release/1.20.0-notes.html#deprecations

../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/numpy/__init__.py:319: AttributeError
________ TestChecksumFunctions.test_open_update_mode_preserve_checksum _________

self = [<astropy.io.fits.hdu.image.PrimaryHDU object at 0x7d2b56190a60>]
func = <built-in method __getitem__ of HDUList object at 0x7d2b5657def0>
args = (1,), kwargs = {}

    def _try_while_unread_hdus(self, func, *args, **kwargs):
        """
        Attempt an operation that accesses an HDU by index/name
        that can fail if not all HDUs have been read yet.  Keep
        reading HDUs until the operation succeeds or there are no
        more HDUs to read.
        """
    
        while True:
            try:
>               return func(*args, **kwargs)
E               IndexError: list index out of range

astropy/io/fits/hdu/hdulist.py:1043: IndexError

During handling of the above exception, another exception occurred:

self = <astropy.io.fits.tests.test_checksum.TestChecksumFunctions object at 0x7d2b575e0d90>

    def test_open_update_mode_preserve_checksum(self):
        """
        Regression test for https://aeon.stsci.edu/ssb/trac/pyfits/ticket/148 where
        checksums are being removed from headers when a file is opened in
        update mode, even though no changes were made to the file.
        """
    
        self.copy_file('checksum.fits')
    
        with fits.open(self.temp('checksum.fits')) as hdul:
>           data = hdul[1].data.copy()

astropy/io/fits/tests/test_checksum.py:365: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
astropy/io/fits/hdu/hdulist.py:314: in __getitem__
    return self._try_while_unread_hdus(super().__getitem__,
astropy/io/fits/hdu/hdulist.py:1045: in _try_while_unread_hdus
    if self._read_next_hdu():
astropy/io/fits/hdu/hdulist.py:1086: in _read_next_hdu
    hdu = _BaseHDU.readfrom(fileobj, **kwargs)
astropy/io/fits/hdu/base.py:326: in readfrom
    hdu = cls._readfrom_internal(fileobj, checksum=checksum,
astropy/io/fits/hdu/base.py:442: in _readfrom_internal
    hdu = cls(data=DELAYED, header=header, **new_kwargs)
astropy/io/fits/hdu/table.py:848: in __init__
    from ....table import Table
astropy/table/__init__.py:41: in <module>
    from .column import Column, MaskedColumn, StringTruncateWarning, ColumnInfo
astropy/table/column.py:28: in <module>
    from .np_utils import fix_column_name
astropy/table/np_utils.py:15: in <module>
    from . import _np_utils
astropy/table/_np_utils.pyx:14: in init astropy.table._np_utils
    DTYPE = np.int
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

attr = 'int'

    def __getattr__(attr):
        # Warn for expired attributes, and return a dummy function
        # that always raises an exception.
        import warnings
        import math
        try:
            msg = __expired_functions__[attr]
        except KeyError:
            pass
        else:
            warnings.warn(msg, DeprecationWarning, stacklevel=2)
    
            def _expired(*args, **kwds):
                raise RuntimeError(msg)
    
            return _expired
    
        # Emit warnings for deprecated attributes
        try:
            val, msg = __deprecated_attrs__[attr]
        except KeyError:
            pass
        else:
            warnings.warn(msg, DeprecationWarning, stacklevel=2)
            return val
    
        if attr in __future_scalars__:
            # And future warnings for those that will change, but also give
            # the AttributeError
            warnings.warn(
                f"In the future `np.{attr}` will be defined as the "
                "corresponding NumPy scalar.", FutureWarning, stacklevel=2)
    
        if attr in __former_attrs__:
>           raise AttributeError(__former_attrs__[attr])
E           AttributeError: module 'numpy' has no attribute 'int'.
E           `np.int` was a deprecated alias for the builtin `int`. To avoid this error in existing code, use `int` by itself. Doing this will not modify any behavior and is safe. When replacing `np.int`, you may wish to use e.g. `np.int64` or `np.int32` to specify the precision. If you wish to review your current use, check the release note link for additional information.
E           The aliases was originally deprecated in NumPy 1.20; for more details and guidance see the original release note at:
E               https://numpy.org/devdocs/release/1.20.0-notes.html#deprecations

../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/numpy/__init__.py:319: AttributeError
_________ TestChecksumFunctions.test_open_update_mode_update_checksum __________

self = [<astropy.io.fits.hdu.image.PrimaryHDU object at 0x7d2b55897f70>]
func = <built-in method __getitem__ of HDUList object at 0x7d2b56d9c310>
args = (1,), kwargs = {}

    def _try_while_unread_hdus(self, func, *args, **kwargs):
        """
        Attempt an operation that accesses an HDU by index/name
        that can fail if not all HDUs have been read yet.  Keep
        reading HDUs until the operation succeeds or there are no
        more HDUs to read.
        """
    
        while True:
            try:
>               return func(*args, **kwargs)
E               IndexError: list index out of range

astropy/io/fits/hdu/hdulist.py:1043: IndexError

During handling of the above exception, another exception occurred:

self = <astropy.io.fits.tests.test_checksum.TestChecksumFunctions object at 0x7d2b5713fac0>

    def test_open_update_mode_update_checksum(self):
        """
        Regression test for https://aeon.stsci.edu/ssb/trac/pyfits/ticket/148, part
        2.  This ensures that if a file contains a checksum, the checksum is
        updated when changes are saved to the file, even if the file was opened
        with the default of checksum=False.
    
        An existing checksum and/or datasum are only stripped if the file is
        opened with checksum='remove'.
        """
    
        self.copy_file('checksum.fits')
        with fits.open(self.temp('checksum.fits')) as hdul:
>           header = hdul[1].header.copy()

astropy/io/fits/tests/test_checksum.py:388: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
astropy/io/fits/hdu/hdulist.py:314: in __getitem__
    return self._try_while_unread_hdus(super().__getitem__,
astropy/io/fits/hdu/hdulist.py:1045: in _try_while_unread_hdus
    if self._read_next_hdu():
astropy/io/fits/hdu/hdulist.py:1086: in _read_next_hdu
    hdu = _BaseHDU.readfrom(fileobj, **kwargs)
astropy/io/fits/hdu/base.py:326: in readfrom
    hdu = cls._readfrom_internal(fileobj, checksum=checksum,
astropy/io/fits/hdu/base.py:442: in _readfrom_internal
    hdu = cls(data=DELAYED, header=header, **new_kwargs)
astropy/io/fits/hdu/table.py:848: in __init__
    from ....table import Table
astropy/table/__init__.py:41: in <module>
    from .column import Column, MaskedColumn, StringTruncateWarning, ColumnInfo
astropy/table/column.py:28: in <module>
    from .np_utils import fix_column_name
astropy/table/np_utils.py:15: in <module>
    from . import _np_utils
astropy/table/_np_utils.pyx:14: in init astropy.table._np_utils
    DTYPE = np.int
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

attr = 'int'

    def __getattr__(attr):
        # Warn for expired attributes, and return a dummy function
        # that always raises an exception.
        import warnings
        import math
        try:
            msg = __expired_functions__[attr]
        except KeyError:
            pass
        else:
            warnings.warn(msg, DeprecationWarning, stacklevel=2)
    
            def _expired(*args, **kwds):
                raise RuntimeError(msg)
    
            return _expired
    
        # Emit warnings for deprecated attributes
        try:
            val, msg = __deprecated_attrs__[attr]
        except KeyError:
            pass
        else:
            warnings.warn(msg, DeprecationWarning, stacklevel=2)
            return val
    
        if attr in __future_scalars__:
            # And future warnings for those that will change, but also give
            # the AttributeError
            warnings.warn(
                f"In the future `np.{attr}` will be defined as the "
                "corresponding NumPy scalar.", FutureWarning, stacklevel=2)
    
        if attr in __former_attrs__:
>           raise AttributeError(__former_attrs__[attr])
E           AttributeError: module 'numpy' has no attribute 'int'.
E           `np.int` was a deprecated alias for the builtin `int`. To avoid this error in existing code, use `int` by itself. Doing this will not modify any behavior and is safe. When replacing `np.int`, you may wish to use e.g. `np.int64` or `np.int32` to specify the precision. If you wish to review your current use, check the release note link for additional information.
E           The aliases was originally deprecated in NumPy 1.20; for more details and guidance see the original release note at:
E               https://numpy.org/devdocs/release/1.20.0-notes.html#deprecations

../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/numpy/__init__.py:319: AttributeError
_________________ TestChecksumFunctions.test_overwrite_invalid _________________

self = <astropy.io.fits.tests.test_checksum.TestChecksumFunctions object at 0x7d2b5713f490>

    def test_overwrite_invalid(self):
        """
        Tests that invalid checksum or datasum are overwriten when the file is
        saved.
        """
    
        reffile = self.temp('ref.fits')
        with fits.open(self.data('tb.fits')) as hdul:
>           hdul.writeto(reffile, checksum=True)

astropy/io/fits/tests/test_checksum.py:427: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
astropy/utils/decorators.py:487: in wrapper
    return function(*args, **kwargs)
astropy/io/fits/hdu/hdulist.py:848: in writeto
    if (len(self) == 0):
astropy/io/fits/hdu/hdulist.py:241: in __len__
    while self._read_next_hdu():
astropy/io/fits/hdu/hdulist.py:1086: in _read_next_hdu
    hdu = _BaseHDU.readfrom(fileobj, **kwargs)
astropy/io/fits/hdu/base.py:326: in readfrom
    hdu = cls._readfrom_internal(fileobj, checksum=checksum,
astropy/io/fits/hdu/base.py:442: in _readfrom_internal
    hdu = cls(data=DELAYED, header=header, **new_kwargs)
astropy/io/fits/hdu/table.py:848: in __init__
    from ....table import Table
astropy/table/__init__.py:41: in <module>
    from .column import Column, MaskedColumn, StringTruncateWarning, ColumnInfo
astropy/table/column.py:28: in <module>
    from .np_utils import fix_column_name
astropy/table/np_utils.py:15: in <module>
    from . import _np_utils
astropy/table/_np_utils.pyx:14: in init astropy.table._np_utils
    DTYPE = np.int
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

attr = 'int'

    def __getattr__(attr):
        # Warn for expired attributes, and return a dummy function
        # that always raises an exception.
        import warnings
        import math
        try:
            msg = __expired_functions__[attr]
        except KeyError:
            pass
        else:
            warnings.warn(msg, DeprecationWarning, stacklevel=2)
    
            def _expired(*args, **kwds):
                raise RuntimeError(msg)
    
            return _expired
    
        # Emit warnings for deprecated attributes
        try:
            val, msg = __deprecated_attrs__[attr]
        except KeyError:
            pass
        else:
            warnings.warn(msg, DeprecationWarning, stacklevel=2)
            return val
    
        if attr in __future_scalars__:
            # And future warnings for those that will change, but also give
            # the AttributeError
            warnings.warn(
                f"In the future `np.{attr}` will be defined as the "
                "corresponding NumPy scalar.", FutureWarning, stacklevel=2)
    
        if attr in __former_attrs__:
>           raise AttributeError(__former_attrs__[attr])
E           AttributeError: module 'numpy' has no attribute 'int'.
E           `np.int` was a deprecated alias for the builtin `int`. To avoid this error in existing code, use `int` by itself. Doing this will not modify any behavior and is safe. When replacing `np.int`, you may wish to use e.g. `np.int64` or `np.int32` to specify the precision. If you wish to review your current use, check the release note link for additional information.
E           The aliases was originally deprecated in NumPy 1.20; for more details and guidance see the original release note at:
E               https://numpy.org/devdocs/release/1.20.0-notes.html#deprecations

../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/numpy/__init__.py:319: AttributeError
______________ TestTableFunctions.test_constructor_copies_header _______________

self = <astropy.io.fits.tests.test_table.TestTableFunctions object at 0x7d2b56d56640>

    def test_constructor_copies_header(self):
        """
        Regression test for https://aeon.stsci.edu/ssb/trac/pyfits/ticket/153
    
        Ensure that a header from one HDU is copied when used to initialize new
        HDU.
    
        This is like the test of the same name in test_image, but tests this
        for tables as well.
        """
    
>       ifd = fits.HDUList([fits.PrimaryHDU(), fits.BinTableHDU()])

astropy/io/fits/tests/test_table.py:118: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
astropy/io/fits/hdu/table.py:848: in __init__
    from ....table import Table
astropy/table/__init__.py:41: in <module>
    from .column import Column, MaskedColumn, StringTruncateWarning, ColumnInfo
astropy/table/column.py:28: in <module>
    from .np_utils import fix_column_name
astropy/table/np_utils.py:15: in <module>
    from . import _np_utils
astropy/table/_np_utils.pyx:14: in init astropy.table._np_utils
    DTYPE = np.int
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

attr = 'int'

    def __getattr__(attr):
        # Warn for expired attributes, and return a dummy function
        # that always raises an exception.
        import warnings
        import math
        try:
            msg = __expired_functions__[attr]
        except KeyError:
            pass
        else:
            warnings.warn(msg, DeprecationWarning, stacklevel=2)
    
            def _expired(*args, **kwds):
                raise RuntimeError(msg)
    
            return _expired
    
        # Emit warnings for deprecated attributes
        try:
            val, msg = __deprecated_attrs__[attr]
        except KeyError:
            pass
        else:
            warnings.warn(msg, DeprecationWarning, stacklevel=2)
            return val
    
        if attr in __future_scalars__:
            # And future warnings for those that will change, but also give
            # the AttributeError
            warnings.warn(
                f"In the future `np.{attr}` will be defined as the "
                "corresponding NumPy scalar.", FutureWarning, stacklevel=2)
    
        if attr in __former_attrs__:
>           raise AttributeError(__former_attrs__[attr])
E           AttributeError: module 'numpy' has no attribute 'int'.
E           `np.int` was a deprecated alias for the builtin `int`. To avoid this error in existing code, use `int` by itself. Doing this will not modify any behavior and is safe. When replacing `np.int`, you may wish to use e.g. `np.int64` or `np.int32` to specify the precision. If you wish to review your current use, check the release note link for additional information.
E           The aliases was originally deprecated in NumPy 1.20; for more details and guidance see the original release note at:
E               https://numpy.org/devdocs/release/1.20.0-notes.html#deprecations

../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/numpy/__init__.py:319: AttributeError
_________________________ TestTableFunctions.test_open _________________________

self = <astropy.io.fits.tests.test_table.TestTableFunctions object at 0x7d2b56d562e0>

    def test_open(self):
        # open some existing FITS files:
        tt = fits.open(self.data('tb.fits'))
        fd = fits.open(self.data('test0.fits'))
    
        # create some local arrays
        a1 = chararray.array(['abc', 'def', 'xx'])
        r1 = np.array([11., 12., 13.], dtype=np.float32)
    
        # create a table from scratch, using a mixture of columns from existing
        # tables and locally created arrays:
    
        # first, create individual column definitions
    
        c1 = fits.Column(name='abc', format='3A', array=a1)
        c2 = fits.Column(name='def', format='E', array=r1)
        a3 = np.array([3, 4, 5], dtype='i2')
        c3 = fits.Column(name='xyz', format='I', array=a3)
        a4 = np.array([1, 2, 3], dtype='i2')
        c4 = fits.Column(name='t1', format='I', array=a4)
        a5 = np.array([3 + 3j, 4 + 4j, 5 + 5j], dtype='c8')
        c5 = fits.Column(name='t2', format='C', array=a5)
    
        # Note that X format must be two-D array
        a6 = np.array([[0], [1], [0]], dtype=np.uint8)
        c6 = fits.Column(name='t3', format='X', array=a6)
        a7 = np.array([101, 102, 103], dtype='i4')
        c7 = fits.Column(name='t4', format='J', array=a7)
        a8 = np.array([[1, 1, 0, 1, 0, 1, 1, 1, 0, 0, 1],
                       [0, 1, 1, 1, 1, 0, 0, 0, 0, 1, 0],
                       [1, 1, 1, 0, 0, 1, 1, 1, 1, 1, 1]], dtype=np.uint8)
        c8 = fits.Column(name='t5', format='11X', array=a8)
    
        # second, create a column-definitions object for all columns in a table
    
        x = fits.ColDefs([c1, c2, c3, c4, c5, c6, c7, c8])
    
>       tbhdu = fits.BinTableHDU.from_columns(x)

astropy/io/fits/tests/test_table.py:166: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
astropy/io/fits/hdu/table.py:129: in from_columns
    hdu = cls(data=data, header=header, character_as_bytes=character_as_bytes, **kwargs)
astropy/io/fits/hdu/table.py:848: in __init__
    from ....table import Table
astropy/table/__init__.py:41: in <module>
    from .column import Column, MaskedColumn, StringTruncateWarning, ColumnInfo
astropy/table/column.py:28: in <module>
    from .np_utils import fix_column_name
astropy/table/np_utils.py:15: in <module>
    from . import _np_utils
astropy/table/_np_utils.pyx:14: in init astropy.table._np_utils
    DTYPE = np.int
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

attr = 'int'

    def __getattr__(attr):
        # Warn for expired attributes, and return a dummy function
        # that always raises an exception.
        import warnings
        import math
        try:
            msg = __expired_functions__[attr]
        except KeyError:
            pass
        else:
            warnings.warn(msg, DeprecationWarning, stacklevel=2)
    
            def _expired(*args, **kwds):
                raise RuntimeError(msg)
    
            return _expired
    
        # Emit warnings for deprecated attributes
        try:
            val, msg = __deprecated_attrs__[attr]
        except KeyError:
            pass
        else:
            warnings.warn(msg, DeprecationWarning, stacklevel=2)
            return val
    
        if attr in __future_scalars__:
            # And future warnings for those that will change, but also give
            # the AttributeError
            warnings.warn(
                f"In the future `np.{attr}` will be defined as the "
                "corresponding NumPy scalar.", FutureWarning, stacklevel=2)
    
        if attr in __former_attrs__:
>           raise AttributeError(__former_attrs__[attr])
E           AttributeError: module 'numpy' has no attribute 'int'.
E           `np.int` was a deprecated alias for the builtin `int`. To avoid this error in existing code, use `int` by itself. Doing this will not modify any behavior and is safe. When replacing `np.int`, you may wish to use e.g. `np.int64` or `np.int32` to specify the precision. If you wish to review your current use, check the release note link for additional information.
E           The aliases was originally deprecated in NumPy 1.20; for more details and guidance see the original release note at:
E               https://numpy.org/devdocs/release/1.20.0-notes.html#deprecations

../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/numpy/__init__.py:319: AttributeError
_____________________ TestTableFunctions.test_binary_table _____________________

self = <[AttributeError("module 'numpy' has no attribute 'int'.\n`np.int` was a deprecated alias for the builtin `int`. To av... https://numpy.org/devdocs/release/1.20.0-notes.html#deprecations") raised in repr()] HDUList object at 0x7d2b55e24310>
func = <built-in method __getitem__ of HDUList object at 0x7d2b55e24310>
args = (1,), kwargs = {}

    def _try_while_unread_hdus(self, func, *args, **kwargs):
        """
        Attempt an operation that accesses an HDU by index/name
        that can fail if not all HDUs have been read yet.  Keep
        reading HDUs until the operation succeeds or there are no
        more HDUs to read.
        """
    
        while True:
            try:
>               return func(*args, **kwargs)
E               IndexError: list index out of range

astropy/io/fits/hdu/hdulist.py:1043: IndexError

During handling of the above exception, another exception occurred:

self = <astropy.io.fits.tests.test_table.TestTableFunctions object at 0x7d2b56d605b0>

    def test_binary_table(self):
        # binary table:
        t = fits.open(self.data('tb.fits'))
>       assert t[1].header['tform1'] == '1J'

astropy/io/fits/tests/test_table.py:219: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
astropy/io/fits/hdu/hdulist.py:314: in __getitem__
    return self._try_while_unread_hdus(super().__getitem__,
astropy/io/fits/hdu/hdulist.py:1045: in _try_while_unread_hdus
    if self._read_next_hdu():
astropy/io/fits/hdu/hdulist.py:1086: in _read_next_hdu
    hdu = _BaseHDU.readfrom(fileobj, **kwargs)
astropy/io/fits/hdu/base.py:326: in readfrom
    hdu = cls._readfrom_internal(fileobj, checksum=checksum,
astropy/io/fits/hdu/base.py:442: in _readfrom_internal
    hdu = cls(data=DELAYED, header=header, **new_kwargs)
astropy/io/fits/hdu/table.py:848: in __init__
    from ....table import Table
astropy/table/__init__.py:41: in <module>
    from .column import Column, MaskedColumn, StringTruncateWarning, ColumnInfo
astropy/table/column.py:28: in <module>
    from .np_utils import fix_column_name
astropy/table/np_utils.py:15: in <module>
    from . import _np_utils
astropy/table/_np_utils.pyx:14: in init astropy.table._np_utils
    DTYPE = np.int
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

attr = 'int'

    def __getattr__(attr):
        # Warn for expired attributes, and return a dummy function
        # that always raises an exception.
        import warnings
        import math
        try:
            msg = __expired_functions__[attr]
        except KeyError:
            pass
        else:
            warnings.warn(msg, DeprecationWarning, stacklevel=2)
    
            def _expired(*args, **kwds):
                raise RuntimeError(msg)
    
            return _expired
    
        # Emit warnings for deprecated attributes
        try:
            val, msg = __deprecated_attrs__[attr]
        except KeyError:
            pass
        else:
            warnings.warn(msg, DeprecationWarning, stacklevel=2)
            return val
    
        if attr in __future_scalars__:
            # And future warnings for those that will change, but also give
            # the AttributeError
            warnings.warn(
                f"In the future `np.{attr}` will be defined as the "
                "corresponding NumPy scalar.", FutureWarning, stacklevel=2)
    
        if attr in __former_attrs__:
>           raise AttributeError(__former_attrs__[attr])
E           AttributeError: module 'numpy' has no attribute 'int'.
E           `np.int` was a deprecated alias for the builtin `int`. To avoid this error in existing code, use `int` by itself. Doing this will not modify any behavior and is safe. When replacing `np.int`, you may wish to use e.g. `np.int64` or `np.int32` to specify the precision. If you wish to review your current use, check the release note link for additional information.
E           The aliases was originally deprecated in NumPy 1.20; for more details and guidance see the original release note at:
E               https://numpy.org/devdocs/release/1.20.0-notes.html#deprecations

../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/numpy/__init__.py:319: AttributeError
______________________ TestTableFunctions.test_endianness ______________________

self = <astropy.io.fits.tests.test_table.TestTableFunctions object at 0x7d2b56d600a0>

    def test_endianness(self):
        x = np.ndarray((1,), dtype=object)
        channelsIn = np.array([3], dtype='uint8')
        x[0] = channelsIn
        col = fits.Column(name="Channels", format="PB()", array=x)
        cols = fits.ColDefs([col])
>       tbhdu = fits.BinTableHDU.from_columns(cols)

astropy/io/fits/tests/test_table.py:322: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
astropy/io/fits/hdu/table.py:129: in from_columns
    hdu = cls(data=data, header=header, character_as_bytes=character_as_bytes, **kwargs)
astropy/io/fits/hdu/table.py:848: in __init__
    from ....table import Table
astropy/table/__init__.py:41: in <module>
    from .column import Column, MaskedColumn, StringTruncateWarning, ColumnInfo
astropy/table/column.py:28: in <module>
    from .np_utils import fix_column_name
astropy/table/np_utils.py:15: in <module>
    from . import _np_utils
astropy/table/_np_utils.pyx:14: in init astropy.table._np_utils
    DTYPE = np.int
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

attr = 'int'

    def __getattr__(attr):
        # Warn for expired attributes, and return a dummy function
        # that always raises an exception.
        import warnings
        import math
        try:
            msg = __expired_functions__[attr]
        except KeyError:
            pass
        else:
            warnings.warn(msg, DeprecationWarning, stacklevel=2)
    
            def _expired(*args, **kwds):
                raise RuntimeError(msg)
    
            return _expired
    
        # Emit warnings for deprecated attributes
        try:
            val, msg = __deprecated_attrs__[attr]
        except KeyError:
            pass
        else:
            warnings.warn(msg, DeprecationWarning, stacklevel=2)
            return val
    
        if attr in __future_scalars__:
            # And future warnings for those that will change, but also give
            # the AttributeError
            warnings.warn(
                f"In the future `np.{attr}` will be defined as the "
                "corresponding NumPy scalar.", FutureWarning, stacklevel=2)
    
        if attr in __former_attrs__:
>           raise AttributeError(__former_attrs__[attr])
E           AttributeError: module 'numpy' has no attribute 'int'.
E           `np.int` was a deprecated alias for the builtin `int`. To avoid this error in existing code, use `int` by itself. Doing this will not modify any behavior and is safe. When replacing `np.int`, you may wish to use e.g. `np.int64` or `np.int32` to specify the precision. If you wish to review your current use, check the release note link for additional information.
E           The aliases was originally deprecated in NumPy 1.20; for more details and guidance see the original release note at:
E               https://numpy.org/devdocs/release/1.20.0-notes.html#deprecations

../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/numpy/__init__.py:319: AttributeError
__________________ TestTableFunctions.test_column_endianness ___________________

self = <astropy.io.fits.tests.test_table.TestTableFunctions object at 0x7d2b56d603a0>

    def test_column_endianness(self):
        """
        Regression test for https://aeon.stsci.edu/ssb/trac/pyfits/ticket/77
        (Astropy doesn't preserve byte order of non-native order column arrays)
        """
    
        a = [1., 2., 3., 4.]
        a1 = np.array(a, dtype='<f8')
        a2 = np.array(a, dtype='>f8')
    
        col1 = fits.Column(name='a', format='D', array=a1)
        col2 = fits.Column(name='b', format='D', array=a2)
        cols = fits.ColDefs([col1, col2])
>       tbhdu = fits.BinTableHDU.from_columns(cols)

astropy/io/fits/tests/test_table.py:345: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
astropy/io/fits/hdu/table.py:129: in from_columns
    hdu = cls(data=data, header=header, character_as_bytes=character_as_bytes, **kwargs)
astropy/io/fits/hdu/table.py:848: in __init__
    from ....table import Table
astropy/table/__init__.py:41: in <module>
    from .column import Column, MaskedColumn, StringTruncateWarning, ColumnInfo
astropy/table/column.py:28: in <module>
    from .np_utils import fix_column_name
astropy/table/np_utils.py:15: in <module>
    from . import _np_utils
astropy/table/_np_utils.pyx:14: in init astropy.table._np_utils
    DTYPE = np.int
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

attr = 'int'

    def __getattr__(attr):
        # Warn for expired attributes, and return a dummy function
        # that always raises an exception.
        import warnings
        import math
        try:
            msg = __expired_functions__[attr]
        except KeyError:
            pass
        else:
            warnings.warn(msg, DeprecationWarning, stacklevel=2)
    
            def _expired(*args, **kwds):
                raise RuntimeError(msg)
    
            return _expired
    
        # Emit warnings for deprecated attributes
        try:
            val, msg = __deprecated_attrs__[attr]
        except KeyError:
            pass
        else:
            warnings.warn(msg, DeprecationWarning, stacklevel=2)
            return val
    
        if attr in __future_scalars__:
            # And future warnings for those that will change, but also give
            # the AttributeError
            warnings.warn(
                f"In the future `np.{attr}` will be defined as the "
                "corresponding NumPy scalar.", FutureWarning, stacklevel=2)
    
        if attr in __former_attrs__:
>           raise AttributeError(__former_attrs__[attr])
E           AttributeError: module 'numpy' has no attribute 'int'.
E           `np.int` was a deprecated alias for the builtin `int`. To avoid this error in existing code, use `int` by itself. Doing this will not modify any behavior and is safe. When replacing `np.int`, you may wish to use e.g. `np.int64` or `np.int32` to specify the precision. If you wish to review your current use, check the release note link for additional information.
E           The aliases was originally deprecated in NumPy 1.20; for more details and guidance see the original release note at:
E               https://numpy.org/devdocs/release/1.20.0-notes.html#deprecations

../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/numpy/__init__.py:319: AttributeError
_______________ TestTableFunctions.test_recarray_to_bintablehdu ________________

self = <astropy.io.fits.tests.test_table.TestTableFunctions object at 0x7d2b56d60bb0>

    def test_recarray_to_bintablehdu(self):
        bright = np.rec.array(
            [(1, 'Serius', -1.45, 'A1V'),
             (2, 'Canopys', -0.73, 'F0Ib'),
             (3, 'Rigil Kent', -0.1, 'G2V')],
            formats='int16,a20,float32,a10',
            names='order,name,mag,Sp')
>       hdu = fits.BinTableHDU(bright)

astropy/io/fits/tests/test_table.py:364: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
astropy/io/fits/hdu/table.py:848: in __init__
    from ....table import Table
astropy/table/__init__.py:41: in <module>
    from .column import Column, MaskedColumn, StringTruncateWarning, ColumnInfo
astropy/table/column.py:28: in <module>
    from .np_utils import fix_column_name
astropy/table/np_utils.py:15: in <module>
    from . import _np_utils
astropy/table/_np_utils.pyx:14: in init astropy.table._np_utils
    DTYPE = np.int
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

attr = 'int'

    def __getattr__(attr):
        # Warn for expired attributes, and return a dummy function
        # that always raises an exception.
        import warnings
        import math
        try:
            msg = __expired_functions__[attr]
        except KeyError:
            pass
        else:
            warnings.warn(msg, DeprecationWarning, stacklevel=2)
    
            def _expired(*args, **kwds):
                raise RuntimeError(msg)
    
            return _expired
    
        # Emit warnings for deprecated attributes
        try:
            val, msg = __deprecated_attrs__[attr]
        except KeyError:
            pass
        else:
            warnings.warn(msg, DeprecationWarning, stacklevel=2)
            return val
    
        if attr in __future_scalars__:
            # And future warnings for those that will change, but also give
            # the AttributeError
            warnings.warn(
                f"In the future `np.{attr}` will be defined as the "
                "corresponding NumPy scalar.", FutureWarning, stacklevel=2)
    
        if attr in __former_attrs__:
>           raise AttributeError(__former_attrs__[attr])
E           AttributeError: module 'numpy' has no attribute 'int'.
E           `np.int` was a deprecated alias for the builtin `int`. To avoid this error in existing code, use `int` by itself. Doing this will not modify any behavior and is safe. When replacing `np.int`, you may wish to use e.g. `np.int64` or `np.int32` to specify the precision. If you wish to review your current use, check the release note link for additional information.
E           The aliases was originally deprecated in NumPy 1.20; for more details and guidance see the original release note at:
E               https://numpy.org/devdocs/release/1.20.0-notes.html#deprecations

../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/numpy/__init__.py:319: AttributeError
_____________ TestTableFunctions.test_numpy_ndarray_to_bintablehdu _____________

self = <astropy.io.fits.tests.test_table.TestTableFunctions object at 0x7d2b56d60850>

    def test_numpy_ndarray_to_bintablehdu(self):
        desc = np.dtype({'names': ['order', 'name', 'mag', 'Sp'],
                         'formats': ['int', 'S20', 'float32', 'S10']})
        a = np.array([(1, 'Serius', -1.45, 'A1V'),
                      (2, 'Canopys', -0.73, 'F0Ib'),
                      (3, 'Rigil Kent', -0.1, 'G2V')], dtype=desc)
>       hdu = fits.BinTableHDU(a)

astropy/io/fits/tests/test_table.py:378: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
astropy/io/fits/hdu/table.py:848: in __init__
    from ....table import Table
astropy/table/__init__.py:41: in <module>
    from .column import Column, MaskedColumn, StringTruncateWarning, ColumnInfo
astropy/table/column.py:28: in <module>
    from .np_utils import fix_column_name
astropy/table/np_utils.py:15: in <module>
    from . import _np_utils
astropy/table/_np_utils.pyx:14: in init astropy.table._np_utils
    DTYPE = np.int
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

attr = 'int'

    def __getattr__(attr):
        # Warn for expired attributes, and return a dummy function
        # that always raises an exception.
        import warnings
        import math
        try:
            msg = __expired_functions__[attr]
        except KeyError:
            pass
        else:
            warnings.warn(msg, DeprecationWarning, stacklevel=2)
    
            def _expired(*args, **kwds):
                raise RuntimeError(msg)
    
            return _expired
    
        # Emit warnings for deprecated attributes
        try:
            val, msg = __deprecated_attrs__[attr]
        except KeyError:
            pass
        else:
            warnings.warn(msg, DeprecationWarning, stacklevel=2)
            return val
    
        if attr in __future_scalars__:
            # And future warnings for those that will change, but also give
            # the AttributeError
            warnings.warn(
                f"In the future `np.{attr}` will be defined as the "
                "corresponding NumPy scalar.", FutureWarning, stacklevel=2)
    
        if attr in __former_attrs__:
>           raise AttributeError(__former_attrs__[attr])
E           AttributeError: module 'numpy' has no attribute 'int'.
E           `np.int` was a deprecated alias for the builtin `int`. To avoid this error in existing code, use `int` by itself. Doing this will not modify any behavior and is safe. When replacing `np.int`, you may wish to use e.g. `np.int64` or `np.int32` to specify the precision. If you wish to review your current use, check the release note link for additional information.
E           The aliases was originally deprecated in NumPy 1.20; for more details and guidance see the original release note at:
E               https://numpy.org/devdocs/release/1.20.0-notes.html#deprecations

../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/numpy/__init__.py:319: AttributeError
______ TestTableFunctions.test_numpy_ndarray_to_bintablehdu_with_unicode _______

self = <astropy.io.fits.tests.test_table.TestTableFunctions object at 0x7d2b570be670>

    def test_numpy_ndarray_to_bintablehdu_with_unicode(self):
        desc = np.dtype({'names': ['order', 'name', 'mag', 'Sp'],
                         'formats': ['int', 'U20', 'float32', 'U10']})
        a = np.array([(1, u'Serius', -1.45, u'A1V'),
                      (2, u'Canopys', -0.73, u'F0Ib'),
                      (3, u'Rigil Kent', -0.1, u'G2V')], dtype=desc)
>       hdu = fits.BinTableHDU(a)

astropy/io/fits/tests/test_table.py:391: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
astropy/io/fits/hdu/table.py:848: in __init__
    from ....table import Table
astropy/table/__init__.py:41: in <module>
    from .column import Column, MaskedColumn, StringTruncateWarning, ColumnInfo
astropy/table/column.py:28: in <module>
    from .np_utils import fix_column_name
astropy/table/np_utils.py:15: in <module>
    from . import _np_utils
astropy/table/_np_utils.pyx:14: in init astropy.table._np_utils
    DTYPE = np.int
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

attr = 'int'

    def __getattr__(attr):
        # Warn for expired attributes, and return a dummy function
        # that always raises an exception.
        import warnings
        import math
        try:
            msg = __expired_functions__[attr]
        except KeyError:
            pass
        else:
            warnings.warn(msg, DeprecationWarning, stacklevel=2)
    
            def _expired(*args, **kwds):
                raise RuntimeError(msg)
    
            return _expired
    
        # Emit warnings for deprecated attributes
        try:
            val, msg = __deprecated_attrs__[attr]
        except KeyError:
            pass
        else:
            warnings.warn(msg, DeprecationWarning, stacklevel=2)
            return val
    
        if attr in __future_scalars__:
            # And future warnings for those that will change, but also give
            # the AttributeError
            warnings.warn(
                f"In the future `np.{attr}` will be defined as the "
                "corresponding NumPy scalar.", FutureWarning, stacklevel=2)
    
        if attr in __former_attrs__:
>           raise AttributeError(__former_attrs__[attr])
E           AttributeError: module 'numpy' has no attribute 'int'.
E           `np.int` was a deprecated alias for the builtin `int`. To avoid this error in existing code, use `int` by itself. Doing this will not modify any behavior and is safe. When replacing `np.int`, you may wish to use e.g. `np.int64` or `np.int32` to specify the precision. If you wish to review your current use, check the release note link for additional information.
E           The aliases was originally deprecated in NumPy 1.20; for more details and guidance see the original release note at:
E               https://numpy.org/devdocs/release/1.20.0-notes.html#deprecations

../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/numpy/__init__.py:319: AttributeError
_______________ TestTableFunctions.test_new_table_from_recarray ________________

self = <astropy.io.fits.tests.test_table.TestTableFunctions object at 0x7d2b56d60760>

    def test_new_table_from_recarray(self):
        bright = np.rec.array([(1, 'Serius', -1.45, 'A1V'),
                               (2, 'Canopys', -0.73, 'F0Ib'),
                               (3, 'Rigil Kent', -0.1, 'G2V')],
                              formats='int16,a20,float64,a10',
                              names='order,name,mag,Sp')
        hdu = fits.TableHDU.from_columns(bright, nrows=2)
    
        # Verify that all ndarray objects within the HDU reference the
        # same ndarray.
        assert (id(hdu.data._coldefs.columns[0].array) ==
                id(hdu.data._coldefs._arrays[0]))
        assert (id(hdu.data._coldefs.columns[0].array) ==
                id(hdu.columns.columns[0].array))
        assert (id(hdu.data._coldefs.columns[0].array) ==
                id(hdu.columns._arrays[0]))
    
        # Ensure I can change the value of one data element and it effects
        # all of the others.
        hdu.data[0][0] = 213
    
        assert hdu.data[0][0] == 213
        assert hdu.data._coldefs._arrays[0][0] == 213
        assert hdu.data._coldefs.columns[0].array[0] == 213
        assert hdu.columns._arrays[0][0] == 213
        assert hdu.columns.columns[0].array[0] == 213
    
        hdu.data._coldefs._arrays[0][0] = 100
    
        assert hdu.data[0][0] == 100
        assert hdu.data._coldefs._arrays[0][0] == 100
        assert hdu.data._coldefs.columns[0].array[0] == 100
        assert hdu.columns._arrays[0][0] == 100
        assert hdu.columns.columns[0].array[0] == 100
    
        hdu.data._coldefs.columns[0].array[0] = 500
        assert hdu.data[0][0] == 500
        assert hdu.data._coldefs._arrays[0][0] == 500
        assert hdu.data._coldefs.columns[0].array[0] == 500
        assert hdu.columns._arrays[0][0] == 500
        assert hdu.columns.columns[0].array[0] == 500
    
        hdu.columns._arrays[0][0] = 600
        assert hdu.data[0][0] == 600
        assert hdu.data._coldefs._arrays[0][0] == 600
        assert hdu.data._coldefs.columns[0].array[0] == 600
        assert hdu.columns._arrays[0][0] == 600
        assert hdu.columns.columns[0].array[0] == 600
    
        hdu.columns.columns[0].array[0] = 800
        assert hdu.data[0][0] == 800
        assert hdu.data._coldefs._arrays[0][0] == 800
        assert hdu.data._coldefs.columns[0].array[0] == 800
        assert hdu.columns._arrays[0][0] == 800
        assert hdu.columns.columns[0].array[0] == 800
    
        assert (hdu.data.field(0) ==
                np.array([800, 2], dtype=np.int16)).all()
        assert hdu.data[0][1] == 'Serius'
        assert hdu.data[1][1] == 'Canopys'
        assert (hdu.data.field(2) ==
                np.array([-1.45, -0.73], dtype=np.float64)).all()
        assert hdu.data[0][3] == 'A1V'
        assert hdu.data[1][3] == 'F0Ib'
    
        with ignore_warnings():
            hdu.writeto(self.temp('toto.fits'), overwrite=True)
    
        with fits.open(self.temp('toto.fits')) as hdul:
            assert (hdul[1].data.field(0) ==
                    np.array([800, 2], dtype=np.int16)).all()
            assert hdul[1].data[0][1] == 'Serius'
            assert hdul[1].data[1][1] == 'Canopys'
            assert (hdul[1].data.field(2) ==
                    np.array([-1.45, -0.73], dtype=np.float64)).all()
            assert hdul[1].data[0][3] == 'A1V'
            assert hdul[1].data[1][3] == 'F0Ib'
        del hdul
    
>       hdu = fits.BinTableHDU.from_columns(bright, nrows=2)

astropy/io/fits/tests/test_table.py:477: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
astropy/io/fits/hdu/table.py:129: in from_columns
    hdu = cls(data=data, header=header, character_as_bytes=character_as_bytes, **kwargs)
astropy/io/fits/hdu/table.py:848: in __init__
    from ....table import Table
astropy/table/__init__.py:41: in <module>
    from .column import Column, MaskedColumn, StringTruncateWarning, ColumnInfo
astropy/table/column.py:28: in <module>
    from .np_utils import fix_column_name
astropy/table/np_utils.py:15: in <module>
    from . import _np_utils
astropy/table/_np_utils.pyx:14: in init astropy.table._np_utils
    DTYPE = np.int
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

attr = 'int'

    def __getattr__(attr):
        # Warn for expired attributes, and return a dummy function
        # that always raises an exception.
        import warnings
        import math
        try:
            msg = __expired_functions__[attr]
        except KeyError:
            pass
        else:
            warnings.warn(msg, DeprecationWarning, stacklevel=2)
    
            def _expired(*args, **kwds):
                raise RuntimeError(msg)
    
            return _expired
    
        # Emit warnings for deprecated attributes
        try:
            val, msg = __deprecated_attrs__[attr]
        except KeyError:
            pass
        else:
            warnings.warn(msg, DeprecationWarning, stacklevel=2)
            return val
    
        if attr in __future_scalars__:
            # And future warnings for those that will change, but also give
            # the AttributeError
            warnings.warn(
                f"In the future `np.{attr}` will be defined as the "
                "corresponding NumPy scalar.", FutureWarning, stacklevel=2)
    
        if attr in __former_attrs__:
>           raise AttributeError(__former_attrs__[attr])
E           AttributeError: module 'numpy' has no attribute 'int'.
E           `np.int` was a deprecated alias for the builtin `int`. To avoid this error in existing code, use `int` by itself. Doing this will not modify any behavior and is safe. When replacing `np.int`, you may wish to use e.g. `np.int64` or `np.int32` to specify the precision. If you wish to review your current use, check the release note link for additional information.
E           The aliases was originally deprecated in NumPy 1.20; for more details and guidance see the original release note at:
E               https://numpy.org/devdocs/release/1.20.0-notes.html#deprecations

../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/numpy/__init__.py:319: AttributeError
_____________________________ test_regression_5383 _____________________________

    def test_regression_5383():
    
        # Regression test for an undefined variable
    
        x = np.array([1, 2, 3])
        col = fits.Column(name='a', array=x, format='E')
>       hdu = fits.BinTableHDU.from_columns([col])

astropy/io/fits/tests/test_table.py:3050: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
astropy/io/fits/hdu/table.py:129: in from_columns
    hdu = cls(data=data, header=header, character_as_bytes=character_as_bytes, **kwargs)
astropy/io/fits/hdu/table.py:848: in __init__
    from ....table import Table
astropy/table/__init__.py:41: in <module>
    from .column import Column, MaskedColumn, StringTruncateWarning, ColumnInfo
astropy/table/column.py:28: in <module>
    from .np_utils import fix_column_name
astropy/table/np_utils.py:15: in <module>
    from . import _np_utils
astropy/table/_np_utils.pyx:14: in init astropy.table._np_utils
    DTYPE = np.int
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

attr = 'int'

    def __getattr__(attr):
        # Warn for expired attributes, and return a dummy function
        # that always raises an exception.
        import warnings
        import math
        try:
            msg = __expired_functions__[attr]
        except KeyError:
            pass
        else:
            warnings.warn(msg, DeprecationWarning, stacklevel=2)
    
            def _expired(*args, **kwds):
                raise RuntimeError(msg)
    
            return _expired
    
        # Emit warnings for deprecated attributes
        try:
            val, msg = __deprecated_attrs__[attr]
        except KeyError:
            pass
        else:
            warnings.warn(msg, DeprecationWarning, stacklevel=2)
            return val
    
        if attr in __future_scalars__:
            # And future warnings for those that will change, but also give
            # the AttributeError
            warnings.warn(
                f"In the future `np.{attr}` will be defined as the "
                "corresponding NumPy scalar.", FutureWarning, stacklevel=2)
    
        if attr in __former_attrs__:
>           raise AttributeError(__former_attrs__[attr])
E           AttributeError: module 'numpy' has no attribute 'int'.
E           `np.int` was a deprecated alias for the builtin `int`. To avoid this error in existing code, use `int` by itself. Doing this will not modify any behavior and is safe. When replacing `np.int`, you may wish to use e.g. `np.int64` or `np.int32` to specify the precision. If you wish to review your current use, check the release note link for additional information.
E           The aliases was originally deprecated in NumPy 1.20; for more details and guidance see the original release note at:
E               https://numpy.org/devdocs/release/1.20.0-notes.html#deprecations

../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/numpy/__init__.py:319: AttributeError
______________________________ test_table_to_hdu _______________________________

    def test_table_to_hdu():
>       from ....table import Table

astropy/io/fits/tests/test_table.py:3056: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
astropy/table/__init__.py:41: in <module>
    from .column import Column, MaskedColumn, StringTruncateWarning, ColumnInfo
astropy/table/column.py:28: in <module>
    from .np_utils import fix_column_name
astropy/table/np_utils.py:15: in <module>
    from . import _np_utils
astropy/table/_np_utils.pyx:14: in init astropy.table._np_utils
    DTYPE = np.int
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

attr = 'int'

    def __getattr__(attr):
        # Warn for expired attributes, and return a dummy function
        # that always raises an exception.
        import warnings
        import math
        try:
            msg = __expired_functions__[attr]
        except KeyError:
            pass
        else:
            warnings.warn(msg, DeprecationWarning, stacklevel=2)
    
            def _expired(*args, **kwds):
                raise RuntimeError(msg)
    
            return _expired
    
        # Emit warnings for deprecated attributes
        try:
            val, msg = __deprecated_attrs__[attr]
        except KeyError:
            pass
        else:
            warnings.warn(msg, DeprecationWarning, stacklevel=2)
            return val
    
        if attr in __future_scalars__:
            # And future warnings for those that will change, but also give
            # the AttributeError
            warnings.warn(
                f"In the future `np.{attr}` will be defined as the "
                "corresponding NumPy scalar.", FutureWarning, stacklevel=2)
    
        if attr in __former_attrs__:
>           raise AttributeError(__former_attrs__[attr])
E           AttributeError: module 'numpy' has no attribute 'int'.
E           `np.int` was a deprecated alias for the builtin `int`. To avoid this error in existing code, use `int` by itself. Doing this will not modify any behavior and is safe. When replacing `np.int`, you may wish to use e.g. `np.int64` or `np.int32` to specify the precision. If you wish to review your current use, check the release note link for additional information.
E           The aliases was originally deprecated in NumPy 1.20; for more details and guidance see the original release note at:
E               https://numpy.org/devdocs/release/1.20.0-notes.html#deprecations

../miniconda3/envs/astropy__astropy__1.3/lib/python3.9/site-packages/numpy/__init__.py:319: AttributeError
==================================== PASSES ====================================
=========================== short test summary info ============================
PASSED astropy/io/fits/tests/test_checksum.py::TestChecksumFunctions::test_sample_file
PASSED astropy/io/fits/tests/test_checksum.py::TestChecksumFunctions::test_image_create
PASSED astropy/io/fits/tests/test_checksum.py::TestChecksumFunctions::test_scaled_data
PASSED astropy/io/fits/tests/test_checksum.py::TestChecksumFunctions::test_scaled_data_auto_rescale
PASSED astropy/io/fits/tests/test_checksum.py::TestChecksumFunctions::test_uint16_data
PASSED astropy/io/fits/tests/test_checksum.py::TestChecksumFunctions::test_groups_hdu_data
PASSED astropy/io/fits/tests/test_checksum.py::TestChecksumFunctions::test_ascii_table_data
PASSED astropy/io/fits/tests/test_checksum.py::TestChecksumFunctions::test_open_with_no_keywords
PASSED astropy/io/fits/tests/test_checksum.py::TestChecksumFunctions::test_writeto_convenience
PASSED astropy/io/fits/tests/test_checksum.py::TestChecksumFunctions::test_hdu_writeto
PASSED astropy/io/fits/tests/test_checksum.py::TestChecksumFunctions::test_datasum_only
PASSED astropy/io/fits/tests/test_table.py::TestTableFunctions::test_ascii_table
PASSED astropy/io/fits/tests/test_table.py::test_regression_scalar_indexing
SKIPPED [1] astropy/io/fits/tests/test_table.py:2468: condition: not HAVE_OBJGRAPH
SKIPPED [1] astropy/io/fits/tests/test_table.py:2482: condition: not HAVE_OBJGRAPH
ERROR astropy/io/fits/tests/test_table.py::TestTableFunctions::test_new_table_from_recarray
ERROR astropy/io/fits/tests/test_table.py::TestTableFunctions::test_new_fitsrec
ERROR astropy/io/fits/tests/test_table.py::TestTableFunctions::test_appending_a_column
ERROR astropy/io/fits/tests/test_table.py::TestTableFunctions::test_adding_a_column
ERROR astropy/io/fits/tests/test_table.py::TestTableFunctions::test_merge_tables
ERROR astropy/io/fits/tests/test_table.py::TestTableFunctions::test_modify_column_attributes
ERROR astropy/io/fits/tests/test_table.py::TestTableFunctions::test_mask_array
ERROR astropy/io/fits/tests/test_table.py::TestTableFunctions::test_slice_a_row
ERROR astropy/io/fits/tests/test_table.py::TestTableFunctions::test_fits_record_len
ERROR astropy/io/fits/tests/test_table.py::TestTableFunctions::test_add_data_by_rows
ERROR astropy/io/fits/tests/test_table.py::TestTableFunctions::test_assign_multiple_rows_to_table
ERROR astropy/io/fits/tests/test_table.py::TestTableFunctions::test_verify_data_references
ERROR astropy/io/fits/tests/test_table.py::TestTableFunctions::test_new_table_with_ndarray
ERROR astropy/io/fits/tests/test_table.py::TestTableFunctions::test_new_table_with_fits_rec
ERROR astropy/io/fits/tests/test_table.py::TestTableFunctions::test_bin_table_hdu_constructor
ERROR astropy/io/fits/tests/test_table.py::TestTableFunctions::test_constructor_name_arg
ERROR astropy/io/fits/tests/test_table.py::TestTableFunctions::test_constructor_ver_arg
ERROR astropy/io/fits/tests/test_table.py::TestTableFunctions::test_unicode_colname
ERROR astropy/io/fits/tests/test_table.py::TestTableFunctions::test_bin_table_with_logical_array
ERROR astropy/io/fits/tests/test_table.py::TestTableFunctions::test_fits_rec_column_access
ERROR astropy/io/fits/tests/test_table.py::TestTableFunctions::test_table_with_zero_width_column
ERROR astropy/io/fits/tests/test_table.py::TestTableFunctions::test_string_column_padding
ERROR astropy/io/fits/tests/test_table.py::TestTableFunctions::test_multi_dimensional_columns
ERROR astropy/io/fits/tests/test_table.py::TestTableFunctions::test_bin_table_init_from_string_array_column
ERROR astropy/io/fits/tests/test_table.py::TestTableFunctions::test_columns_with_truncating_tdim
ERROR astropy/io/fits/tests/test_table.py::TestTableFunctions::test_string_array_round_trip
ERROR astropy/io/fits/tests/test_table.py::TestTableFunctions::test_new_table_with_nd_column
ERROR astropy/io/fits/tests/test_table.py::TestTableFunctions::test_mismatched_tform_and_tdim
ERROR astropy/io/fits/tests/test_table.py::TestTableFunctions::test_tdim_of_size_one
ERROR astropy/io/fits/tests/test_table.py::TestTableFunctions::test_slicing
ERROR astropy/io/fits/tests/test_table.py::TestTableFunctions::test_array_slicing
ERROR astropy/io/fits/tests/test_table.py::TestTableFunctions::test_array_broadcasting
ERROR astropy/io/fits/tests/test_table.py::TestTableFunctions::test_array_slicing_readonly
ERROR astropy/io/fits/tests/test_table.py::TestTableFunctions::test_dump_load_round_trip
ERROR astropy/io/fits/tests/test_table.py::TestTableFunctions::test_dump_load_array_colums
ERROR astropy/io/fits/tests/test_table.py::TestTableFunctions::test_load_guess_format
ERROR astropy/io/fits/tests/test_table.py::TestTableFunctions::test_attribute_field_shadowing
ERROR astropy/io/fits/tests/test_table.py::TestTableFunctions::test_table_from_bool_fields
ERROR astropy/io/fits/tests/test_table.py::TestTableFunctions::test_table_from_bool_fields2
ERROR astropy/io/fits/tests/test_table.py::TestTableFunctions::test_bool_column_update
ERROR astropy/io/fits/tests/test_table.py::TestTableFunctions::test_missing_tnull
ERROR astropy/io/fits/tests/test_table.py::TestTableFunctions::test_blank_field_zero
ERROR astropy/io/fits/tests/test_table.py::TestTableFunctions::test_column_array_type_mismatch
ERROR astropy/io/fits/tests/test_table.py::TestTableFunctions::test_table_none
ERROR astropy/io/fits/tests/test_table.py::TestTableFunctions::test_unncessary_table_load
ERROR astropy/io/fits/tests/test_table.py::TestTableFunctions::test_table_from_columns_of_other_table
ERROR astropy/io/fits/tests/test_table.py::TestTableFunctions::test_bintable_to_asciitable
ERROR astropy/io/fits/tests/test_table.py::TestTableFunctions::test_pickle - ...
ERROR astropy/io/fits/tests/test_table.py::TestTableFunctions::test_zero_length_table
ERROR astropy/io/fits/tests/test_table.py::TestTableFunctions::test_dim_column_byte_order_mismatch
ERROR astropy/io/fits/tests/test_table.py::TestTableFunctions::test_fits_rec_from_existing
ERROR astropy/io/fits/tests/test_table.py::TestTableFunctions::test_update_string_column_inplace
ERROR astropy/io/fits/tests/test_table.py::TestTableFunctions::test_dump_clobber_vs_overwrite
ERROR astropy/io/fits/tests/test_table.py::TestVLATables::test_variable_length_columns
ERROR astropy/io/fits/tests/test_table.py::TestVLATables::test_extend_variable_length_array
ERROR astropy/io/fits/tests/test_table.py::TestVLATables::test_variable_length_table_format_pd_from_object_array
ERROR astropy/io/fits/tests/test_table.py::TestVLATables::test_variable_length_table_format_pd_from_list
ERROR astropy/io/fits/tests/test_table.py::TestVLATables::test_variable_length_table_format_pa_from_object_array
ERROR astropy/io/fits/tests/test_table.py::TestVLATables::test_variable_length_table_format_pa_from_list
ERROR astropy/io/fits/tests/test_table.py::TestVLATables::test_getdata_vla - ...
ERROR astropy/io/fits/tests/test_table.py::TestVLATables::test_copy_vla - pyt...
ERROR astropy/io/fits/tests/test_table.py::TestColumnFunctions::test_column_format_interpretation
ERROR astropy/io/fits/tests/test_table.py::TestColumnFunctions::test_zero_precision_float_column
ERROR astropy/io/fits/tests/test_table.py::TestColumnFunctions::test_column_array_type_mismatch
ERROR astropy/io/fits/tests/test_table.py::TestColumnFunctions::test_new_coldefs_with_invalid_seqence
ERROR astropy/io/fits/tests/test_table.py::TestColumnFunctions::test_pickle
ERROR astropy/io/fits/tests/test_table.py::TestColumnFunctions::test_column_lookup_by_name
ERROR astropy/io/fits/tests/test_table.py::TestColumnFunctions::test_column_attribute_change_after_removal
ERROR astropy/io/fits/tests/test_table.py::TestColumnFunctions::test_x_column_deepcopy
ERROR astropy/io/fits/tests/test_table.py::TestColumnFunctions::test_p_column_deepcopy
ERROR astropy/io/fits/tests/test_table.py::TestColumnFunctions::test_column_verify_keywords
ERROR astropy/io/fits/tests/test_table.py::TestColumnFunctions::test_column_verify_start
FAILED astropy/io/fits/tests/test_checksum.py::TestChecksumFunctions::test_binary_table_data
FAILED astropy/io/fits/tests/test_checksum.py::TestChecksumFunctions::test_variable_length_table_data
FAILED astropy/io/fits/tests/test_checksum.py::TestChecksumFunctions::test_compressed_image_data
FAILED astropy/io/fits/tests/test_checksum.py::TestChecksumFunctions::test_compressed_image_data_int16
FAILED astropy/io/fits/tests/test_checksum.py::TestChecksumFunctions::test_compressed_image_data_float32
FAILED astropy/io/fits/tests/test_checksum.py::TestChecksumFunctions::test_append
FAILED astropy/io/fits/tests/test_checksum.py::TestChecksumFunctions::test_hdu_writeto_existing
FAILED astropy/io/fits/tests/test_checksum.py::TestChecksumFunctions::test_open_update_mode_preserve_checksum
FAILED astropy/io/fits/tests/test_checksum.py::TestChecksumFunctions::test_open_update_mode_update_checksum
FAILED astropy/io/fits/tests/test_checksum.py::TestChecksumFunctions::test_overwrite_invalid
FAILED astropy/io/fits/tests/test_table.py::TestTableFunctions::test_constructor_copies_header
FAILED astropy/io/fits/tests/test_table.py::TestTableFunctions::test_open - A...
FAILED astropy/io/fits/tests/test_table.py::TestTableFunctions::test_binary_table
FAILED astropy/io/fits/tests/test_table.py::TestTableFunctions::test_endianness
FAILED astropy/io/fits/tests/test_table.py::TestTableFunctions::test_column_endianness
FAILED astropy/io/fits/tests/test_table.py::TestTableFunctions::test_recarray_to_bintablehdu
FAILED astropy/io/fits/tests/test_table.py::TestTableFunctions::test_numpy_ndarray_to_bintablehdu
FAILED astropy/io/fits/tests/test_table.py::TestTableFunctions::test_numpy_ndarray_to_bintablehdu_with_unicode
FAILED astropy/io/fits/tests/test_table.py::TestTableFunctions::test_new_table_from_recarray
FAILED astropy/io/fits/tests/test_table.py::test_regression_5383 - AttributeE...
FAILED astropy/io/fits/tests/test_table.py::test_table_to_hdu - AttributeErro...
============= 21 failed, 13 passed, 2 skipped, 72 errors in 11.09s =============
ERROR conda.cli.main_run:execute(124): `conda run pytest --no-header -rA -p no:cacheprovider astropy/io/fits/tests/test_checksum.py astropy/io/fits/tests/test_table.py` failed. (See above for error)

 
[astropy__astropy__1.3] [astropy__astropy-6938] Return Code: 1 

>>>>> Some Tests Failed
[astropy__astropy__1.3] [astropy__astropy-6938] Test script run successful 
